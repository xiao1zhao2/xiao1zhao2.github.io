<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言高级编程--7内存管理]]></title>
    <url>%2F2017%2F12%2F25%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇围绕C语言内存管理，讨论了变量存储模型、程序内存分配以及动态内存分配的使用方法，以及其使用注意事项，这些内容需结合函数、指针等知识进行综合分析。 存储模型 变量是对程序中数据的存储空间的抽象。一个变量可以通过存储期、作用域、链接点来描述。 存储期（生命期）：表示变量在内存中保存的时间。分为静态变量和动态变量。静态变量是编译时分配存储空间，从程序开始到程序结束。文件作用域的变量具有静态存储期。动态存储变量在程序执行中使用它时才分配存储空间，使用完立即释放。代码块作用域的变量具有动态存储期，例如函数的形参。函数定义时并不给形参分配存储空间，只有在函数被调用时，才予以分配。 作用域：表示变量出现有效区域。分为三种，代码块内作用域（即局部变量的情况）、函数原型作用域（从变量定义处到原型声明末尾，编译器只关心参数类型，不关心名字）、文件作用域（函数之外定义的变量具有文件作用域，也称为全局变量）。 链接点：用来说明程序哪些部分可以使用该变量。分为内部链接（一个文件内有效，使用static）、外部链接(一个或多个文件有效)、空链接（代码块作用域或者函数原型作用域）。 分类从存储期、作用域、链接点三个方面考虑，将变量的存储模型分为五类。 自动：使用关键字auto，可省略。一个代码块内或者函数头部声明的变量，即所谓的普通局部变量，具有动态存储期，代码块作用域、空链接。如果未初始化，则值不确定。 寄存器: 使用关键词register，具有自动存储期、代码块作用域和空链接。由于变量在寄存器中，不能使用取地址运算符获取变量的地址。未初始化则值不确定。 具有外部链接的静态：在所有函数外定义未使用static修饰的变量，即通常的全局变量，具有静态存储期，文件作用域和外部链接。仅在编译时初始化一次，默认为0,如果要在其他文件中使用，需要使用关键词extern。通常在.c文件定义，在.h文件中声明为外部变量。但不能在头文件为变量赋初值。 具有内部链接的静态：使用static修饰的全局变量，具有静态存储期、文件作用域、内部链接，只能在同一个文件中使用。仅在编译时初始化一次，默认为0。 空链接的静态：即static修饰局部变量，具有静态存储期、代码块作用域和空链接，仅在编译时初始化一次，默认为0。适用于多次调用函数且要求保留这些变量的值，可以考虑使用静态局部变量。 说明： 存储期是从时间上考虑变量，而作用域是从空间上考虑变量。要注意区别。 在函数专题中，提及函数返回值不能是局部变量，可以是静态局部变量或者堆上的内容。 注意区分一些概念。例如动态存储期。动态存储期是指局部变量空间在使用时才分配，且使用完就释放了，是相对于静态存储期而言。而动态分配是指程序员可以自己手动分配内存空间，是相对于自动分配而言。 static关键词的作用： 修饰全局变量，限制其作用域，只能在本文件中使用。 修饰局部变量，扩展其生存期，其值能保持到下一次调用，到程序结束时释放。 修饰函数，限制其作用域，只能在本文件中使用。 参考文献：C语言编程之存储模型、链接C语言存储模型 内存分配一个在运行的C语言程序占用内存的情况，分为以下几个区域： 代码区：只读，存放CPU执行的机器指令。 已初始化的全局数据与静态数据区：包括全局变量、静态变量（全局或局部）、常量数据（如字符串常量）。 未初始化数据区：即BSS区，存放未初始化的全局变量。 堆区：用于动态分配内存。位于BSS区和栈区之间。 栈区：存放函数参数、局部变量等。 说明： 这里的堆区别于数据结构中的堆，类似于链表。这里的栈，类似于数据结构中的栈，符合先进先出的规则。 size exename可以看到可执行文件各个区的大小，包括text、data、BSS，这里没有堆和栈，是存储时的三个区域，当程序执行时，才会有堆和栈。 ulimit -a命令可以查看资源限制的设定，包括栈空间、可打开的文件数等。 堆和栈的区别如下： 管理方式：堆区空间申请和释放需要程序员控制，而栈区由编译器自动管理。 空间大小：堆区内存不连续，空间大，而栈区连续空间，空间较小。 是否产生碎片：堆区需要频繁的malloc，容易造成内存空间不连续，产生碎片。 增长方向：堆区向着内存地址增加的方向，栈区向着内存地址减小的方向。 分配效率：堆区的效率低于栈区。 参考文档：C语言中内存分配 动态内存 通常情况下，编译器根据变量的类型知道所需的内存空间，在合适的时间分配确定的存储空间。在栈上创建局部变量，函数执行完毕自动释放存储单元，效率高，但分配的内存空间有限。该方式的分配和释放都是自动进行。 而有的情况只有在程序运行的时候才能确定内存分配大小，系统根据运行时的要求进行内存分配，称为动态存储分配。动态存储分配在堆上进行。使用malloc函数手动分配，使用free函数手动释放，因此其生存期由程序员决定。 对于动态分配的内存唯一的访问方式是通过指针间接访问。malloc函数在内存中动态的分配一个长度为size的连续空间，返回指向所分配连续空间起始地址的指针。内存空间有限，须在不用时，使用free函数显式释放空间。函数原型如下： malloc函数1void *malloc(size_t num); free函数1void free(void *p); 说明： malloc函数本身并不识别要申请的内存是什么类型，只关心申请内存的大小。在实际调用中，需要显式的进行强制类型转换。如果申请失败，返回NULL，因此要做错误判断。 堆区不会自动在分配时初始化，必须显式的进行初始化。例如：memset(p,0,n*sizeof(int));这一点在实践中应该注意。 分配的内存如果操作越界，会造成不可估量的后果，比如给char类型指针动态分配空间，需要考虑’\0’的存储空间。 使用堆上的空间，必须记得使用free释放，且只能释放一次。如果忘记释放，则会造成内存泄露。如果释放多次也会出错。 free 不允许释放部分内存。即free(p+2)是错误的。必须提供释放内存的起始地址。 free只是告诉系统这段空间不使用了，可以再次分配。但是其空间上的内容尚未改变，还可以访问，因此free后，通常置指针为NULL。释放的是堆空间，指针P在栈上，还指向原来的位置，因此可以访问，所以让其置NULL。 free只能释放堆空间。代码区、全局变量、静态变量区、栈区上的指针变量都不能用free释放空间。 malloc与free必须配对使用。不需要的内存空间都需要释放回收。 在函数内建立的动态对象在函数外仍然可以使用，这就是为什么函数可以返回堆上的地址的原因。因此堆上的空间称为自由空间。在函数运行时才能确定大小的情况，通常会在函数内动态分配内存并返回指针。但是在函数内申请动态空间而在函数外释放是一件很容易失控的事情，往往会出错。此种情况，要保证指针起始位置的正确赋值，并在函数外不使用指针时及时释放。 关于野指针：指向垃圾内存的指针。形成原因：（1）指针没有初始化；（2）指针free后没有置NULL。（3）指针操作超过了变量的作用范围，访问了非法内存。（4）返回指向栈内存的指针。 关于野指针会造成什么后果是难以估计的。若内存暂时空闲，可能程序正常运行，若内存再次被分配，又通过野指针对内存进行写操作，则原有合法数据会被覆盖。尽量应避免出现野指针。即指针初始化时置NULL，使用完毕释放后再次置NULL。 参考文档：C动态内存分配：（三）malloc/calloc/realloc/free使用注意事项 浅谈C语言内存管理、内存泄露、堆栈结构体指针内的指针变量成员的内存分配结构体内指针字符数组的释放free函数的实质 个人观点对于本节内容，主要是要掌握动态内存分配使用的各种注意事项，在实践中避免不规范的使用造成的内存错误。结合前面总结的指针、函数等内容综合分析。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>内存管理</tag>
        <tag>malloc</tag>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--6用户自定义数据类型(结构体)]]></title>
    <url>%2F2017%2F12%2F15%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--6%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E7%BB%93%E6%9E%84%E4%BD%93)%2F</url>
    <content type="text"><![CDATA[本篇文章以用户自定义数据类型为核心，重点讲解了结构体使用的相关知识点：包括定义、初始化、使用，结构体数组，结构体指针，以及讨论了一些在实践中需要考虑的问题。最后简要介绍了共用体和枚举。 结构体基本使用 结构体是一种构造类型，用户自定义的数据类型。包含多个不同数据类型的数据组合在一起进行描述。其中可以是基本类型也可以是构造类型。 结构体的作用：结构体的使用为处理复杂数据结构（如动态数据结构）提供了有效的手段。而且，为函数间传递不同类型的数据提供了方便。 结构体变量定义123456789101112131415161718192021222324252627方法1.先定义结构体，再定义变量名。适合于同时定义多个变量。struct 结构体名&#123; 数据类型 成员名１; 数据类型 成员名２; …… 数据类型 成员名n;&#125;;struct 结构体名 变量名;方法2.在定义结构体类型的同时定义变量。适合于定义全局结构体。struct 结构体名&#123; 数据类型 成员名１; 数据类型 成员名２; …… 数据类型 成员名n;&#125;变量名;方法3.直接定义结构体变量。适合于函数内部或者结构体嵌套，因为其他地方不可以再声明。struct &#123; 数据类型 成员名１; 数据类型 成员名２; …… 数据类型 成员名n;&#125;变量名; 说明： 在定义结构体时，不占内存空间，只有在定义结构体变量时，才分配内存空间。 struct关键字和结构体名必须写在一起，代表结构体类型名。因此为了方便，可以在定义结构体时使用typedef，这样在后面定义变量时则可以少写struct。 一般在头文件定义结构体，如果在定义结构体同时定义结构体变量，则是全局的结构体变量，在其他文件可以包含该头文件，使用该结构体变量，但是不能再定义其他结构体变量。因此定义结构体同时定义结构体变量只适合于该结构体只使用一次的情况。通常的做法是在头文件使用typedef 定义结构体新数据类型，在其他文件定义该数据类型的结构体变量。 结构体变量初始化按照结构体变量定义的方式不同，也有不同的初始化方法。1234567方法1：struct 结构体名 变量名=&#123;初始数据表&#125;;方法2：struct 结构体名&#123; 成员列表;&#125;变量名=&#123;初始数据表&#125;; 说明：可以对结构体部分成员赋初值。另外，在驱动编程部分也涉及结构体初始化问题。通常写法如下：1234567891011121314151617181920结构体变量初始化struct device=&#123; .id=-1, .name=&quot;key&quot;, ……&#125;;结构体数组变量初始化struct device[]=&#123; [0]=&#123; .id=-1, .name=&quot;key1&quot;, …… &#125;, [1]=&#123; .id=-1, .name=&quot;key2&quot;, …… &#125;,&#125;; 结构体变量使用 结构体变量的成员表示为：结构体变量名.成员名。 定义了结构体变量后，可以对结构体变量的成员赋值，也可以引用其地址。如果结构体当中又嵌套结构体，则只能一层一层找到最低层进行运算。 不能将一个结构体类型变量作为一个整体引用，只能对结构体变量中的成员加以引用。 同一类型的结构体变量之间可以互相赋值，但是数组不可以互相赋值。赋值后就相当于所有成员被赋值了。 两个结构体变量进行比较，可以各成员逐个比较，也可以使用memcpy比较内存内容。 结构体数组与结构体指针结构体数组 首先结构体数组是指数组元素为结构体，那么结构体数组的定义、初始化、使用和结构体变量的定义、初始化、使用类似，此处省略。 其次它又是数组，因此有数组的特性，数组的个数等于sizeof(数组名)/sizeof(结构体名)。 在使用时，结构体数组的元素值可以赋值给同一类型的另一个数组的元素，也可以赋值给同类型的结构体变量，也就是允许结构体之间互相赋值。 结构体指针用一个指针变量指向一个结构体变量，该指针变量的值是结构体变量的起始地址，该指针为结构体指针。 定义：1struct 结构体名 *结构体指针名; 说明： 在定义结构体变量的同时，也可以定义结构体指针变量，并且使用typedef定义一种新的数据类型。详见《C语言高级编程–1基础零碎知识》。 定义结构体指针变量只是说明该指针指向这种结构体类型，规定了其数据特性，并为结构体指针本身分配了内存空间，但是指针的内容尚未确定，指向随机的对象。 使用结构体指针访问成员，使用-&gt;。 扩展问题总结 在实践中经常用到结构体。在项目详细功能设计阶段需要设计项目所需的各个结构体。在阅读开源代码时，也需着重分析核心结构体，例如mosquitto源码、cJSON源码、onvif源码等，其中涉及的结构体举例详见gist。 结构体可以理解为面向对象编程语言中的对象，其中普通数据类型的成员相当于属性，函数指针成员相当于方法。 结构体中成员为函数指针：通常会在某个函数里赋初值，即赋值为某函数名(回调函数)。然后使用结构体成员调用函数，即会执行回调函数。 结构体中成员要使用字符串，可以用字符数组也可以使用字符指针。但是使用字符指针，需要使用malloc先动态分配内存，才可以赋值内容。字符数组和字符指针赋值，即填充字符串，都使用strcpy，strncpy，snprintf等函数，但需要注意这些函数各自的特点。 如果函数返回结构体指针，在函数体内对结构体填充内容，首先需要对结构体指针malloc动态分配内存。如果其中成员含有字符指针，需要使用malloc二次动态分配空间填充字符串。 为结构体指针分配动态内存时，只是为其中字符指针成员分配空间，并没有为其指向的字符串分配空间，因此需要二次分配。 注意free的时机，两次分配的内存空间并不连续。如果在函数外需要访问结构体内容，访问完毕需要先释放字符指针成员的空间，再释放结构体指针的空间。且不可以在函数内释放字符指针成员空间。 正是由于第二点使用的不方便，可以定义零长度数组成员，实现连续空间的分配和释放，详见参考文档《C语言结构体里的成员数组和指针》。 关于结构体作为函数返回值：如果返回结构体，在函数内错误处理不便于返回。若返回结构体指针，出错时可以返回NULL。 关于结构体做形参：若使用结构体做形参，需要大面积赋值，且也不能改变实参的值，因此多使用结构体指针做形参。 关于函数返回结构体指针和函数形参为结构体指针的选择：和其他函数考虑一样，如果是在函数内确定结构体数组大小，返回动态分配的内存内容，考虑返回结构体指针。如果要返回多于一个返回值，考虑使用多个形参。 使用示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889头文件 b.h：#ifndef _B_H_#define _B_H_typedef struct&#123; int num; char *name;&#125;student,*student_t;#endifmain.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;b.h&quot;student_t set_info()&#123; int n = 2; //为结构体指针分配空间 student_t studentP=(student_t)malloc(sizeof(student)*n); //64位系统，8字节对齐 printf(&quot;%lu\n&quot;,sizeof(student));//16 printf(&quot;%lu\n&quot;,sizeof(int));//4 printf(&quot;%p\n&quot;,studentP); printf(&quot;%p\n&quot;,&amp;studentP[0].num); //只是分配了存放指针成员的内存空间，指针指向的内容空间没有分配 printf(&quot;%p\n&quot;,&amp;studentP[0].name); printf(&quot;%p\n&quot;,&amp;studentP[1].num); printf(&quot;%p\n&quot;,&amp;studentP[1].name); studentP[0].num=1; //为字符指针成员所指向的内容分配空间 studentP[0].name = (char *)malloc(sizeof(char)*10); //使用snprintf赋值 snprintf(studentP[0].name,10,&quot;%s&quot;,&quot;youbo&quot;); studentP[1].num=2; studentP[1].name = (char *)malloc(sizeof(char)*10); snprintf(studentP[1].name,10,&quot;%s&quot;,&quot;xiaozhao&quot;); //其值为所指向字符串的首地址，和前面的地址并不连续 printf(&quot;%p\n&quot;,studentP[0].name); printf(&quot;%p\n&quot;,&amp;studentP[0].name[0]); printf(&quot;%p\n&quot;,&amp;studentP[0].name[1]); printf(&quot;%p\n&quot;,studentP[1].name); printf(&quot;%p\n&quot;,&amp;studentP[1].name[0]); printf(&quot;%p\n&quot;,&amp;studentP[1].name[1]); //如果在该处释放后，函数外不能访问内容 //free(studentP[0].name); //free(studentP[1].name); return studentP;&#125;int main(int argc,const char *argv[])&#123; student_t studentP = NULL; studentP = set_info(); printf(&quot;%d %s\n&quot;,studentP[0].num,studentP[0].name); printf(&quot;%d %s\n&quot;,studentP[1].num,studentP[1].name); free(studentP[0].name); free(studentP[1].name); studentP[0].name = NULL; studentP[1].name = NULL;// printf(&quot;%s\n&quot;,studentP[0].name); free(studentP); // 如果不释放studentP[0].name,只释放studentP,在置NULL之前还可以访问成员指向的内容// printf(&quot;%s\n&quot;,studentP[0].name); studentP = NULL; // 置NULL后再访问一定会出现段错误，可以避免错误。// printf(&quot;%s\n&quot;,studentP[0].name);// 必须在studentP释放之前释放指针成员空间// free(studentP[0].name);// free(studentP[1].name);// studentP[0].name = NULL;// studentP[1].name = NULL; return 0;&#125; 参考文档：c语言里用结构体和指针函数实现面向对象思想对结构体中字符串指针和字符数组赋值的区别是什么C语言，结构体中字符串的声明（采用字符指针还是字符数组）C语言结构体里的成员数组和指针strcpy和strdup比较和详解结构体内的指针需要逐个释放吗？ 位域位域是指把一个字节的二进位划分为不同的区域，并说明每个区域的位数。每个域有一个域名，允许程序按域名操作。这样可以将几个不同对象用一个字节的二进制位域来表示，从而可以节约空间。 定义：1234struct 位域结构体名&#123; 类型说明符 位域名:位域长度;&#125;; 使用示例:123456789101112131415161718192021222324252627282930313233343536linux内核源码 linux-3.14/include/linux/tcp.hstruct tcphdr &#123; __be16 source; __be16 dest; __be32 seq; __be32 ack_seq;#if defined(__LITTLE_ENDIAN_BITFIELD) __u16 res1:4, doff:4, fin:1, syn:1, rst:1, psh:1, ack:1, urg:1, ece:1, cwr:1;#elif defined(__BIG_ENDIAN_BITFIELD) __u16 doff:4, res1:4, cwr:1, ece:1, urg:1, ack:1, psh:1, rst:1, syn:1, fin:1;#else#error &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;#endif __be16 window; __sum16 check; __be16 urg_ptr;&#125;; 说明: 位域不可以跨越字节，如果剩下的位不足以存放一个位域时，应该从下一单元起存放该位域，而上一字节剩下的部分用无名的位域来填充。 位域其实是一种结构类型，只是其成员是按照二进制位进行分配。 位域变量定义和使用方法都和结构体类似，此处省略。 位域在实践中用的较少，仅作了解。 共用体共用体又称为联合体。其定义、初始化、使用方法和结构体类似，但是在使用内存上有所不同。特点： 不同数据类型的数据使用共同的存储空间。 由于第一条的特点，因此各个成员的首地址相同。 由于第一条的特点，因此共用体变量起作用的成员是最后一次存放的成员，新的成员值会将旧的成员值覆盖。 共用体用在各数据类型占用空间差不多，且对各变量同时使用要求不高的场合。例如共享内存，每次只用到其中一个成员的情况。 使用示例：123456789101112131415161718192021e.g1信号灯集操作函数,第四个参数是一个共用体，适用于不同的情况。 int semctl(int semid, int semnum, int cmd, ...); union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */ unsigned short *array; /* Array for GETALL, SETALL */ struct seminfo *__buf; /* Buffer for IPC_INFO (Linux-specific) */&#125;;e.g2共用体测试字节序是大端还是小端union gy&#123; char a; short b; int c;&#125;;union gy t;t.c = 0x12345678;printf(&quot;%#x %#x %#x\n&quot;,t.a,t.b,t.c); 参考文档联合体（union）的使用方法及其本质共用体的定义与应用详细解析 sizeof作用于结构体和共用体 不考虑字节对齐，结构体的大小是所有成员大小之和。 不考虑字节对齐，共用体的大小是成员中占字节最大的字节数。 如果考虑字节对齐，结构体大小可能会变大，32位机4字节对齐，64位机8字节对齐。 如果考虑到对齐原则，那么定义结构体时，尽量注意顺序，4字节成员放前面，接着是2字节成员，最后是1字节成员。 如果出现某个数据总是与期望的不符，但不会波动，要考虑字节未对齐的问题。 参考文档：C语言字节对齐问题详解（对齐、字节序、网络序等） 枚举枚举用于变量取值有限的情况。定义：123enum 枚举名&#123;枚举列表&#125;; 说明： 如果不写取值，默认从0开始，是整型数据。如果想要改变，可以自定义每一个成员等于几。 如果没有显式赋值的成员值总是在前一个枚举成员的值上加１，允许不同成员具有相同的值。 枚举变量的定义，使用都是和结构体共用体类似，此处省略。 枚举是一种基本数据类型，因为其不可再分。 个人观点 至此，完成了C语言中四个重要知识点的梳理，包括数组、指针、函数、结构体。 总结起来，讨论了两个内容，一是数据类型：数组、指针、结构体。二是函数。而函数中有形参和返回值，这些都是变量，因此又和数组、指针、结构体等数据类型产生关系。因此需要综合考虑。 应先理解每一个知识点的含义，再进行组合考虑。比如数组指针、指针数组、字符数组、字符指针、函数指针、指针函数、函数指针数组、函数传递指针、函数传递数组、函数传递字符数组、函数传递字符指针、函数传递结构体、函数传递结构体指针、函数返回指针、函数返回指向数组的指针、函数返回结构体 、结构体指针、结构体数组、结构体成员为字符数组、结构体成员为字符指针、结构体成员为函数指针。 要理解各个内容是在什么情况下使用，有什么特点好处，才会在遇到同样的情况下有意识的去使用这个知识点。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>指针</tag>
        <tag>结构体</tag>
        <tag>共用体</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--5函数]]></title>
    <url>%2F2017%2F12%2F11%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--5%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本篇文章以函数为核心，重点讲解函数指针和指针函数，以及与之密切相关的函数传参和函数返回值。在实践中应该结合这几个知识点综合考虑其使用。最后简单提及递归函数。 函数基础 函数是一个完成特定功能的代码模块，通常有参数，也可以沒有参数。通常要求有返回值，也可以是空值。 使用函数可以实现代码的复用，使程序更整洁，可读性更好。函数是实现模块化编程的重要工具。 定义12345&lt;数据类型&gt; &lt;函数名&gt;(形参说明)&#123; 语句序列； return (&lt;表达式&gt;);&#125; 说明： 这里的数据类型是指函数返回的数据类型。 return 表达式的类型要和函数返回类型一致，如果返回值为void,可以省略return不写。 如果不写数据类型，则默认为返回int型，而不是void型。 形参出现在被调函数当中，在整个函数体内都可以使用。形参在定义时编译系统并不分配存储空间，只有在调用该函数时才分配内存单元。调用结束内存单元被释放，故形参只有在函数调用时有效，调用结束时不能再使用。可结合《C语言高级编程–7内存管理》中的内容理解。 函数前可以使用static修饰，表示该函数只能在本文件内使用。默认函数是外部函数，用extern修饰，可以省略不写。 声明1&lt;数据类型&gt; &lt;函数名&gt;(形参说明); 说明： 函数声明又称为函数原型，function prototype。 形参说明中可以省略变量名，但是不能省略类型。因为编译器并不会检查变量名。 在调用函数前必须已进行了声明，要么是在头文件里面声明，要么被调用函数写在调用函数之前。 声明的作用是为了把函数名、返回值类型以及形参类型、个数和顺序通知编译系统，以便在调用该函数时，编译系统进行对照检查。 调用1函数名(实参说明) 说明： 实参可以是确切的数据，也可以是有确切值的表达式。 实参出现在主调函数当中，当函数调用时，主调函数把实参的值或者地址传送给被调函数的形参，从而实现函数间的数据传递。 函数调用可以作为一个运算量出现在表达式中,也可以作为单独的语句。 函数传参两种方式复制传递方式 原理：调用函数把实参传递给被调用函数，被调用函数会创建同类型的形参，并用实参进行初始化。即把实参赋值给一个新的变量，把实参的值复制到新建的形参的存储区域中，也就是函数内的变量和函数外的变量是存储在不同位置。 特点：被调用函数不能访问调用函数里的实参。即使改变了形参的值，函数调用完成后，形参被系统释放，不会改变实参的值。 地址传递方式 原理：调用函数把实参的地址传递给被调用函数。被调用函数对该地址的目标进行操作，相当于对实参本身的操作。此时，实参为变量的地址，形参为同类型的指针。 特点：被调用函数中通过地址解引用方式可以访问到函数外的实参，从而间接的改变实参的值。 说明： 复制传递和地址传递方式的区别，经典例子是交换两个数。 参数的传递是单向的，只能实参传递给形参。 除了复制传递和地址传递，也可以使用全局变量传参，但是使用全局变量传递参数的先后顺序不同会影响计算结果，应该少用。 C语言中都是按值传递。可以传递变量（复制传递），也可以传递变量的指针（地址传递）。而按引用传递的概念应该是出现在C++中。 关于结构体作为参数，因为结构体通常很大，而将实参赋值给形参会效率低下，因此通常考虑传递结构体指针。 关于函数返回值与函数传参，因为地址传递方式可以改变函数外的变量，相当于函数返回。因此当函数需要返回多于一个的值时，应考虑使用形参传递地址。 参考文档：24.C语言函数传参详解C语言中的值传参和引用传参是指什么？值传递和引用传递—–函数参数传递的两种方式 传递数组由于其特殊性，单独说明数组在函数之间的传递。这里是指在函数的形参里可以是数组形式。使用示例:12345678double testArray(double b[], int size)//相当于double testArray(double *b,int size)int test_array(int n,int m,int a[][m],int *p)//相当于int test_array(int n,int m,int (*a)[m],int *p)int main(int argc,const char *argv[])//相当于int main(int argc,const char **argv) 说明: 形参为数组形式时，本质是同级别的指针。相当于传递的是数组的首地址，由于数组存储的连续性，因此可以依次访问数组的所有元素。 通常除了传递数组名还要传递数组元素个数。此时实参为数组名。 在函数的内部，传入的数组名相当于是指向数组首地址的指针，因此此时求sizeof不是数组的大小，而是为4或者8。 形参中使用数组形式时，[]里的数字可有可无，因为它相当于一个指针，并不需要数组长度信息。 理解形参出现数组形式的原因可能是在函数内看起来像一个数组，可以作为数组使用。但实际上它会退化为一个指针。它带来的方便可能比它带来的歧义更多，因此最好使用同类型的指针，而不使用数组形式。 参考文档：《你必须知道的495个C语言问题》p65 6.4 指针函数与函数指针指针函数如果一个函数返回值是指针，则称函数为指针函数。定义:12345&lt;数据类型&gt; *&lt;函数名&gt;(形参说明)&#123; 语句序列； return (&lt;表达式&gt;);&#125; 错误使用示例：12345678910char *mystring(void)&#123; char str[20] =&#123;0&#125;; strcpy(str,&quot;hello&quot;); return str;&#125;int main(void)&#123; printf(&quot;%s\n&quot;,mystring);&#125; 分析：编译出现警告：function returns address of local variable(返回了局部变量的地址)，运行结果是打印乱码。局部变量是分配在栈上，函数执行完毕，局部变量自动释放，在主调函数中不能再访问。访问一段释放的内存是非法操作，显示乱码。如果修改了非法内存中的值，可能会有更严重的后果，不可预料。 函数正确返回指针的三种方法 12345678910111213141516171819202122232425262728293031323334353637383940414243441.使用static,static变量到程序结束时才会回收内存。char *mystring(void)&#123; static char str[20]; strcpy(str,&quot;hello&quot;); return str;&#125;int main(void)&#123; printf(&quot;%s\n&quot;,mystring);&#125;2.使用字符串常量，和静态变量类似，字符串常量也在程序结束时才释放内存。char *mystring(void)&#123; char *str = &quot;hello&quot;; return str;&#125;int main(void)&#123; printf(&quot;%s\n&quot;,mystring);&#125;3.使用malloc,动态分配空间。char *mystring(void)&#123; char *str = NULL; str = (char *)malloc(20); if(str == NULL) &#123; return str; &#125; strcpy(str,&quot;hello&quot;); return str;&#125;int main(void)&#123; char *s; if((s = mystring()) != NULL) &#123; printf(&quot;%s\n&quot;,s); free(s); &#125;&#125; 说明： 指针函数返回的地址在主调函数中必须是有效的，是可以访问的内存。 指针函数不可以返回局部变量的地址，可以返回的地址有三种：静态变量的地址，字符串常量的地址，堆上的地址。 在实践中使用较多的是第三种方式，在函数内使用malloc动态分配内存，填充内容后，返回指针。应注意可能涉及多次的malloc,例如为结构体指针分配内存空间，再为结构体成员分配内存空间。此外，还需注意在函数外合适的位置使用free释放指针并置NULL。 函数指针函数指针是用来存放函数地址的指针。函数地址是一个函数的入口地址。函数名代表了函数的入口地址。当一个函数指针指向了一个函数，就可以通过这个指针来调用这个函数。 定义：1&lt;数据类型&gt; (*&lt;函数名&gt;)(形参说明)； 说明： 数据类型是指函数指针所指向的函数的返回值的类型。 形参说明应该和指向的函数的形参说明保持一致。 函数指针做形参，使用函数名做实参。定义函数指针变量，也用函数名赋值。 使用函数指针调用函数时，写法为去掉数据类型，填入实参即可。相当于地址解引用调用函数。 定义函数指针时，形参里面的变量可以不写，但是类型不能省略。 关于函数名：函数名是一个符号，表示整个函数代码段的首地址，其实质是一个指针常量，所以在程序中使用到函数名时都是当地址用的，表示调用该函数。 关于回调函数：回调函数就是一个通过函数指针调用的函数。这个在实践中经常出现，应掌握。常用在中断发生，调用某个函数。该内容涉及结构体、多线程等内容，可另作讨论总结。 结构体中也可以定义函数指针成员，赋值为函数名，在适当时候调用回调函数。 参考文档：C语言函数指针基础Linux C 函数指针应用—回调函数C语言中的回调函数（Callback Function）结构体中定义函数指针 使用示例：12345678910111213141516171819202122232425262728293031323334353637383940e.g1用函数指针使用不同功能的函数int test(int a,int b,int (*pFunc)(int m,int n));int plus(int,int);int minus(int,int);int main()&#123; int x=5,y=8; int (*pFunc)(int a,int b);//注意定义函数指针的写法 pFunc = minux; printf(&quot;%d\n&quot;,(*pFunct)(x,y));//注意使用函数指针调用函数的写法 printf(&quot;%d\n&quot;,test(5,15,plus));&#125;int plus(int a,int b)&#123; return a+b;&#125;int minus(int a,int b)&#123; return a-b;&#125;int test(int a,int b,int (*pFunc)(int m,int n))&#123; return (*pFunc)(a,b);&#125;e.g2信号注册typedef void (*sighandler_t)(int);sighandler_t signal(int signum,sighandler_t handler);注意理解这里的typedef，typedef的作用是定义一种数据类型，这里相当于定义了一种函数指针类型，因此在其他地方使用时，就可以简化只写sighandler_t。例如函数原型中的形参和返回值。如果还是原来那种复杂的写法，则不易看懂。e.g3创建线程int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);e.g4快速排序，需要用户自定义元素比较规则。void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 总结起来，函数指针的用处有以下几点： 定义一种函数模板，结合void指针，处理不同数据类型实现相同功能的情况。例如比较两个对象的大小，对象是int、double、char*等类型。 定义一种函数模板，处理相同数据类型和个数，功能不同的情况。例如对两个整型数的加减乘除。 函数形参为函数指针，适用于库函数编写者，由用户使用时决定函数的具体使用方法。提高灵活性和通用性。 函数形参为函数指针，传递回调函数的函数名，在适当的时候调用回调函数。 递归函数 递归函数是指函数的函数体中直接或间接的调用了该函数自身的函数。 递归函数调用执行分为两步：递推和回归。函数实现是递推过程，函数调用是回归过程。 实例分析函数传参 实践中函数形参为指针时，通常会在函数内部通过地址解引用改变指针指向对象的内容，比如字符指针，在函数内赋值字符串。实参应该传递字符数组，而不要传递字符指针。 函数形参为指针，实参传递指针时，如果在函数内部通过地址解引用改变指针指向对象的内容，实参会有相应改变。如果在函数内部改变形参的地址，相当于普通变量值传递，实参不会有相应变化。 实践中函数定义使用形参和函数调用使用实参，其形参和实参对应关系有:形参为一级指针，实参为一维数组名。形参为行指针，实参为二维数组名。形参为二级指针，实参为一维指针数组名。形参为结构体指针，实参为结构体地址。形参为字符指针，实参为字符数组名。 使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566传递数组名和传递指针的不同，传递指针出现段错误。int get_cameraIP(uint8_t *str,uint8_t *cameraIP)&#123; uint8_t *p = str; uint8_t *begin = NULL; uint8_t *end = NULL; const char *d =&quot;.&quot;; int dot_flag = 0; int first_num_flag = 0; int last_num_flag = 0; int i = 0; int j = 0; while(*p != &apos;\0&apos;) &#123; if(isdigit(*p)&amp;&amp;first_num_flag == 0)//找到第一个数字 &#123; begin = p; first_num_flag = 1; &#125; if((dot_flag == 3) &amp;&amp; (!(isdigit(*p)) &amp;&amp; (last_num_flag == 0)))//找到最后一个IP数字 &#123; end = p; last_num_flag = 1; &#125; if(*p == &apos;.&apos;) &#123; dot_flag++; &#125; p++; &#125; for(i = 0 ;i &lt; (end-begin);i++) &#123; cameraIP[i] = str[begin-str+i];//提取IP字符串 &#125; return 0;&#125;int ONVIF_ClientDiscovery(void)&#123; …… struct __wsdd__ProbeMatches resp; retval = soap_recv___wsdd__ProbeMatches(soap, &amp;resp); if (resp.wsdd__ProbeMatches-&gt;ProbeMatch != NULL &amp;&amp; resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs != NULL) &#123; for(i = 0; i &lt; resp.wsdd__ProbeMatches-&gt;__sizeProbeMatch; i++) &#123; //printf(&quot;%s\n&quot;, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs); memset(CameraInfo[FoundDevNo].cameraIP,0,16);//全局变量使用前先清零 //将摄像头IP存入摄像头完整信息全局数组 //get_cameraIP(resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs,&amp;CameraInfo[FoundDevNo].cameraIP[0]); //解决段错误，传递数组名，而不是指针 uint8_t tmpip[256]=&#123;&#125;; sprintf(tmpip,&quot;%s&quot;,resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs); printf(&quot;%s\n&quot;,tmpip); get_cameraIP(tmpip,&amp;CameraInfo[FoundDevNo].cameraIP[0]); …… &#125; &#125;&#125; 参考文档：一级指针还是二级指针作函数参数（2）C语言中“指针”作为“函数参数”时的注意事项指针形参实参传递时需要注意 指针函数 指针函数返回指针，调用时，用同类型的指针变量接收即可。 在实践中返回堆上的地址用的多，涉及malloc和free的使用。需要考虑malloc多次，以及何时free。 关于函数返回值是指针类型或者用指针传递参数的选择：若需要返回多个值，考虑形参为指针。若返回动态内存，考虑函数返回值为指针。 在函数内的字符数组加了static,返回该数组名才能在主函数内访问。如果在主函数不能访问，考虑函数内的变量已经销毁，在适当的位置加上static。 使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201e.g1 指针函数返回堆上的地址。在函数中确定数组大小再动态分配空间。/* * 假设message是符合json格式的字符串，这里未对字符串的格式做检查 * 将控制json格式的字符串分割为原子字符串,以便后续处理 * eg:&#123;&quot;function&quot;:1,&quot;sensorID&quot;:1,&quot;sensorName&quot;:&quot;totalTime&quot;,&quot;valueType&quot;:2,&quot;value&quot;:0&#125; * */char **split_message(char *message,int *num)&#123; int commaNum = 0; int i = 0; int j = 0; int atomMessageNum = 0; int *commaPos = NULL; char **atomMessageArray = NULL; //统计逗号个数，按照协议，json格式应该是一个数组，数组元素是对象,这里称作控制数据原子包 for(i=1;i&lt;strlen(message); i++) &#123; if(message[i] == &apos;,&apos; &amp;&amp; message[i-1] == &apos;&#125;&apos; &amp;&amp; message[i+1] == &apos;&#123;&apos;) &#123; commaNum++; &#125; &#125; //控制数据原子包个数，并通过num返回 atomMessageNum = commaNum + 1; *num = atomMessageNum; //动态分配内存，这里是一个二级字符指针，指向一个字符指针数组，每个数组元素存放字符的首地址 atomMessageArray = (char **)malloc(sizeof(char *) * atomMessageNum); //动态分配内存，对字符指针数组里每个元素分配内存，便于后续使用strncpy赋值 for(i=0; i&lt;atomMessageNum; i++) &#123; atomMessageArray[i] = (char *)malloc(sizeof(char) * ATOMPAYLOAD_MAX); &#125; //数组元素只有一个 if(commaNum == 0) &#123; strncpy(atomMessageArray[0],message+1,strlen(message)-2-1+1); atomMessageArray[0][strlen(message)-2+1] = &apos;\0&apos;; &#125; //数组元素有多个 else if(commaNum &gt; 0) &#123; //统计每个逗号在整个message的位置，存放在动态分配的数组中 commaPos = (int *)malloc(sizeof(int) * commaNum); for(i=1;i&lt;strlen(message); i++) &#123; if(message[i] == &apos;,&apos; &amp;&amp; message[i-1] == &apos;&#125;&apos; &amp;&amp; message[i+1] == &apos;&#123;&apos;) &#123; commaPos[j] = i; j++; &#125; &#125; //第一个数组元素赋值 //起始位置：1 //结束位置：commaPos[0]-1 //长度：commaPos[0]-1-1+1 snprintf(atomMessageArray[0],commaPos[0]-1-1+2,&quot;%s&quot;,message+1); //第2个数组元素到第atomMessageNum-1个元素 //起始位置：commaPos[i-1]+1 //结束位置：commaPos[i]-1 //长度：commaPos[i]-1-(commaPos[i-1]+1)+1 for(i=1; i&lt;atomMessageNum-1; i++) &#123; snprintf(atomMessageArray[i],commaPos[i]-1-(commaPos[i-1]+1)+2,&quot;%s&quot;,message+commaPos[i-1]+1); &#125; //最后一个数组元素 //起始位置：commaPos[commaNum-1]+1 //结束位置：strlen(message)-2 //长度：strlen(message)-2-(commaPos[commaNum-1]+1)+1 snprintf(atomMessageArray[atomMessageNum-1],strlen(message)-2-(commaPos[commaNum-1]+1)+2,&quot;%s&quot;,message+commaPos[commaNum-1]+1); free(commaPos); &#125; return atomMessageArray;&#125;/* *控制数据解包，返回commandInfo指针，和个数 * */commandInfo_t control_payload_parse(char *message,int *num)&#123; char **p = NULL; commandInfo *commandInfoP = NULL; int i; int numTemp; //分割字符串为原子字符串，并获取个数 p = split_message(message,num); numTemp = *num; //动态分配内存空间，存放commandInfo结构体数组 commandInfoP = (commandInfo *)malloc(sizeof(commandInfo)*numTemp); for(i=0; i&lt;numTemp; i++) &#123; //结构体整体赋值 commandInfoP[i] = json_control_atom_unpack(p[i]); //挨个释放p[i]内存 free(p[i]); //判断所给message是否有格式异常，json_control_atom_unpack中异常时，整个结构体赋值0.这里没有对比所有结构体成员，足以判断 if(commandInfoP[i].commandType == 0 &amp;&amp; commandInfoP[i].sensor.sensorID == 0 &amp;&amp; commandInfoP[i].sensor.type == 0) &#123; return NULL; &#125; &#125; //释放二级指针动态分配的空间 free(p); return commandInfoP; &#125;e.g2 指针函数返回静态变量的地址。/* * json解析字符串,返回json结构体，和键指对个数n * 格式限定为： * &#123; * xxx:xxx * xxx:xxx * &#125; */jSONStruct *json_unpack(char *string,int *n)&#123; //函数调用完毕后该变量释放，在函数外不能访问其值，因此加上static static bool tmp; int num,i; //解析json字符串 jSONStruct *jSONStructP = NULL; cJSON *root = cJSON_Parse(string); //获取键值对个数 num = cJSON_GetArraySize(root); *n = num; if(num == 0) &#123; DEBUG_CUSTOMERR(&quot;json format error&quot;); return NULL; &#125; //动态分配内存，便于后面依次填充jSONStruct结构体的内容 jSONStructP = (jSONStruct *)malloc(sizeof(jSONStruct) * num); //获取每一个键值对内容 for(i=0;i&lt;num;i++) &#123; cJSON *jSON1 = cJSON_GetArrayItem(root,i); //填充key strncpy(jSONStructP[i].pKey,jSON1-&gt;string,strlen(jSON1-&gt;string)); jSONStructP[i].pKey[strlen(jSON1-&gt;string)] = &apos;\0&apos;; //按类型填充value和类型 if(cJSON_IsFalse(jSON1)) &#123; tmp = false; jSONStructP[i].pData = &amp;tmp; jSONStructP[i].type = JSON_BOOL; &#125; else if(cJSON_IsTrue(jSON1)) &#123; tmp = true; jSONStructP[i].pData = &amp;tmp; jSONStructP[i].type = JSON_BOOL; &#125; else if(cJSON_IsNumber(jSON1)) &#123; jSONStructP[i].pData = &amp;jSON1-&gt;valuedouble; //这里无法判断int还是double,统一为double jSONStructP[i].type = JSON_DOUBLE; &#125; else if(cJSON_IsString(jSON1)) &#123; //为&apos;\0&apos;也分配空间，否则字符串结束后跟着乱码 jSONStructP[i].pData = (char *)malloc(strlen(jSON1-&gt;valuestring)+1); strcpy((char *)jSONStructP[i].pData,jSON1-&gt;valuestring); jSONStructP[i].type = JSON_STRING; &#125; else &#123; DEBUG_CUSTOMERR(&quot;json object type error&quot;); return NULL; &#125; &#125; return jSONStructP;&#125; 函数指针实践中常在有中断的情况下使用回调函数。通常在初始化时，将结构体的函数指针成员赋值为函数名(即回调函数名)，则在中断触发时，会调用回调函数。 1234567891011121314151617181920212223242526272829303132333435363738394041e.g串口中断方式处理/* * 信号处理函数,如果收到串口中断，置wait_flag=false * 由于向串口发送数据也会触发信号，因此这里区分串口发送触发的信号和串口接收触发的信号 */void signal_handler_IO(int status)//回调函数&#123; //printf(&quot;recv signal\n&quot;); if(uartSend == false) &#123; waitFlag = false; &#125; else &#123; uartSend = false; &#125;&#125;/* * 注册信号，使用sigaction函数 */void set_signal(int fd)&#123; /*definition of signal axtion */ struct sigaction saio; /*install the signal handle before making the device asynchronous*/ saio.sa_handler = signal_handler_IO;//结构体中的函数指针成员赋值为某函数名 sigemptyset(&amp;saio.sa_mask); //saio.sa_mask = 0; 必须用sigemptyset函数初始话act结构的sa_mask成员 saio.sa_flags = 0; saio.sa_restorer = NULL; sigaction(SIGIO,&amp;saio,NULL); /* allow the process to recevie SIGIO*/ fcntl(fd,F_SETOWN,getpid()); /* Make the file descriptor asynchronous*/ fcntl(fd,F_SETFL,FASYNC);&#125; 此外，在许多开源代码中也有函数指针的使用。例如mosquitto中客户端的一些回调函数，在设置回调函数的函数中为结构体的函数指针成员初始化赋值为函数名。在恰当的时候调用回调函数。1234567891011121314151617181920212223242526272829303132e.g mqtt 客户端连接过程回调函数的使用void my_connect_callback(struct mosquitto *mosq, void *obj, int result)//回调函数&#123; int i; struct mosq_config *cfg; assert(obj); cfg = (struct mosq_config *)obj; if(!result)&#123; for(i=0; i&lt;cfg-&gt;topic_count; i++)&#123; mosquitto_subscribe(mosq, NULL, cfg-&gt;topics[i], cfg-&gt;qos); &#125; &#125;else&#123; if(result &amp;&amp; !cfg-&gt;quiet)&#123; fprintf(stderr, &quot;%s\n&quot;, mosquitto_connack_string(result)); &#125; &#125;&#125;int main(int argc, char *argv[])&#123; …… mosquitto_connect_callback_set(mosq, my_connect_callback);//设置回调函数的函数 …… rc = mosquitto_loop_forever(mosq,-1,1); //处理数据收发&#125;void mosquitto_connect_callback_set(struct mosquitto *mosq, void (*on_connect)(struct mosquitto *, void *, int))&#123; pthread_mutex_lock(&amp;mosq-&gt;callback_mutex); mosq-&gt;on_connect = on_connect;//结构体中的函数指针成员赋值为某函数名 pthread_mutex_unlock(&amp;mosq-&gt;callback_mutex);&#125; 说明： 这里只是追溯回调函数的使用，对于mosquitto源码的实现原理另作讨论。 通过ctags工具逐层追溯，可以看到mosquitto_loop_forever()=&gt;mosquitto_loop()=&gt;mosquitto_loop_read()=&gt;_mosquitto_packet_read()=&gt;_mosquitto_packet_handle()=&gt;_mosquitto_handle_connack()=&gt;mosq-&gt;on_connect() ,最终可以找到回调函数的调用，从而能够顺利找到对应的回调函数执行。 在mosquitto_loop()函数中会调用select函数，从而引发后续操作。 参考文档：MQTT C Client实现消息推送（入门指南） MQTT 嵌入式 C语言 客户端libemqtt源码解析 mqtt-client回调方法简介 MQTT libmosquitto源码分析 个人观点 函数指针和指针函数是在实践中使用较多的，应该重点掌握。 与此相关的函数的参数传递和返回值也需要考虑使用场合。 函数相关的参数传递，返回值等应该结合作用域、链接属性、存储模型等内容一起分析。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>指针</tag>
        <tag>函数</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--4数组与指针]]></title>
    <url>%2F2017%2F11%2F26%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍了数组和指针相关的知识点，并分析了二者之间的联系和区别。此外还介绍了一些特殊情况：空指针、void 指针、const修饰指针。最后针对实践中常用的字符串，总结了其使用的注意事项。 数组数组基础数组的特点 数组元素类型一样。 存储空间连续。区别于链表。 数组名是数组的起始位置，是地址常量。 注意事项 对数组名求sizeof，结果是整个数组的占用总空间，数组个数=sizeof(数组名)/sizeof(数据类型)。 数组名是地址常量，则说明不能对其做自增自减，改变其值。 数组元素的数据类型可以是基本类型也可以是构造类型。因此有字符数组、指针数组、结构体数组等，后续相关部分有详细介绍。 方括号中的常量表达式在定义就必须确定，而不能随着程序运行而改变。 数组定义、初始化、引用定义1&lt;存储类型&gt; &lt;数据类型&gt; &lt;数组名&gt;[数组元素个数] 初始化 全部元素初始化时，方括号中个数可省略不写。 数组全部初始化为0的几种方法：123int a[10]=&#123;0&#125;;int a[10];memset(a,0,sizeof(a));int a[10];bzero(a,sizeof(a)); 引用1&lt;数组名&gt;[下标] 说明： 数组必须逐个元素引用，不能整体引用。所以在定义完毕后如果需要赋值，必须一个一个赋值，可以使用for循环。而不能写int a[3];a[3] = {1,2,3}; 注意数组下标越界，相当于内存访问越界，造成的结果无法估量。不确定会产生什么后果，这取决于越界访问的内存空间是否是空闲以及访问是读还是写。 二维数组 二维数组的定义、引用、初始化类似于一维数组。 二维数组的存储是按行优先顺序存储的，也是存储在连续的空间。 初始化时可以省略第一个方括号中的数字。 对于二维数组元素或者元素地址的各种变形，要从本质上理解其含义，以a[2][3]为例： a是二维数组名，是地址常量。a+1表示移动一行。a+1表示第二行的地址。 a[0]、a[1]等是一维数组名，也是地址常量。a[0]+1表示移动一列，a[0]+1表示第一行第二列的地址，即&amp;a[0][1]。 指针指针基础基本概念 在计算机中，所有的数据都存放在存储器中，将存储器中的一个字节称为一个内存单元，不同的数据类型占有不同的内存单元数量。比如整型占4个内存单元(即4个字节)。 为了正确的访问内存单元,必须为每个内存单元编号,根据每个内存单元的编号就可以找到该内存单元。内存单元的编号也叫地址,而又称这个地址为指针。 内存单元的指针(地址)和内存单元的内容（具体存放的变量）是两个不同的概念。指针指向的内存区域的数据称为指针的目标，如果指向的区域是一个变量的内存空间，则这个变量称为指针的目标变量。 使用指针的好处 使程序简洁、紧凑、高效。 有效地表示复杂的数据结构。 实现动态分配内存。 得到多于一个函数返回值。 注意事项 理清各个概念的本质。是变量还是常量，是指针还是数据，指针是变量还是常量，所指向的目标是变量还是常量。 实践中建议画图标明指向关系。在程序出错时，也要从本质上分析原因。 使用示例：123px 表示指针变量，内容是地址变量。*px 表示指针指向的目标，内容是数据。&amp;px 表示指针变量占用存储区域的地址，内容是地址常量。 指针定义、初始化、引用定义1&lt;存储类型&gt; &lt;数据类型&gt; *&lt;指针变量名&gt; 说明： 定义时，将星号写在靠近变量名的一侧，而不是靠近数据类型。 这里的数据类型是指指针指向的目标的数据类型。 初始化12345&lt;数据类型&gt; *&lt;指针变量名&gt;=&lt;地址量&gt;int *p = &amp;m;或者int m,*p;p=&amp;m; 说明：未经赋值的指针变量不能随便使用。例如：int *p;*p=50;这是错误的，没有对指针进行初始化，指针随机指向一个内存单元，这样的指针成为野指针，代码在执行时会出现segmentation fault，访问了一个非法地址。在对指针变量进行间接引用前必须确保它们已经指向了一个合法的对象。 引用 对指针的引用使用*。*叫做指针运算符或者叫间接存取运算符。通过指针访问它所指向的对象叫做变量的间接访问。 &amp;是取地址运算符，和*互为逆运算。 注意：将一个变量的地址赋值给指针，那就意味着指针所指向的内存单元就是存储该变量的内存单元。无论是改变指针所指向的内存单元的内容还是直接改变变量的值，都会有相同的效果。 使用示例：1234int a,*p;a = 1;p = &amp;a;*p=2; 该例中a的值也会有变化，这是通过指针改变了变量的值。因此才会有如果不希望通过指针改变变量的值，那么使用const修饰。 指针运算指针的运算是指以指针变量所存放的值作为运算量而进行的运算。指针的运算就是地址的运算。 算术运算 +、-、++、--，表示移动一个或多个单位长度，单位长度是指数据类型所占字节数。因此其值的改变为数据类型所占字节大小乘以1或n。 两指针相减：结果为一个整数，而不是地址量，表示两指针相隔的数据个数。 关系运算：比较少用。多用if(px != NULL)和空指针进行比较。或者两个指针一起向中间移动时，会比较两个指针。 赋值运算 对指针赋值使用&amp;，和*互为逆运算。多个运算符在一起要注意优先级。 *p++ 表示*(p++)，表达式的值是取原p指向的对象值，然后p移动一个位置。 *++p 表示*(++p)，表达式的值是p移动一个位置后，再取其指向的对象值。 sizeof运算符：sizeof(px)，任何类型的指针变量求sizeof，大小始终是4或者8字节，是由计算机系统位数决定，和类型无关。 二级指针 二级指针是指向一级指针变量的指针变量，即指针指向的目标是指针。 定义：&lt;存储类型&gt; &lt;数据类型&gt; **&lt;指针名&gt; 二级指针的运算，和一级指针类似，理解本质即可。++，--也是移动单位长度，这里的单位长度是指针类型的长度，则是4字节或者8字节。另外，用sizeof对二级指针运算，同样是4字节或者8字节。 使用示例：12345678910e.g1:字符指针数组名赋值给字符二级指针char *p[5]=&#123;&quot;beijing&quot;,&quot;tianjin&quot;,&quot;shanghai&quot;,&quot;sichuan&quot;,&quot;liaoning&quot;&#125;;char **pp=p;e.g2:指针数组名赋值给二级指针int a[2][3];int *p[2];p[0]=a;p[1]=a+1;int **q = p; 特殊指针空指针 空指针是指指针变量为0的指针，表示为NULL。表示目前尚未指向任何对象。 用处：(1)在需要返回指针时，如果失败常常返回NULL。(2)在指针定义时，常常初始化为NULL。 修改0地址的值或者进行间接引用操作都是不允许的，会出现段错误。 如果指针初始化为NULL，后又访问或者修改该地址的内容，则一定会出现段错误，所以可以分析出原因：是由于指针指向的对象不明确造成的。 一般在对指针进行引用前，应该先判断指针是否为空。 void指针 void指针是指向不明确数据类型的指针变量。这是空类型指针，区别空指针概念。 不确定数据类型表示只知道目标的起始位置，但是不知道目标的大小，即占用字节数。 void指针可以指向任何类型的数据，那么任何类型的指针可以赋值给void指针，不需要强制类型转换。但是反过来，void指针赋值给某一具体类型的指针变量，则需要强制类型转换。 在引用void指针的目标值时，需要进行强制类型转换。 void指针的运算，ANSI C和GNU C规定不一样。ANSI C规定不允许对void指针进行运算，而GNU C可以。 使用场合：使用任意类型的指针的场合，比如函数参数传递，函数返回值。例如作为一种函数模板，适用于多种情况。 扩展知识：void也是一种数据类型，空类型。void不能定义变量。void的作用是(1)对函数返回做限定。(2)对函数参数做限定。 使用示例：12345678910e.g1:给某个指针动态分配内存，malloc需要强制类型转换void *malloc(size_t size);int *p;p = (int *)malloc(sizeof(int)*n);e.g2:内存拷贝函数，任何类型的指针都可以使用。也符合内存拷贝的本质，与类型无关。void *memcpy(void *dest, const void *src, size_t n);char a1[5]=&#123;0&#125;;char b1[]=&#123;&quot;hi&quot;&#125;;memcpy(a1,b1,sizeof(b1)); 参考文档：void指针详解void及void指针含义的深刻解析void指针用法 const修饰指针 const int *a：常量化指针指向的对象，不予许通过指针修改指向的对象，但可以直接修改变量。 int * const a：常量化指针变量，只能指向同一个对象，指针变量的值不能改变，但是可以通过指针改变对象的值。 const int * const a：常量化指针变量和目标表达式，既不能通过指针修改指针所指向的变量的值，也不能修改指针变量的地址。 注意： 强行修改会报错：assignment of read-only location …… const声明的变量必须在初始化时赋值，后面再赋值，则会报错。 使用示例：1234567e.g1:char *strcpy(char *dest, const char *src);这里加const是为了不予许在函数内，通过*src修改原字符串的内容。e.g2:int main(int argc,const char *argv[])这里的形参char *argv[]可以理解为char **argv。const限制*argv[]不能变，即不能通过指针改变字符串。而argv[1]和argv都是可变的。 参考文档：读懂C语言const限定以及复杂定义C语言中strcpy字符串复制库函数的理解与分析 指针与数组由上面内容可知，指针和数组有很多相似之处。要从本质上理解区分指针和数组。在C语言中指针的效率往往高于数组下标。编译器对程序中数组下标操作会全部转换为对指针的偏移量操作。 数组指针数组指针是指向数组起始位置的指针，本质是指针。实践中多指指向二维数组的指针。 指针与一维数组 数组在内存中的位置在运行过程中不能动态改变。数组名不允许被赋值。 数组的指针是地址常量，而指针变量是地址变量。 *运算符称之为指针解引用，即根据地址获取地址里的内容。[]运算符称之为下标运算，表示指针移动n个单位长度后取内容。 使用示例：12345int a[5];int *p = a;则有数组元素表示：*(p+i)&lt;=&gt;p[i]&lt;=&gt;a[i]&lt;=&gt;*(a+i)数组元素地址表示：p+i&lt;=&gt;&amp;p[i]&lt;=&gt;&amp;a[i]&lt;=&gt;a+i 指针与二维数组访问二维数组元素的方法有： 列指针（一级指针），利用顺序存储的特点访问。 行指针。定义：存储行地址的指针称为行地址。加1表示移动一行。格式：&lt;存储类型&gt; &lt;数据类型&gt; (*&lt;指针变量名&gt;)[表达式]注意：方括号的表达式表示指针加1，移动几个数据，用行指针操作二维数组时，代表一行的个数，即列数。 一级指针数组。定义指针数组操作二维数组时，指针数组的个数应该为二维数组的行数。 二级指针。注意：二级指针的初始化在这里必须赋值为指针数组名，而不是二维数组名，否则不知道如何偏移。 使用示例：123456789101112131415161718192021222324252627282930313233int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//访问二维数组元素//数组方式//a[1][2];printf(&quot;%d %d %d\n&quot;,a[1][2],*(a[1]+2),*(*(a+1)+2));//列指针访问int num = sizeof(a)/sizeof(int);int row = sizeof(a)/sizeof(a[0]);int col = num / row;int *pcol = &amp;a[0][0];printf(&quot;%d\n&quot;,*(pcol+1*col+2));//行指针访问int (*prow)[3];prow = a;printf(&quot;%d\n&quot;,*(*(prow+1)+2));//指针数组访问int *parray[2];parray[0] = a[0];parray[1] = a[1];printf(&quot;%d\n&quot;,*(parray[1]+2));//二级指针访问int **psec;//psec =a;//对二级指针赋值，是指针数组名，而不是二维数组名，否则psec+1不知道如何偏移psec = parray;printf(&quot;%d\n&quot;,*(*(psec+1)+2));//访问二维数组元素的地址printf(&quot;%p %p %p\n&quot;,&amp;a[1][2],a[1]+2,*(a+1)+2);printf(&quot;%p %p %p %p\n&quot;,pcol+1*col+2,*(prow+1)+2,parray[1]+2,*(psec+1)+2); 注意：a[i]和*(a+i)是完全等价的，不管a是数组名还是指针，因此示例中可以按照此规则等价转换书写更多的形式。 指针数组指针数组：本质数组，数组名相当于多级指针。指针数组的数组名是数组的起始地址。 使用示例：12345678910111213e.g1:访问二维数组int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;int *parray[2];parray[0] = a[0];parray[1] = a[1];e.g2:字符指针数组int main(int argc,const char *argv[])这里是指针数组做形参，相当于同级别的指针。char *fruit[3]=&#123;&quot;apple&quot;,&quot;pear&quot;,&quot;grape&quot;&#125;; 字符串、字符数组、字符指针关于字符串的使用，涉及字符数组和字符指针。数组和指针前面已经介绍，数组和指针使用的注意事项，字符数组和字符指针同样应注意。除此之外，重点理解字符串的特殊之处即可。 字符串定义字符串是由’\0’作为结束符的一组字符，用字符数组表示。 字符串常量在程序中使用字符串常量会生成一个“指向字符串的常指针”。当一个字符串常量出现在一个表达式中，表达式所引用的值是存储该字符串常量的内存首地址，而不是字符串本身。 字符串处理函数字符处理函数常用的有strlen、strcpy、strcmp、strcat、strtok。以及带有长度限制的对应函数，例如strncpy等。这些函数需要熟练使用，这在Linux应用程序开发中有使用。说明： 每一个函数的具体用法参见man手册。一定要理解各个函数的含义，尤其是特殊处理。 strlen统计字符长度，不带’\0’。 strcpy不会做越界检查，需自己保证长度合适。而strncpy不保证最后一个字符是’\0’。 strtok功能是分割字符串，会破坏原有字符串完整性，如果要想保持不变，使用strchr和sscanf组合代替。 参考文档:C语言字符串使用注意事项常见字符串处理函数梳理及分析 C语言字符串操作总结大全(超详细)C语言中strcpy字符串复制库函数的理解与分析 字符数组 字符数组是有一定顺序关系的若干字符变量的集合。可以是一维的也可以是二维的。字符数组具有普通数组的性质，又有其特殊性。 初始化：可以使用逐个赋值，也可以使用字符串常量。 1234char str[6]=&#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos;\0&apos;&#125;;char str[6]=&quot;hello&quot;;char str[]=&quot;hello&quot;;char fruit[][7]=&#123;&quot;apple&quot;,&quot;orange&quot;,&quot;grape&quot;&#125;; 注意： 用字符串赋值比用字符逐个赋值多一个字符，所以通常用字符串赋初值时，不写数组长度。 如果希望字符数组表示字符串，那么字符逐个赋值时，应该额外在最后手动添加’\0’。即a[strlen(s)]=’\0’。 字符数组一定不能越界访问。如果定义了数组长度N，输入时只能输入N-1个字符。 字符数组名同样也是地址常量，不能自增自减改变其值。 字符指针 字符指针就是指向字符类型对象的指针。如果字符指针指向字符串，则存储字符串的起始地址，即指针指向字符串的第一个字符。 初始化：可以赋值为字符数组名，也可以使用字符串常量。 12char str[]=&quot;hello&quot;;char *p = str;char *p=&quot;welcome&quot;; 注意： 初始化字符指针是把内存中字符串的首地址赋予指针，并不是把字符串复制到指针中。而字符串本身存储在内存的其他地方。 char *p=”welcome”;相当于const char *p=”welcome”;因此按照const修饰指针的规则，则不能通过指针修改字符串的内容，会引起段错误。但是指针本身可以改变，p++是允许的。 字符指针作为形参，函数内判断字符串是否达到结尾，通常使用while(*s == ‘\0’)，而不用其长度判断。 获得字符串长度，通常使用strlen，而不能对字符指针求sizeof，因为其代表的是指针占内存空间大小。如果对字符指针求sizeof控制长度，打印时会导致字符串打印不全。 如果给指向字符串的字符指针动态分配空间时，也应该是strlen(s)+1，因为要给’\0’提供一个位置。否则在打印时会导致字符串打印完全后还跟着乱码字符。 参考文档C语言字符串指针（指向字符串的指针）c中给字符数组，字符串指针赋值的方法总结 字符指针数组 字符指针数组即是在数组中存储若干个字符串首地址。 字符指针数组的数组名是代表数组的起始位置，而数组元素是字符指针，因此数组名是指针的地址，即为二级指针，因此使用二级指针操作。 使用示例： 12char *p[5]=&#123;&quot;beijing&quot;,&quot;tianjin&quot;,&quot;shanghai&quot;,&quot;sichuan&quot;,&quot;liaoning&quot;&#125;;char **pp=p;//(用二级指针承接指针数组名) 个人观点 理解每一个概念的本质含义。从本质上去理解每一个知识点的使用方法和注意事项。 当出现多个名词组合在一起时，学会分解，从简单组合到复杂。 对数组和指针的掌握程度是熟练使用。此外建议通过读经典源码，了解通用写法。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--3Make]]></title>
    <url>%2F2017%2F11%2F23%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--3Make%2F</url>
    <content type="text"><![CDATA[本篇文章围绕GNU make介绍了make工程管理器相关知识，包括Makefile基本结构、变量、规则的使用，以及一些相关问题：伪目标、文件搜索、嵌套执行make、Makefile函数的使用。最后结合实践情况，对一些Makefile文件做了简要分析，并介绍了autotools和cmake两种自动生成Makefile的工具。 make简介 make工程管理器，它是一个自动编译管理器，“自动”是指它能够根据文件时间戳自动发现更新过的文件，只编译改动的代码文件，而不是全部编译，从而减少工作量。make可以提高项目开发和维护的工作效率。 Makefile是make读入的唯一配置文件。 可以理解为makefile里面是大量的gcc命令。使用Makefile可以减少多个文件编译时一遍一遍输入gcc命令。只不过Makefile有其自己的语法格式。 这里是总结GNU make的知识。而其他厂商的make与之类似。 Makefile基本结构使用make工程管理器，也就是编写Makefile文件。Makefile文件由三部分组成：（1）目标体：通常是可执行文件、目标文件、标签。（2）创建目标体所依赖的文件。（3）创建每个目标体需要运行的命令。 Makefile格式：123target:dependency_files&lt;tab&gt; command&lt;tab&gt; …… 说明： Makefile的工作原理：如果dependency_files比target新或者target不存在，那么就会执行command指令。 目标和依赖是Makefile中的主要构成。而目标和依赖的关系是通过规则表达，即命令。 一个Makefile可以定义多个目标，调用make命令时需指明目标，如果未指明时，默认生成第一个目标。 如果依赖也是目标，那么make会按从左到右的顺序先构建规则中依赖的目标，再构建目标。Makefile只检查依赖关系，如果依赖的文件找不到则会退出。 注意命令前tab键的使用。Makefile以tab键区分是否是命令，不能以多个空格代替。 command不一定是编译链接等命令，可以是任意可以运行的命令以及make定义的函数。 一个规则可能包含多条命令。一个规则也可以包含多个目标。 在Makefile文件中除了有规则、变量定义还有文件指示和注释。文件指示包括：在一个Makefile中包含另一个Makefile；指定Makefile的有效部分，即条件判断；定义一个多行的命令。而注释是以#开头。 包含其他Makefile，可以使用include filename，其中filename可以包含路径和通配符。 使用cc -MM xxx.c命令可以输出文件的依赖关系，并生成一条依赖语句。 变量使用 在Makefile中使用变量的目的就是代替一个文本字符串，作用类似于宏。比如系列文件的名字、传递给编译器的参数、运行的程序、查找源代码的目录。使用变量可以增加Makefile的可维护性。 在Makefile文件中定义的变量相当于全局变量，如果要定义局部变量，可以定义在目标之后或者模式（%）之后，则变量会只作用于由这个目标引发的所有规则。 定义变量的两种方式 递归展开方式 1VAR=var 一次性将内嵌的变量全部展开，但不能在变量后追加内容，可能导致无穷循环。 简单扩展方式 1VAR：=var 在定义处展开，且只展开一次。前面的变量不能使用后面的变量，只能使用前面定义好的变量。 使用变量1$(VAR) 使用说明: 变量大小写敏感。 推荐使用小写字母作为变量名，预留大写字母作为控制隐式规则参数或用户重载命令选项参数的变量名。 实践中常会用到+=，为定义的变量添加新的值。 变量的替换(1) $(var:a=b) 将var变量中以a结尾的字符串替换为b。(2) 使用静态模式 $(var:%a=%b)。 override指示符的作用：如果变量是通过命令行参数设置，要在Makefile中设置其值，需要使用override。 定义空格可以写为：12empty:=space:=$(empty) $(empty) 变量的种类 自定义变量 预定义变量 自动变量 $@目标文件完整名称，在模式规则中， 可以匹配目标中模式定义的集合。 $^所有不重复的目标依赖文件。 $&lt;第一个依赖文件名称，在模式规则中，是将符合模式的文件挨个取出。 环境变量make在启动时会自动读取系统当前已经定义的环境变量，并创建与之相同的变量，若在Makefile中定义了相同名称的变量，则会覆盖同名的环境变量。 类似于全局变量和局部变量的关系。最好不要使用环境变量MAKEFILES,否则会影响使用make。 规则说明 Makefile的规则包括目标体、依赖文件和其间的命令语句。这称为显式规则，即显示的说明了如何生成一个或多个目标文件。除此之外，还有隐式规则和模式规则。 规则包含两个部分：一个是依赖关系，一个是生成目标的方法。Makefile中只应该有一个最终目标，第一条规则中的目标被确立为最终的目标，所以顺序很重要。 隐式规则 隐式规则告诉make如何按照约定俗成的方法完成任务，只需把目标文件列出即可，不需要指定编译的具体细节。 使用隐含规则生成目标，make会自动推导这个目标的规则和命令。 在隐含规则库中，每一条规则都在其库中有顺序，位置靠前的规则容易被使用，为了避免依赖无效，则必要时需要显示写出执行的命令，不能省略。 常见的隐式规则有：123.c变成.o 使用$(CC) -c $(CPPFLAGS) $(CFLAGS).cc变成.o 使用$(CXX) -c $(CPPFLAGS) $(CXXFLAGS).o生成目标 使用$(CC) $(LDFLAGS) xxx.o $(LOADLIBES) $(LDLIBS) 说明： 其余隐式规则详见《跟我一起写Makefile:隐含规则》。 隐式规则中使用的是系统设定的变量，用户可以在Makefile中修改这些变量的值，只要设置了其值，那么就会对隐式规则起作用。 关于隐含规则链，一个目标可能被多条隐含规则作用。make会尽一切可能生成目标，其中可能生成中间文件，这种方式生成的中间文件在生成目标后会使用“rm -f”删除。 模式规则 模式规则用来定义对多个文件使用相同处理规则。隐式规则仅能使用make默认的变量进行操作，但模式规则可以引入用户自定义变量，简化Makefile的书写。 模式规则在目标定义中需加上”%”符号，”%”表示一个或多个任意字符。目标必须是这种形式，否则成为一般的规则。 依赖中也可以使用“%”符号，但是其值取决于目标。 使用示例：12%.o:%.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@ 补充：静态模式，可以容易的定义多目标的规则。其定义和模式规则类似，格式如下：12target:target-pattern:prereq-pattern&lt;tab&gt;commands 其中target为一系列目标，target-pattern是目标集模式，prereq-pattern是目标的依赖模式。使用示例：1234objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 相关问题伪目标使用.PHONY关键词定义伪目标，作用是防止文件夹中有和目标相同名字的文件，执行make指令不产生预期的动作。例如clean目标，可以认为是一个标签，不依赖任何文件。因此可以在Makefile中定义一些和编译无关的命令，比如程序的打包、备份、删除等。 使用示例：123.PHONY:cleanclean: rm xxx *.o 说明： 通常clean规则写在文件最后。需要显示使用make clean执行相应功能。 这里使用了通配符“*”，make支持“*“、”?”、”~”三种通配符。 如果要一次生成多个可执行文件，可以使用all伪目标，用伪目标作为默认目标。 伪目标也可以作为依赖，用于完成不同的功能，详见《跟我一起写Makefile:书写规则》。 文件搜寻使用VPATH完成文件搜索。如果Makefile文档中定义了VPATH变量，那么make会在当前目录找不到的情况下，到指定的目录中寻找文件。 使用示例：1VPATH=src:../header 说明： make会按照这个顺序进行搜索，多个路径由冒号分割。 还可以使用vpath(小写字母)关键词定义，详细使用方法详见《跟我一起写Makefile:书写规则》。 命令的书写这里总结几条书写命令时的注意事项： make的命令默认使用/bin/sh解释执行。 如果在使用make时不希望打印命令，则在Makefile中命令前加上@。 如果要执行两条命令，第一句的命令结果要应用于下一条命令，必须用分号分割，而不能写在两行。 在Makefile中可以为相同的命令序列定义一个变量，注意不可以和变量重名。使用方法和变量类似，执行命令时，其包裹的每条命令都会执行。使用示例：1234define two-lines echo foo echo $(bar)endef 嵌套执行make 在大的工程中，不同模块或功能的源文件放在不同的目录中，每个目录都可以书写一个该目录下的Makefile。最外层的Makefile称为总控Makefile。 如果要传递变量到下级Makefile中，使用export xxx，如果要传递所有，使用一个export即可。其具体使用详见《跟我一起写Makefile:书写命令》。 在实践中，通常有很多源码，每个文件夹都有Makefile,上级目录中的Makefile会逐级调用下层的Makefile。具体情况需结合实例分析。 使用make -C指定进入下层Makefile时，-w参数自动打开，则可以在make执行时看到进入哪个目录，离开哪个目录。 使用示例:1set -e; for d in $(DIRS); do $(MAKE) -C $$&#123;d&#125;; done 使用条件判断使用条件判断，可以让make根据不同的情况选择不同的分支执行。格式如下：12345ifeq (arg1,arg2) 或者ifneq (arg1,arg2) 或者 ifdef xxx 或者ifndef xxx……else……endif 说明： arg可以是make函数。 ifdef只是判断变量是否为空，非空为真，空为假。 Makefile函数在Makefile中使用函数处理变量，可以增加其灵活性。函数的返回值可以作为变量使用。包括字符串处理函数，文件名操作函数，foreach，if，call，shell函数等，具体使用详见《跟我一起写Makefile:使用函数》。 格式如下：1$(function arguments) 函数名和参数用空格隔开，变量之间用逗号隔开。 常用的函数总结如下：1234567891011121314151617addprefix 给字符串中每一个子串加上一个前缀。$(addprefix prefix,names)filter 从字符串中根据模式得到满足模式的字符串，返回匹配的。$(filter pattern,text)filter-out 从字符串中根据模式滤出某些字符串，返回不匹配的。$(filter-out pattern,text)wildcard 通配符，相当于*，pattern举例：*.c$(wildcard pattern)patsubst 模式字符串替换,相当于变量替换的功能。$(patsubst pattern,replacement,text)shell函数执行shell命令，和`xxx`是同样的功能。 make 使用make命令 make命令执行后会有三个退出码。0表示成功执行，1表示运行时出现任何错误。2表示某些目标不需要更新，make需要使用-q选项。 make最终目标是Makefile中的第一个目标。可以指定make的目标，只需在make命令后跟上目标的名字即可。目标可以是真实的目标，也可以是伪目标。 通常开源软件发布的Makefile中都包括编译、安装、打包等功能。例如有all、clean、install、tar、dist、test等目标。具体要结合具体的Makefile分析。 因此，可以使用make xxx，make clean，make install等完成不同的功能，如果只写make,则默认建立Makefile中第一个目标。 make 常用参数12345-C dir 读入指定目录下的Makefile。-f file 读入当前目录下file文件作为Makefile。-n 模拟执行，打印要执行的命令，但不执行。可以用于调试Makefile，查看其执行顺序。-j 同时运行命令的个数，-j2表示以两个线程编译。-i 忽略所有命令执行错误，也可以在Makefile中command前加上短横线。 更多的参数详见《跟我一起写Makefile：make运行》。 应用实例 在实践中，通常会用到第三方的开源库或者SDK包，因此涉及第三方库的移植，若是源代码，那么需要修改其自带的Makefile，使其适合目标平台，再进行配置编译工作。该部分内容另作讨论研究。这里只对使用第三方库过程中的Makefile做简单分析。 此外，在开发者自己编写模块或者软件包时，可以采用系统内核规定的方式，将软件包作为内核的一部分进行编译。也可以放在内核之外，使用内核的Makefile文件编译为模块，使用时再进行动态加载。这里也做简要分析。 最后，实践中也经常使用工具来自动生成Makefile,例如autotools和cmake工具，开发者只需按照规定填充源文件的相关信息。 第三方开源库或SDK使用中的Makefile分析openwrt使用opencv库Makefile分析在js9331开发板上做图像处理，需要openwrt移植opencv库。具体移植的方法在后续第三方库移植专题中再做深入研究。这里只对其测试代码的Makefile做一分析。 Makefile说明： Makefile代码详见gist。 使用命令时，可以添加命令行参数，例如export prefix=xxx; make install。 opencv的应用程序一般使用c++编写，如果移植到openwrt平台，涉及到c和c++程序的混合编译，使用注意事项详见《c语言高级编程-2搭建交叉编译环境》。 参考文档：用OpenWrt package方式编译OpenCV openwrt-packages/wrtnode/opencv-test/src/Makefile ubuntu使用海康威视SDK包Makefile分析海康威视摄像头提供linux版本的SDK包，供开发者进行二次开发。其中涉及到Makefile文档，对其进行简要分析。 Makefile说明： Makefile代码详见gist。 gcc选项-W……，用于不同错误的警告提示。 Makefile函数的使用，比如subst，foreach，wildcard，dir，notdir，patsubst，addprefix等。 VPATH的使用，用于文件搜索。 对于动态链接库，使用-Wl,-rpath=……选项，表示运行时记住库的路径。 gcc选项，-pipe，用于优化处理。 参考文档：提领类型双关的指针将破坏重叠规则——strict-aliasinggcc中的-Wl,rpath=选项《gcc五分钟系列》第十节：编译期优化选项（一）——pipe 海康威视设备网络SDK_V5.2.7.4(for Linux64) openwrt上onvif开发Makefile分析openwrt平台上进行onvif协议开发和在其他linux平台上类似，只是编译器选为mips-openwrt-linux-gcc。onvif协议客户端开发，使用gSoap开源软件中的WSDL2h和SOAPcpp2工具生成onvif.h和相关的.c源文件进行应用程序开发。具体原理另作研究讨论。 Makefile说明： Makefile代码详见gist。 使用-DDEBUG选项，可以打印onvif通信日志。 使用strip命令，可以对可执行文件瘦身，减小大小，对于嵌入式开发十分必要。 参考文档：onvif开发之设备发现功能的实现Onvif开发之Linux下gsoap的使用及移植 编译自己的模块或软件openwrt编写ipk包Makefile分析openwrt软件安装包一般为ipk后缀的文件，它提供了一种让用户自己生成ipk包的方法。即： 在openwrt源码中，package目录下，新建文件夹A，其中创建Makefile和src文件夹。src文件夹中编写.c、.h源文件和编译的Makefile。或者没有源码文件，在A文件夹下的Makefile中写明获取软件源码的网址。 在文件夹A下的Makefile是一种编写模板，其提供了该软件包的下载、编译、安装的方法。 在步骤2编写完成的Makefile包含了该软件在make menuconfig配置下的位置和信息，因此在openwrt主目录下make menuconfig选中要编译的软件。 在openwrt主目录下运行make V=s。完成后在/openwrt/bin/ar71xx/packages/base目录下可以找到对应的ipk软件包，复制到开发板进行安装即可。 Makefile说明： Makefile代码详见gist，这里选取两个范例，一个是openwrt移植opencv使用该方法，另一个是普通的ipk软件包生成测试。具体含义参见参考文档。 makefile函数的使用，eval和call函数。 参考文档:用OpenWrt package方式编译OpenCVOpenwrt学习之路-(5-Openwrt package Makefile) openwrt简单ipk生成及Makefile解释 iTOP4412/FS4412编写LED灯驱动Makefilelinux驱动编译时，多采用动态编译，即驱动的源代码不放在内核中，因此其Makefile编写有一定讲究。在此简略分析。关于驱动的内容详见后续总结。 Makefile说明： Makefile代码详见gist。 ifeq的使用，执行不同的命令。 make -C指明使用内核Makefile的路径。 参考文档：Linux 驱动开发之内核模块开发 （二）—— 内核模块编译 Makefile 入门 自动生成Makefile的工具对于大型的项目，如果有工具可以自动生成Makefile，那么将提高开发效率。 GNU autotools使用autotools制作Makefile步骤如下： 运行命令autoscan。 修改configure.scan文件，并重命名为configure.ac。 运行命令aclocal。 运行命令autoconf。 运行命令autoheader。 创建文件Makefile.am，并配置内容。 运行命令automake –add-missing。期间缺少的文件自己创建。 运行./configure命令。 运行make命令，得到可执行文件。 说明： make install、make clean、make disk等命令可以使用。 在confiure.ac、Makefile.am文件中填写源文件相关的内容，不需要填写依赖关系等，可以自动生成。 参考文档：Linux c 开发 - Autotools使用详细解读 cmake GNU autotools 是linux系统下常用的自动生成Makefile的工具，而cmake是一款跨平台的安装编译工具。不仅可以生成Makefile，还可以生成Windows visual C++的projects等。 在实践项目中，涉及一些开源软件的使用，比如opencv、mosquitto、paho.mqtt.embedded-c、Azure iot-hub-c-raspberrypi-client-app等。在这些源码中，包含了许多CMakeLists.txt文件。关于如何在自己的程序中使用这些第三方的开源库，在第三方库移植专题中总结。这里只对cmake做一简单介绍，涉及两个方面。 如何编写CMakeLists.txt文件，即理解其语法。常用的语法如下：projet(projectname) 项目名称 add_executable(exename source) 生成可执行文件 set(var value) 设置变量 add_subdirectory(source_dir) 增加源代码目录 add_library(libname source ) 生成链接库 target_link_libraries() 添加依赖的链接库 aux_source_directory(. var) 查找当前目录下源文件并将其保存到var变量中 如何使用cmake命令。cmake PATH PATH是CMakeLists.txt所在的目录 cmake . 在当前目录下运行cmake 注意： CMakeLists.txt中命令不区分大小写。 使用变量时，使用花括号。 参考文档：为什么用CMake大型程序管理神器之CMakeCMake 入门实战cmake 命令行CMake TutorialCMake交叉编译配置 个人观点 本篇文章的Makefile主要参考文档为跟我一起写makefile。 写Makefile时，首先是思考需要表达什么样的依赖关系。而不是先思考如何写规则命令。 对于Makefile的掌握程度，要会写简单的Makefile，用于自己项目管理。要会读懂别人的Makefile，要会根据需要做相应修改。对于一些细节知识仅作了解，理解即可，真正使用时再做分析。 在实践中，由于项目并不大，因此一般自己编写Makefile文件，可使用一份Makefile模板，进行细微修改即可，而不是用cmake或autotools工具。autotools目前只做了解。 目前cmake工具的使用主要用在开源库的使用中，因此需要理解其含义和使用方法。待对cmake有足够了解后，可以对开源库的CMakeLists.txt根据自己需要进行修改。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>make</tag>
        <tag>Makefile</tag>
        <tag>autotools</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--2搭建嵌入式linux编程环境]]></title>
    <url>%2F2017%2F11%2F17%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--2%E6%90%AD%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[搭建嵌入式Linux编程环境，就是搭建C语言编程环境，这是嵌入式系统开发的首要工作。另外在嵌入式Linux系统移植中，也需要首先搭建交叉开发环境。嵌入式开发工具包括编辑器、编译器、调试器、工程管理器等。前面已介绍过VIM编辑器，本篇主要总结gcc编译器和gdb调试器，此外简要介绍GNU Binutils工具集，并给出实践的使用实例。工程管理器make将在下一篇总结。 GNU工具集GNU工具集是包含了GNU项目所产生的各种编程工具的集合。这些工具形成一条工具链，用于开发应用程序和操作系统。ＧNU工具有很多，包括如下： 编译工具：gcc。 调试工具：gdb。 二进制工具集：GNU Binutils,包括链接器、汇编器、格式转换工具等。 软件管理工具：make、CVS、subvision等。 参考文档：gnu工具集GNU工具链（GNU toolchain）gnu工具链简介 GNU Binutilsbinutils工具集主要包括as汇编器和ld链接器，除此之外，还有一些工具(即命令)是开发调试中常用的，此处做一简要介绍。123456789101112131415161718192021readelf -h xxx 查看可执行文件的头部信息，包括系统架构、大小端等信息。elf文件是linux/unix系统下的二进制文件格式。readelf -a xxx 查看可执行文件的所有信息。file xxx 查看文件类型，如果是可执行文件，会显示文件类型、系统架构、大小端、是否strip等信息。size xxx 列出可执行文件每一段的大小和总大小。可显示可执行文件包括text、data、bss等部分。strip xxx 对可执行文件“瘦身”，丢弃目标文件中的全部或特定符号，减小文件体积。对于嵌入式系统，需要使用该命令。不可对中间文件“瘦身”，否则链接出错。nm xxx 查看可执行文件的所有符号。在调试段错误时可以使用，方便定义哪里发生了段错误。objdump -d xxx 对可执行文件进行反汇编，生成汇编代码，在调试段错误也会用到。 objcopy 进行目标文件格式转换 例如：objcopy --gap-fill=0xff -O binary u-boot u-boot.bin,用在uboot移植部分。addr2line 把程序地址转换为文件名和行号，常用于内核调试。注意编译时需加上-g选项，生成调试符号。否则运行addr2line出错。e.ggcc -o test -Wl,-Map=test.map -g test.cgrep main test.mapaddr2line 0x08048368 -e test -f 参考文档：Binutils工具集 解析Linux环境下段错误的产生原因及调试方法小结Linux debug : addr2line追踪出错地址 GCCGCC简介GCC可以编译如C、C++、Java等多种语言，GCC是可以在多种硬件平台上编译出可执行程序的超级编译器，其执行效率比一般的编译器要高20%-30%。在嵌入式领域开发需要交叉平台编译器。 GCC的基本用法该部分介绍GCC命令常用的选项，需熟练掌握。因为在makefile中也就是使用这些语句组成。 1234567891011121314151617181920212223-c 只编译,不链接为可执行文件。用于编译不包含主程序的子程序文件。由.c文件生成.o文件。-g 在使用gdb之前需要加上该选项。-o output_name 指定输出文件名。-O/O2 优化编译链接过程。-On n表示优化级别的整数。优化可以加快代码运行速度，但是会对调试造成影响，因此在开发阶段不要进行优化，在发布时可以优化。-I dirname 将dirname所指向目录加入到程序头文件目录列表中,在预编译过程使用。-L dirname 将dirname所指向的目录加到程序函数档案库文件的目录列表中,在链接时用到。-llibrary 链接名为library的库文件。-Dname 预定义一个名为name的宏，值为1。也可以是-Dname=xxx，值为xxx。 可以用于调试，如-DDEBUG。-Wall 打开所有类型的语法警告。运行含有警告信息的代码通常会有意想不到的结果，所以应尽量使用-Wall处理警告信息。-std=c99 指明使用标准ISO C99作为标准编译程序。-static 禁止使用动态库。-share 尽量使用动态库。 GCC编译过程GCC编译包括4个步骤： 预处理命令：gcc -E test.c -o test.i作用：进行编译的第一遍扫描。由预处理程序负责完成。当编译一个程序时，系统自动调用预处理程序对程序中的以＃开头的预处理部分进行展开，然后才进入源程序的编译阶段。包括替换宏、条件编译、头文件展开等。该阶段不检查语法错误。 编译命令：gcc -S test.i -o test.s作用：检查代码的规范性，是否有语法错误，检查无误后把代码翻译为汇编代码。 汇编命令：gcc -c test.c -o test.o 或者gcc -c test.s -o test.o或者 as test.s -o test.o作用：生成目标代码。 链接命令：gcc test.o -o test作用：将目标程序链接库资源，生成可执行程序。对于头文件包含的函数声明，其函数实现大多数都包含在libc.so.6这个函数库中，gcc默认在路径/usr/lib下去搜索，即链接到libc.so.6库函数中，从而找到函数的实现。这就是链接的作用。 GDBGDB使用GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。使用时，必须在编译时加上-g选项，才可以使用GDB调试。编译完成后，使用命令gdb xxx,即进入调试过程。以下列出常用的选项。1234567891011121314151617l 查看文件。b n 在第n行设置断点，表示程序运行到第n行之前停止。r 运行代码。c 恢复代码运行。p xxx 打印变量值xxx，在显示变量值时前面有一个$N,表示当前变量值的引用标记，后续再次查看该变量，可以使用$N简化书写。n 非进入式单步运行。s 进入式单步运行。watch xxx 对xxx变量设置观察点，单步运行会看到变量值的变化。q 退出。 参考文档：Linux gdb调试器用法全面解析 嵌入式交叉开发环境搭建搭建嵌入式交叉开发环境是进行嵌入式应用开发前必需的准备工作，也是嵌入式系统移植的第一步。开发环境包括主机、目标机、以及连接介质。搭建嵌入式交叉开发环境就是要在主机上编译、调试目标机的代码，即涉及主机和目标机的通信。关于嵌入式交叉开发环境搭建有以下几点说明： 理解为什么要交叉编译。交叉编译是指在开发主机上运行编译器编译内核、应用程序，在目标机上运行内核和应用程序。原因是嵌入式系统硬件资源限制，且嵌入式系统MCU体系结构和指令集不同。 理解如何搭建嵌入式开发环境。 准备好主机、目标机和连接介质。 准备好目标机代码。 安装交叉工具链。 准备主机和目标机之间通信的辅助工具，即安装通信服务和软件。 关于安装交叉工具链。主要步骤是获取交叉工具链压缩包、解压、添加全局环境变量到配置文件、source 配置文件。一般情况是从网上下载已经编译好的交叉工具链。也可以下载源码，自行编译交叉工具链，需要使用工具crosstool-ng，后续有需求再做深入了解。GNU 交叉工具链和前面叙述一致，包括GNU Binutils、GNU GCC、GNU Glibc等部分。 连接主机和目标机的介质通常是串口、USB、网络。对于每一种方式，掌握使用什么工具，如何使用，有何作用即可。具体情况需结合实践情况进行分析。通常情况下，有以下两个任务需要完成。 进入目标机终端的方法：（1）使用串口。（2）使用网络协议ssh、Telnet等。不管是使用串口还是网络，都可以使用putty、scureCRT软件，因为其支持serial、ssh、ftp等众多协议。此外，也可以使用命令行远程控制，例如ssh root@192.168.1.105。 传输目标机代码的方法：（1）使用串口。使用dnw或超级终端软件。（2）使用网络协议scp、tftp等传输。同样，可以使用secureCRT，winSCP(windows平台下使用)等软件，也可以使用命令行，例如在主机上运行命令scp test root@192.168.1.105:/上传文件，或者在开发板上运行scp youbo@192.168.1.109:/home/youbo/test .下载文件。 在使用的嵌入式硬件平台中，（1）JS9331开发板，使用串口进入终端，使用scp传输文件。（2）树莓派和Intel NUC3815，使用ssh进入终端，使用scp传输文件。（3）FS4412/ITOP4412开发板，使用串口进入终端，使用tftp传输文件，使用nfs共享根文件系统，此外还使用dnw或者超级终端烧写程序。 说明：使用网络协议nfs共享根文件系统，是开发调试时比较方便的一种方法。应该理解为根文件系统在主机上，主机上对根文件系统的操作会同步到目标机上。因此可以方便的拖动应用软件，而不需要传输。等待功能开发完毕后，可以将根文件系统压缩传输到目标机的flash中，启动时从flash读取根文件系统即可。具体内容还可参见系统移植部分。 参考文档：linux：嵌入式linux开发环境搭建（整理）嵌入式Linux开发环境的搭建之：嵌入式开发环境的搭建 NFS文件系统简介及原理目标板通过nfs挂载根文件系统嵌入式CRT和DnW工具有什么区别扩展文档：OpenWrt NFS启动 实例分析GCC编译C++程序在实际编程中可能涉及调用第三方库函数。而基于第三方库，项目中他人可能编写c++程序，因此涉及如何同时编译c程序和c++程序。以openwrt移植opencv库，并使用c程序调用c++程序函数为例进行分析。详情参见源代码和Makefile。 说明： 使用gcc编译C程序，使用g++编译C++程序，使用g++或者gcc -lstdc++链接。 如果要使用C程序调用C++函数，对于C++函数形参中的对象变量如何在C程序转换使用，需要扩展学习。因此此段代码暂时使用IplImage *指针传参，在函数内部转换为Mat类型。 参考文档：linux下C与C++混合编程 GCC编译C C++ 和C混合C++ GDB远程调试在实际开发过程中，调试程序是必不可少的环节，对于应用程序的调试，可以采用print方法。也可以使用gdb方法。因为gdb通常很大，不适合直接在目标机中运行，因此通常使用目标机运行gdbserver,主机运行gdb进行远程调试。此外，还有一些其他方法，例如分析core文件调试段错误，后续根据需要可做扩展研究。这里分析gdb远程调试的方法。 js9331开发板使用gdb远程调试包括以下步骤： 在openwrt源码目录下make menuconfig选中toolchain option中的gdb,以及development中的gdbserver。 编译openwrt。将/openwrt/staging_dir/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2拷贝到/opt目录下，配置好环境变量。 将/openwrt/bin/ar71xx/packages/base/目录下的gdbserver包及其依赖包传输到开发板进行安装。 开发板运行命令./gdbserver 192.168.1.111:1234 hello。 主机运行mips-openwrt-linux-gdb hello，进入gdb环境。 在gdb环境下运行target remote 192.168.1.105:1234。 在gdb环境下查看搜索文件路径前缀show solib-absolute-prefix，并设置为交叉编译环境库路径前缀set solib-absolute-prefix /opt/OpenWrt-Toolchain-ar71xx-for-mips_34kc-gcc-4.8-linaro_uClibc-0.9.33.2/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2/。之后则进入正式调试环节。 ITOP4412开发板使用gdb远程调试包括以下步骤： 在arm-2009q3交叉工具链中找到gdbserver可执行文件，使用arm-none-linux-gnueabi-strip对其进行瘦身。 使用tftp将瘦身后的gdbserver传输到开发板。 使用arm-none-linux-gnueabi-gcc编译待调试代码，加入选项-g。并用tftp传输到开发板。 开发板运行命令./gdbserver 192.168.1.111:1234 hello。 主机运行arm-none-linux-gnueabi-gdb hello，进入gdb环境。 在gdb环境下运行target remote 192.168.1.230:1234。 在gdb环境下查看搜索文件路径前缀show solib-absolute-prefix，并设置为交叉编译环境库路径前缀set solib-absolute-prefix /opt/arm-2009q3/arm-none-linux-gnueabi/libc。之后则进入正式调试环节。 参考文档：嵌入式开发调试方法 嵌入式Linux的调试技术使用gdbserver远程调试openwrt下使用gdbserver远程调试 搭建交叉开发环境搭建交叉开发环境，主要是安装交叉编译工具链。此外，为了调试方法，会使用tftp和nfs服务，下面做简要分析。这里的操作均是在主机上运行。 js9331开发板openwrt系统搭建交叉编译环境步骤如下： openwrt官网下载工具链压缩包。 解压到/opt文件夹下。 配置环境变量，修改/etc/bash.bashrc文件。 执行命令source /etc/bash.bashrc。 执行mips-openwrt-linux-gcc -v检查安装是否成功。 ITOP4412开发板linux最小系统搭建交叉编译环境步骤如下： 获得工具链压缩包。 解压到/opt文件夹下。 配置环境变量，修改/etc/bash.bashrc文件。 执行命令source /etc/bash.bashrc。 执行arm-none-linux-gnueabi-gcc -v检查安装是否成功。 使用tftp服务 主机安装tftpd-hpa和tftp-hpa。 配置tftp server配置文件，/etc/default/tftpd-hpa。内容如下： 1234TFTP_USERNAME=&quot;tftp&quot;TFTP_DIRECTORY=&quot;/tftpboot&quot;TFTP_ADDRESS=&quot;0.0.0.0:69&quot;TFTP_OPTIONS=&quot;-c -s -l&quot; 创建/tftpboot文件夹，并改变权限。 重启tftp服务，sudo /etc/init.d/tftpd-hpa restart。 复制目标机代码到/tftpboot文件夹下。 目标机输入命令”tftp -g -l 目标文件名 -r 源文件名 tftp服务器IP”即可下载代码。 使用nfs服务 主机安装nfs-kernel-server。 配置文件，/etc/exports。内容如下： 1/source/rootfs *(rw,sync,no_root_squash,no_subtree_check) 创建/source/rootfs文件夹，解压根文件系统到该目录。 复制目标机代码到/source/rootfs文件夹下。 配置目标机启动参数。 注：在集成开发环境也可以编译、调试程序，例如eclipse CDT,其中也需要设置编译器、调试器等参数，其原理本质上和gcc、gdb等一样。 参考文档《嵌入式linux c语言程序设计基础教程》1.6 个人观点这一部分不涉及知识难点，只需要会使用gcc、gdb，以及主机和目标机之间通信的工具，达到完成开发的目的即可。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>gcc</tag>
        <tag>gdb</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--1基础零碎知识]]></title>
    <url>%2F2017%2F11%2F14%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--1%E5%9F%BA%E7%A1%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本篇文章作为C语言高级编程的铺垫，介绍一些C语言相关的基础概念，以及容易出错的零碎知识点。重点包括typedef定义数据类型，宏定义，条件编译，sizeof运算符。 数据这里介绍嵌入式linux c语言数据相关的知识点,包括GNU C简介、基本数据类型、变量与常量定义、预处理等。 ANSI C与GNU C ANSI C是美国国家标准协会ANSI(American National Standard Institute) 1989年颁布的C语言标准，也称为C89，Standard C。1990年ISO和IEC采用了ANSI C(带有一些小改动)为国际标准，所以C89标准又被称为C90标准。后来又有C99和C11。 GNU C(支持GNU扩展的Ｃ语言称之为GNU C)是在标准Ｃ基础上进行了扩展而来，GCC支持C90，不完全支持C99和C11,使用时需加上-std=gnu99之类。GCC由开始的GNU C Compiler变成了GNU Compiler Connection，支持多种语言的编译。 参考文档：1.《ANSI C, Standard C与GCC》2.《GNU C 、ANSI C、标准C、标准c++的区别和联系》 数据类型C语言数据类型如图所示。 说明:不同计算机体系结构中数据类型所占字节数不同，比如32位机或者64位机不一样，编译器相关目录下的limits.h中有相关的规定。123ubuntu系统： /usr/include/limits.hopenwrt交叉工具链： /opt/OpenWrt-Toolchain-ar71xx-for-mips_34kc-gcc-4.8-linaro_uClibc-0.9.33.2/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2/include/limits.h 变量与常量变量：变量采用先定义后使用的规则。变量定义后存储器会为其分配一定的存储空间，一个变量在其作用域内只能有一个定义，可以有多次声明，且存储器不会为其分配存储空间。用typedef定义一种新的数据类型，是编程中常见的处理。常量：常量定义可以使用const，也可以使用define。const的主要知识点在于修饰指针。详见《C语言高级编程-4数组与指针》。 typedeftypedef是c语言的关键字，用于为一种数据类型定义一个新名字。 格式如下：1typedef 已有数据类型 新数据类型 使用typedef的好处有： 给变量起一个易记且意义明确的新名字。例如对函数指针使用typedef。 简化一些比较复杂的类型声明。例如对结构体使用typedef。 用在嵌入式开发移植中，通过typedef为标识符取名为一个统一的名称，在需要修改标识符时，只需要修改typedef的内容。例如/usr/include/asm-generic/types.h，以及linux内核源码中include/asm-arm/types.h。 使用示例：1234567891011121314151617181920212223242526e.g1:链表节点定义，注意这里int也重新定义一个名字，方便后续可以替换其他类型。typedef int datatype;typedef struct node&#123; datatype data; struct node *next;&#125;linknode,*linknode_t;void list_show(linknode_t H)e.g2:枚举类型重新定义新名称。typedef enum&#123; SENSOR_BOOL = 1, SENSOR_INT = 2, SENSOR_DOUBLE = 3,&#125;SENSORTYPE;typedef struct sensorInfo&#123; int sensorID; char sensorName[20]; SENSORTYPE type; void *pValue;&#125;sensorInfo;e.g3:函数指针重新定义新名称。#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum,sighandler_t handler); 预处理预处理是gcc编译的第一步，包括预定义、文件包含、条件编译等功能。预处理的主要作用是用预处理程序将以#开头的语句进行展开。具体关于预处理的相关内容详见《C语言高级编程–2搭建嵌入式linux编程环境》。 预定义预定义符号在C语言中有一些预处理定义的符号串，其值为字符串常量或者十进制常量，常用在调试程序时输出源程序各项信息。常用的有__FILE__、__LINE__、__FUNCTION__等。 宏定义除了系统定义的预处理符号，还有用户自定义编写的宏。这里的宏定义即为用户编写的宏。分为两种，无参宏定义和带参宏定义，定义如下。12无参宏定义 #define 宏名 字符串 带参宏定义 #define 宏名() 字符串 使用说明： 预处理阶段不会对宏做错误检查。 宏定义不必加分号，否则连分号一起替换。 为了避免优先级引起的替换错误，一定要加括号，否则有宏的副作用。不仅被替换的要加括号，可能整个字符串也要加括号。 带参宏定义中宏名和形参表中间不能有空格。多行时用“\”进行分割。可以使用do……while(0)结构，增强可读性。 带参宏定义就是函数宏。在函数宏中，参数每次应用于宏定义时，都会重新求值，多次求值可能导致结果不可预料。 文件包含文件包含是把指定文件插入该语句行位置，从而把指定文件和当前文件源程序连成一个源文件。通常我们称为包含头文件。格式为#include “文件名”或者#include &lt;文件名&gt;。注意：&lt;&gt;是在系统头文件目录去找，而“”是在当前目录下找头文件。此外，书写头文件的格式通常如下，这样可以防止头文件重复包含。123#ifndef _MYFUNC_H_#define _MYFUNC_H_#endif 条件编译条件编译是指根据条件的真假决定是否编译相关代码。按不同条件编译不同的代码。区别if……else,它是都会生成机器语言，根据不同条件执行语句。而条件编译是选择性编译，代码量会少一些，可以通过.i文件区分。条件编译的用途有： 用于移植。在同一份文件中生成不同的可执行文件。 用于调试。区分调试版本和发布版本。 条件编译的格式如下： 方式一： #ifdef 标识符 程序段1 #else 程度段2 #endif 方式二： #if 常量表达式 程序段1 #else 程序段2 #endif 应用实例在实际编程中，常常会打印信息用于调试，判断程序执行情况和出错情况。由于经常使用，有必要自定义一个调试打印代码，可以方便的移植到任何项目中，用于调试。其中涉及到预定义符号、函数宏、条件编译等内容。代码详情参见debug.h。 数据的输入输出常用的输入函数有：getchar,gets,printf。常用的输出函数有：putchar,puts,scanf。其使用方法在此不再赘述。其相关信息相见文件IO和标准IO部分。注意事项 int getchar(void)注意理解返回值是int类型而不是char类型的原因：字符对应的ascii码值范围为0-255，用char类型不能表示完整，此外，如果接收错误，返回-1。因此返回值类型为int类型。 垃圾字符可以用getchar()吃掉或者用格式串中的“%*c”来吃掉。通常产生的原因可能是scanf一个字符，而%c是可以接收转义字符的，所以会把缓存区的字符(例如\n)直接赋值过去。 运算符和表达式C语言包括40多种运算符，常见的运算有：算术运算、赋值运算、逗号运算、位运算、关系运算、逻辑运算、条件运算以及sizeof运算符等。这里只简要介绍需要注意的几点。 重点说明 逗号表达式：分别求两个表达式的值，并以第二个表达式的值作为结果。 位运算表达式：C语言标准说明对无符号数进行移位都是逻辑移位，而有符号数采用算术移位还是逻辑移位取决于编译器。因此一个程序采用了有符号数的右移操作是不可移植的。移位操作相当于乘2或者除2,该运算效率要高于乘除。逻辑移位和算术移位详见ARM汇编一节，另外位运算多用于操作寄存器，参见ARM接口编程。 sizeof操作符：单目运算。用来计算变量或者数据类型占用内存空间字节数。 sizeof(p)p为指针，结果是4或者8,和计算机位数有关。不管是什么类型的指针，结果一样，因此不能对字符指针求sizeof得到字符串长度，而应该使用strlen。 sizeof(a)a为数组名，结果为整个数组所占长度，数组个数=sizeof(数组名)/sizeof(类型)。同样需要注意字符数组求sizeof，可作为期望长度。 条件运算符：三目运算符。示例：#define MAX(a,b) (a)&gt;(b)?a:b 取两个值中的大数。 类型转换运算符：即强制转换。示例：void *需要强制转化，详情见void *知识点,《C语言高级编程-4数组与指针》。如果某数据打印结果显示为一长串数字，不是预期的，需要考虑可能数据类型出现问题。 运算符优先级C语言中，一个表达式中如有不同优先级的运算符，优先级高的先运算。如果相同优先级，则按照结合性规则进行运算。运算符的优先级总结如下表。 程序结构与控制语句C语言中的语句分为：顺序结构、分支结构和循环结构。控制语句有：条件判断语句、循环语句和跳转语句。其具体使用方法在此不再赘述。 这里只简单说明switch语句的格式和注意事项。格式如下所示。其中表达式必须是字符类型或者整数类型，不能是字符串。 1234switch (表达式)case 常量表达式1：语句1;case 常量表达式2：语句2；default:语句n;]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>typedef</tag>
        <tag>宏定义</tag>
        <tag>条件编译</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--6文件系统]]></title>
    <url>%2F2017%2F10%2F29%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[本篇文章主要围绕linux文件系统总结相关知识点，包括文件系统类型、分区与挂载等基本概念以及文件系统重要目录分析。最后简要叙述文件系统体系结构中起重要作用的虚拟文件系统概念，以作后期扩展学习。 文件系统简介文件系统概念 文件系统是一种管理和访问磁盘的软件机制。用于组织和管理计算机存储设备上的大量文件，并提供用户交互接口。 文件系统是linux操作系统的重要组成部分。在linux操作系统中，“一切皆文件”。因此硬件设备也是一种特殊的文件，它挂载在某一目录下被使用。我们需掌握体会linux文件系统与windows文件系统的不同之处。 文件系统类型常见的linux文件系统有以下几种： 磁盘文件类型本地主机可以访问的文件系统，包括硬盘、CD-ROM、DVD、USB、磁盘阵列等。文件系统格式有：Ext3、Ext4、vfat、FAT32、FAT16、NTFS等。 网络文件系统远程可访问的文件系统，在服务器端仍然是本地的磁盘文件系统。文件格式有：NFS、Samba、AFP、WebDAV等。 专有/虚拟文件系统不驻留磁盘的文件系统，即为操作系统加载才产生。文件格式有：TMPFS（临时文件系统）、PROCFS（进程文件系统）、LOOPBACKFS（回送文件系统）。 注：1. 使用du -aTh命令可以看到各文件系统的使用情况和类型。2. 对比Windows系统，文件系统格式主要为NTFS、FAT16、FAT32。 分区与挂载分区 硬盘分区是针对硬件进行操作，分为主分区、扩展分区、逻辑分区。 交换分区：将内存中的内容写入磁盘或者从磁盘中读出，称为内存交换。交换分区的大小最小为计算机内存。需要把交换分区放在硬盘驱动器的起始位置。 挂载 挂载是指将分区和目录对应的过程。将一个文件系统和一个存储设备关联起来。挂载点是指文件树中的挂载目录。 linux下分区与目录的关系 Linux每一个分区都和某一个目录对应，对目录的操作就是对分区的操作，从而实现了硬件管理手段和软件目录管理手段的统一。 在Linux下，查找某个文件，不需要知道其物理存储位置，只需要知道属于哪一个目录即可。 在Windows下，目录属于分区，而在Linux下，分区属于目录。 Linux文件系统和Windows文件系统区别如下图所示。 注:1. 分区的概念可以结合安装linux操作系统的操作进一步加深理解。2. 参考文档：《嵌入式操作系统(Linux篇)》1.5.1 根文件系统目录结构根文件系统定义：存放运行、维护系统所必须的各种工具软件、库文件、脚本、配置文件和其他特殊文件的地方，也可以安装各种软件包，其实就是目录和文件。 文件类型linux系统下文件不是以后缀名不同来区分不同的文件。linux操作系统下有7种文件类型。 b 块设备文件 c 字符设备文件 d 目录文件 - 普通文件 l 链接文件 s 套结字文件 p 管道文件 说明 用ls -l命令可以看到前10个字符表示文件类型和访问权限。访问权限包括读r、写w、执行x。访问权限又分为3个不同用户级别：文件所有者、文件从属组、其他用户。 使用chmod可使用符号标记或者八进制数两种方式改变文件访问权限。如chmod u+r xxx或者chmod 777 xxx。使用符号标记方式改变，可指定多个用户级别，用逗号隔开。 目录分析Linux文件系统就是一个树形的分层组织结构，类似于一棵倒置的树。将根（/）作为文件系统的唯一起点，其他文件和外部设备都以文件的形式挂载在这个文件树上。每一个linux操作系统的文件系统不完全一样，这里以Ubuntu为例，只介绍重要的几个目录。 /bin 普通用户可以使用的命令存放地，类似的有/usr/bin、/usr/local/bin。 /sbin 超级用户可以使用的命令存放地，类似的有/usr/sbin、/usr/local/sbin。 /dev 存放所有设备文件，包括硬盘、键盘、鼠标、网卡、终端等。 /etc 存放系统配置文件。 /home 普通用户家目录。 /root 超级用户家目录。 /lib 存放共享库文件，包括被/bin、/sbin程序使用的库文件，类似的有/usr/lib、/usr/local/lib。 /media Ubuntu系统自动挂载CD-ROM、USB等，存放临时读入的文件。 /mnt 作为临时被挂载文件系统的挂载点。 /opt 作为可选文件和程序的存放目录，通常第三方软件和通过源码安装的软件，可安装于该目录。 /proc 存放所有标志为文件的进程，每一个进程在proc下有一个名为其进程号的目录。 /tmp 存放临时文件。 /lost+found 恢复文件存放位置，系统崩溃时，可在该目录下找到恢复文件，通常为空。 /usr/include c/c++等开发环境的标准include文件。 /usr/local 安装本地程序的一般默认路径。 /var/cache 应用程序缓存目录。 说明 使用tree命令可以查看系统的文件树形目录结构。 用于intel NUC3815的开发IDE Intel® System Studio IoT Edition和openwrt的交叉编译环境都安装在opt下。 /tmp文件夹是tmpfs类型的文件系统挂载于此，而tmpfs文件系统由内核支持，存在于内存中，由于内存的数据掉电丢失，因此系统重启后，该目录下的文件被清空。openwrt系统下安装软件，通常将软件包放于此目录。 制作根文件系统的方法详见系统移植部分。 参考文档：Linux文件系统以及目录结构简介 文件系统体系结构linux文件系统组件的体系结构如下图所示，该图显示了用户空间和内核空间中与文件系统相关的主要组件之间的关系。 文件系统包括三个部分：虚拟文件系统、cache、真正的文件系统(vfat、Ext3等)。其中有重要作用的是虚拟文件系统(VFS)。它是一种转换机制，仅存在于内存中，不存在外存空间。它的作用如下： 给用户空间的程序提供文件系统接口，通过一套统一的文件IO系统调用，对任意文件操作。 提供抽象功能，通过一些数据结构及其方法向实际的文件系统提供接口，实现不同文件系统在Linux中共存。 注：1. 从调用open、read等函数到设备文件正确返回数据的过程加深理解文件系统体系结构。2. 后期可深入内核中文件系统源代码加深理解文件系统的工作机制。3. 参考文档：Linux 文件系统剖析]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>文件系统</tag>
        <tag>根文件系统</tag>
        <tag>虚拟文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--5shell脚本]]></title>
    <url>%2F2017%2F10%2F23%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--5shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[本篇文章围绕shell脚本编程，介绍了shell变量、常用的功能性语句和结构性语句，并通过实例分析进一步理解shell脚本的使用。 shell简介 计算机不能直接理解高级语言，而需要将高级语言翻译成可以理解的机器语言。翻译的方式有两种：编译和解释。而shell脚本就是一种解释性语言。 shell脚本对于管理系统任务和其他重复性工作，有很好的表现。例如在/etc/rcx.d/文件夹下有许多脚本文件，用来存储系统配置和建立服务，必要时可以修改。再例如网络配置重启时，使用命令/etc/init.d/networking restart，其中networking就是一个脚本文件。 shell脚本和windows系统下的批处理类似，脚本文件类似于.bat文件。 shell脚本的本质shell命令的有序集合。 shell脚本的目的批量执行shell命令。 shell编程的基本过程 建立shell文件 赋予shell文件执行权限 执行shell文件 注：执行时要加上./才可以。因为标准搜索路径没有当前路径。 shell变量基本概念 shell允许变量，但是不支持变量类型，所有赋值给变量的值都解释为一串字符。不需要声明。 变量赋值不能有空格，否则解析为命令。 通常使用全大写表示shell变量。 变量的调用：在变量前加$，可以使用{}区分其他内容，即${}。 使用unset命令删除变量的赋值，如unset VAR。 用#开头表示注释，通常在脚本的第一行写#! /bin/bash表示用哪种类型shell解释该程序。 变量类型 用户自定义变量 位置变量（命令行参数）$0表示脚本文件名。$1、$2……${10}等分别表示命令行第一个参数，第二个参数……第十个参数。 预定义变量 $# 表示命令行参数个数。 $@或$* 表示所有命令行参数，不包括命令名称。 $? 表示前一个命令的退出状态。 $$ 表示正在执行的进程ID号。注意预定义变量和makefile的自动变量区分。 环境变量在《Linux操作系统使用–4常用shell命令汇总》中有相关描述，此处不再赘述。补充：使用set命令查看所有本地定义的shell变量，包括环境变量。 使用说明 shell允许变量，但是不支持变量类型，所有赋值给变量的值都解释为一串字符。不需要声明。 变量赋值：VAR=var,不能有空格，否则解析为命令。通常变量使用全大写表示。 变量调用：在变量前加$即可，可以使用{}区分别的内容，即${}，避免歧义。 使用unset命令删除变量的赋值，如unset VAR。也可清除环境变量。 用#开头表示注释，通常在脚本的第一行写“#! /bin/bash”表示用哪种类型shell解释该程序。 常用功能性语句readread var1 var2 var3……表示从标准输入读入一行，把读入的第一个单词赋给var1，把第二个单词赋给var2，其余所有的词赋给var3。注：read是阻塞等待输入的。 exprexpr用于简单的整数运算，包括加(+)、减(-)、乘(\*)、整除(/)、求模(%)等。注：1. expr和运算符之间有空格，运算符之间有空格。2. expr结果赋值给变量，需要使用命令置换。3. 变量运算时，必须使用expr。不能使用$I=$I+1，而是let i++或者expr 1 + 1。切记shell脚本的目的不是做运算。 testtest用来测试字符串、整数、文件属性，每一种有不同的测试操作符。 字符串s1=s2,判断s1字符串和s2字符串是否相等。还有s1!=s2、-z s1、-n s1等,详情参阅手册man test。 整数a -eq b,判断a和b是否相等。在a和b之间还有-ne、-gt、-ge、-lt、-le等，详情参阅手册。 文件属性-d name,判断name是否为一个目录。name前还可以有-e、 -f、 -L、-r、-w、-x、-s等。以及f1 -nt f2、f1 -ot f2等。详情参阅手册。注：1. 可以使用[]代替test，在使用条件语句时常用。注意[]内的内容离左右两个括号都有一个空格。2. 字符串比较，等号和不等号两边的字符串有空格，且字符串要加双引号。3. 使用echo $?查看test结果，真为0,假为1。4. 在系统调用中可以使用stat取得文件属性。 echoecho用于向标准输出打印字符串。注:1. 单引号不解析特殊字符，原样输出。双引号解析特殊字符，进行替换输出。因此如需打印变量的值，需使用双引号。2. echo在打印空格时，若加上双引号，每个空格都打印。若不加，两个单词间多个空格只当做分割两个单词的符号，打印一个空格。参考文档：shell脚本中单引号(‘)和双引号(“)的使用区别 setset用于跟踪调试shell脚本。set -e表示脚本执行出现了返回值为非零时，整个脚本立即退出。set -x表示set命令之后执行的每一条命令以及加载命令行中的任何参数都会显示出来。 各种括号在shell脚本中，常常会使用各种括号。例如： []单中括号可以替代test。 [[]]双中括号用于字符串模式匹配，例如if [[“$i” =~ “.sh”]] 判断是否包含.sh后缀。 {}花括号和$一起使用，${}表示区分其他字符。{}内还可以加入逗号或者“..”表示扩展，例如{1..5}。 ()圆括号和$一起使用，$()和反引号``作用一样，表示取值。 (())双圆括号用在算术运算中，例如for ((I=0;I&lt;10;I++))循环。 参考文档：shell中各种括号的作用()、(())、[]、[[]]、{} 结构性语句shell脚本中的结构性语句主要是掌握每种语句的书写格式,使用方法类似c语言，但不能照搬，注意shell脚本的主要任务是执行命令集合。 条件语句123456789101112131415if 条件then 命令1 命令2fiif 条件1then 命令1elif 条件2then 命令2else 命令Nfi 说明： if i&lt;5用shell表示为if (($i&lt;5)), 或者if [ $i -lt 5 ]。 在脚本中常看到if和then写在一行，用分号隔开。例如if [$i -lt 5];then 多路分支12345678case 字符串变量 in模式1） 命令1 ;;模式2) 命令2 ;;esac 说明： case只能识别字符串变量，且字符串要加双引号。 模式可以使用通配符，也可以同时匹配两个模式，使用|单竖线即可，通常最后一个模式使用*通配剩下所有情况。 匹配模式为字符串匹配。 使用;;结束，类似于c语言中的break。 循环语句for循环1234for 变量名 in 单词表do 命令表done 说明： 这里不是用变量名匹配单词表，而是使用单词表里单词的个数作为循环的次数。 for循环适用于循环次数确定。 如果单词表为所有命令行参数，可以省略“in 单词表”。 一定要区分和c语言中的for循环，shell脚本主要是执行命令。 示例：for ((I=0;I&lt;10;I++))，for i in `seq 1 2 10`（表示从1开始到10,间隔为2），for i in {1..5} (表示从1到5,间隔为1)。 while循环1234while 命令或表达式do 命令表done 说明: while用于循环次数不确定。 死循环为while true。 while语句的退出状态为命令表中最后一条命令的退出状态。 循环控制语句123break n continue 说明：break n表示跳出n层循环，而continue表示转到最近一层循环语句的下一轮循环上。 shell函数 定义：把完成固定功能且多次使用的一组命令封装在一个函数里，使用时调用函数名即可。 原则：遵循先定义后调用。 函数只在当前shell起作用，不能输出到子shell中。 定义格式：函数名()或者function 函数名()，没有形参，使用命令行传参。 调用格式：置换的方式赋值给变量或者单独调用。调用时，就相当于使用一个命令。 函数返回：由return返回或者使用echo $?查看结果。 可以在函数中定义局部变量，使用local修饰。 实例分析通过分析三个实践中使用过的shell脚本。进一步理解shell脚本编程。源代码详见gist。 automatic mount disk in openwrt 该例子是openwrt系统下自动挂载的脚本。编辑文件为/etc/hotplug.d/block/30-disk-mount。 该段代码主要是case……esac语句的使用。模式有add和remove。 参考文档：1. openwrt hotplug2. OpenWrt中的热拔插Hotplug.d中的脚本 mkconfig in uboot source code 该例子是uboot源代码顶层目录下的配置文件，在Makefile中调用，作用是完成编译前针对特定单板的配置工作，编辑文件为u-boot-2013.01/mkconfig。 -a表示&amp;&amp;，-o表示||，在单中括号中使用-a和-o，在双中括号中使用&amp;&amp;和||。 set ${line}表示把line变量设置为当前shell的变量。 shift用来向左移动位置参数。 if [“字符串”]表示判断字符串是否为空。 awk是一个文本分析工具，可以用于字符串匹配分割等。 sed是一个流编辑器，可以用于字符串的替换过滤等。 关于uboot源码的配置编译在系统移植部分再具体分析。 参考文档：1.(三)u-boot2013.01.01 for s5pv210：《mkconfig分析》 2. linux awk命令详解3. Shell脚本学习之sed详解 networking service in ubuntu 该例子是Ubuntu系统下重启网络的脚本，编辑文件为/etc/init.d/networking。 该例子中使用一些函数，例如log_warning_msg。定义在/lib/lsb/init-functions文件中。在第19行使用“. /lib/lsb/init-functions”（点号加文件名）表示调用另一个脚本。 该例子中使用&amp;&amp;和||逻辑运算符，利用其短路性质。当&amp;&amp;连接两个表达式时，只有左边表达式为真时计算右边表达式。当||连接两个表达式时，只有左边表达式为假时计算右边表达式。 关于Linux启动脚本和如何编写启动脚本另做研究总结。 参考文档：1. Linux Standard Base2. 分析 shell 中 的 复杂的 &amp;&amp; 和 || 表达式3. 理解Linux系统/etc/init.d目录和/etc/rc.local脚本4. Linux exec与重定向 个人观点 shell脚本的掌握程度是：能够编写基本的脚本，同时能够理解他人的脚本。 shell脚本编程时出现错误的原因多数是因为未理解shell脚本的实质，与C语言混淆。shell脚本的实质是为了执行一系列命令。 C语言中提供了调用shell脚本的方法，具体内容另起研究总结。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--4常用shell命令汇总]]></title>
    <url>%2F2017%2F10%2F18%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--4%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本篇文章从基本命令、磁盘管理、用户管理、进程管理、文件管理等几个方面总结实践中shell常用命令及其使用场合。并在最后简要介绍环境变量的相关知识：定义、查看、修改。 shell简介基本概念 shell是一个命令行解释器，其功能是将用户命令解析为操作系统所能理解的指令，实现内核和用户的交互。 shell命令包括三个要素，命令名称、选项、参数。命令名称区分大小写。 当多个shell命令写在一行，用分号隔开，顺序执行每一个命令。 当一条shell命令一行写不完，用反斜杠表明。 shell中的特殊字符通配符当用shell命令处理一组文件时，通常使用通配符，提高效率。注意和正则表达式区分。常用于文件名匹配。 - * 匹配任意长度字符 - ? 匹配一个长度字符 - […] 匹配其中指定的一个字符 - […-…] 匹配指定的一个字符范围 - [^…] 除了指定的字符，其他均可匹配 管道功能：将第一个命令的输出作为第二个命令的输入（单竖线 |）示例：ps -ef | grep xxx 用于杀死某个进程时，先用该命令定位进程号ls | wc -l 统计文件个数 置换功能：将一个命令的输出作为另一个命令的参数（Esc下方的引号）示例：wc -l `ls` 统计每个文件的行数ls `pwd` 显示当前路径文件 重定向功能：分为输入、输出、错误重定向，输出重定向用的多。主要是改变shell命令或者程序默认的标准输入、输出、错误目标。示例：> 新建模式，覆盖原文件>> 追加模式，写在已有内容后注：使用> filename可以新建文件参考文档：shell中的通配符，特殊字符和正则表达式 常用shell命令基本命令这里只简要总结常用shell命令。 whereis xxx 查找二进制文件、可执行文件、帮助文档，源文件、配置文件等。 which xxx 查找可执行文件所在位置。 hostname 查看主机名。 whoami 查看当前用户。 history numberline 显示历史命令，在重启电脑后可以查看，以便执行过去的命令。 wc -c/-w/-l xxx 统计文件字符数/单词数/行数。 参考文档：四个查找命令find,locate,whereis,which的区别注：掌握某些命令的选项含义，能够举一反三套用在多个命令中，例如-r表示 recursion递归，-h表示human人类可读。 磁盘管理 df -aTh 查看文件系统空间占用磁盘情况，显示文件格式类型，在清理磁盘时常用。 du -h 查看某个目录/文件所占磁盘空间大小。 dd if=xxx of=xxx bs=xxx count=xxx 块拷贝文件，烧写系统时将镜像拷贝到优盘用到；制作ramdisk文件系统用到。 fdisk 查看硬盘分区及对硬盘进行分区管理。ITOP4412烧写系统用到fdisk -c 0。 mount -t types device mountpoint 将设备文件挂载在某个目录下，openwrt下有手动挂载和自动挂载使用；制作ramdisk文件系统用到。 umount mountpoint 将设备文件卸载。 用户管理 adduser username 添加用户。 passwd username 修改用户的密码。 注：1. 添加一个用户时，系统会将/etc/skel目录下的文件、目录都复制到新用户的主目录下，主要是一些配置文件，如.vimrc、.bashrc等。且会保存在/etc/passwd文件里，一行包含一个账号信息。此外，/etc/group文件记录了组的名称和组员列表。2. 如果忘记密码，可以使用启动界面进入Recovery Mode，以root身份修改其他用户密码。也可以使用passwd直接修改其他用户密码，不必输入旧密码。 进程管理 ps aux 查看进程，侧重查看进程的CPU占用率和内存占用率。 ps -ef 查看进程，侧重查看进程的父进程ID和完整的COMMAND命令。 pstree 以树状形式显示进程。 注：1. 其余关于进程的状态等知识点另起专题研究。2. ps命令经常搭配grep命令，关注感兴趣的进程。 文件管理文件及文件夹 pwd 查看当前路径，在需要粘贴绝对路径时使用该命令。 file xxx 查看文件类型。 rm -rf 强制删除，包括文件夹。小心使用该命令，尤其是root用户。一般不使用rmdir，该命令要求必须为空文件夹。 mkdir -p dir1/dir2 创建多级目录。 head -num xxx 显示文件前num行内容，通常搭配其他命令结合管道使用。 tail -num xxx 显示文件后num行内容。 grep pattern file 查找字符串，格式支持正则表达式。 find path -name “xxx” 查找文件,支持通配符*和?。 diff a b 比较a和b两个文件。 创建链接 ln target link_name 创建硬链接，通过每个文件的iNode建立，不能跨越文件系统。会在选定位置生成一个和源文件大小相同的文件。 ln -s target link_name 创建软链接（符号链接），利用文件路径名建立，使用绝对路径，可以跨越文件系统。实践中使用较多。不会重复占用磁盘空间。 压缩与解压 tar -cvjf xxx.tar.bz directoryname 压缩为bz格式。 tar -cvzf xxx.tar.gz directoryname 压缩为gz格式。 zip xxx.zip directoryname 压缩为zip格式。 tar -xvjf xxx.tar.bz 解压bz格式。 tar -xvzf xxx.tar.gz 解压gz格式。 unzip xxx.zip 解压zip格式。 注：1. iNode是检索i节点表的下标，i节点中存放有文件的状态信息。2. 修改硬链接文件名，链接仍然有效，而软链接断开连接。对于已存在的链接执行移动或删除命令，可能会导致链接断开。如果删除后，建立同名文件，软链接将恢复，但硬链接不再有效。 网络管理网络管理主要是配置上网。临时生效使用命令配置，永久生效编辑配置文件。关于网络的其他基础知识和常用的命令另起专题研究。 ifconfig 查看网络。 ifconfig eth1 192.168.1.126 netmask 255.255.255.0 配置IP和子网掩码。 Ubuntu/Raspbian网卡配置文件：/etc/network/interfacesdns配置文件：/etc/resolv.conf重启生效 ：sudo /etc/init.d/networking restart openwrt网卡配置文件：/etc/config/network重启生效：/etc/init.d/network reload 注：1. 如果ping不通域名网址，可能需要修改dns配置文件。2. resolv.conf文件在重启后被清空，需要再次配置。 环境变量环境变量是指用户运行环境的参数集合。每一个用户都有其专门的运行环境。用户可以对运行环境进行定制，即修改系统环境变量。环境变量的书写为 环境变量名=内容1：内容2。使用环境变量的场合有： 安装软件，配置路径环境变量，以便全局使用。 切换用户时，通常带上环境变量和工作目录，确保软件的正常使用，如su - root。 常见的环境变量 PATH 系统路径 HOME 系统家目录 HISTSIZE 保存历史命令记录的条数 LOGNAME 当前用户的登录名 HOSTNAME 主机名称 SHELL 当前用户用的哪种shell 查看/设置环境变量 env 查看所有环境变量。 echo $environmentVariable 查看某一环境变量的内容。 export PATH=/home/youbo:$PATH 临时添加环境变量，只对当前终端有效。 如果想要永久性修改环境变量，则需要修改配置文件。 /etc/profile 系统级环境变量 e.g:安装java和tomcat /etc/bash.bashrc 系统级bashrc e.g:安装openwrt交叉编译环境 /home/xxx/.bashrc 用户级环境变量 e.g:修改HISTSIZE 注：修改完配置文件后，需要使用source命令使其生效，不必重启参考文档：Linux环境变量种类、文件、设置]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>shell命令</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--3软件包管理]]></title>
    <url>%2F2017%2F10%2F15%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--3%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇文章围绕Linux平台下软件包管理问题，首先介绍deb软件包和rpm软件包两种常用的软件包管理机制，重点介绍deb软件包的dpkg命令和apt原理，简述rpm软件包的rpm命令和yum工具。然后归纳在实践中使用的除上述两种软件包管理之外的方法，并结合所使用的硬件平台给出一些具体的软件包安装实例说明。 软件包管理机制定义把应用程序的二进制文件、配置文档、man/info帮助页面等文件合并打包在一个文件中，使用软件包管理器操作软件包，完成获取、安装、卸载、查询等操作。 主要功能安装、卸载、查询、升级、校验等。 软件包管理是在工作中必做的一项任务，但Linux系统下的软件管理和Windows下软件管理截然不同，因此需要了解Linux系统软件管理的原理、方法并熟练使用。通常有两类软件包管理机制：Debian系统的deb软件包(.deb)管理和Redhat系统的rpm软件包(.rpm)管理。 关于两种软件包管理机制的重要说明： 原理十分类似，命令有所区别，掌握其中一种，其余的有需要时再查询资料。 由Debian或者Redhat衍生出来的Linux系统必然使用与之相关的软件包管理机制。 deb软件包deb软件包管理有两种方式：dpkg本地安装和apt在线安装。dpkg安装方式适用于deb软件包已经下载到本地时进行。而APT工具适合联网时安装使用。 dpkg本地安装常用的命令有以下几个： - dpkg -i xxx.deb 安装软件 - dpkg -r xxx 移除软件 - dpkg -P xxx 移除软件和配置文件 - dpkg -l 列出已安装软件清单 - dpkg -s xxx 显示某个软件安装情况 apt在线安装定义APT是Ubuntu Linux中功能最强大的命令行软件包管理工具，用于获取、安装、编译、卸载、查询deb软件包和检查软件包依赖关系。它是一组命令，包括apt-get、apt-cache、apt-proxy、apt-show-versions、apt-config、apt-cdrom等。其中最常用的apt-get。 原理1.配置软件源各种软件包存放在软件仓库中，软件仓库置于镜像服务器中，在/etc/apt/sources.list软件源配置文件中列出最合适访问的镜像站点。该文件可以直接编辑修改。 在更新源或者添加源时，修改sources.list文件，需要了解其配置项的书写格式，可参考以下文档。另外，直接访问镜像站点查看各个文件夹也有助于进一步了解APT安装软件的原理。参考文档：《嵌入式操作系统Linux篇》3.2.1节debian软件源source.list文件格式说明apt系统中sources.list文件的解析 2.刷新软件源使用apt-get update命令，从/etc/apt/sources.list文件中的每一个配置项下载软件包列表，即建立索引文件，存放在/var/lib/apt/lists目录下。 3.安装软件包使用apt-get install xxx命令，会执行以下几个步骤： 本地扫描软件包列表(/var/lib/apt/lists目录)找到软件包。 检查依赖关系，找到支持软件运行的所有软件包。 从软件源指向的镜像站点下载软件包，存放于var/cache/apt/archives目录。 解压软件包，自动完成应用程序的安装配置。 注：1. apt-get install执行时的打印信息就是其步骤过程2. apt的cron脚本会限制var/cache/apt/archives目录的存储空间和其中文件的存放时间 特点相比于dpkg，APT软件包管理的两个特点是： 检查和修复软件包的依赖关系 需要使用Internet网络获取软件包 apt-get常用命令如下： - apt-get update 下载更新软件包列表信息 - apt-get upgrade 软件包升级为最新版本 - apt-get install xxx 安装软件 - apt-get --reinstall install xxx 重新安装软件 - apt-get check 检查是否有损坏的依赖 - apt-get -f install 修复软件包依赖问题 - apt-get remove xxx 卸载软件 - apt-get --purge remove xxx 完全卸载软件 - apt-get autoremove 将不满足依赖关系的软件包自动卸载 - apt-get clean 删除缓存区所有已下载的包文件 - apt-get autoclean 删除缓存区老版本已下载的包文件 注：apt-get autoclean在释放磁盘时会用到 apt-cache常用命令如下： - apt-cache show xxx 获取二进制软件包详细描述信息 - apt-cache search xxx 根据正则表达式检索软件包 - apt-cache depends xxx 查询该软件包的依赖信息 - apt-cache rdepends xxx 查询所有依赖该软件包的软件包 - apt-cache policy xxx 查询软件包安装状态 rpm软件包rpm软件包管理是另外一种软件包管理机制，和deb功能十分相似。在此不再赘述，有需要时请查阅参考资料。 rpm本地安装rpm的功能类似于dpkg yum在线安装yum功能类似于apt，也有相应的配置文件/etc/yum.conf，/etc/yum.repos.d/目录，数据库目录/var/lib/rpm/等。 rpm和yum使用详情，参考linux软件包管理之一（rpm包管理）deb和rpm软件包管理命令对比，参考Linux软件包管理 应用实例值得注意的是，上述两种软件包管理机制适用的Linux平台为Debian和Redhat系统及它们衍生的Linux系统，而对于嵌入式Linux安装软件又有其各自的特殊之处。另外，基于Linux开源的思想，还有一种特别的软件安装方法，即源码安装。 因此，在实践中，有两个方面需要考虑。第一，Linux平台有哪几种软件安装方法可供选择。第二，具体在哪种Linux平台上安装软件，需要注意什么问题。 Linux平台下安装软件的几种方式 使用dpkg、rpm等底层工具安装需要将软件包下载到本地后，再使用命令安装。 使用apt、yum等上层工具安装联网安装，自动检查依赖关系。 源代码编译安装第三方开源软件通用的安装方法，通常经历：下载--解压--./configure--make--make install等步骤。不同的软件以及不同的安装平台具体细节有差别，该方法可做专题研究，尤其是在嵌入式Linux平台移植，可做总结。 其他除了以上安装方法，有的软件提供安装脚本，直接运行即可。还有其他方法参考以下文档。 参考文档：汇总linux下安装软件的几种方式 实践中各平台的操作系统在实践中我使用了四个硬件平台，关于其详细介绍参考嵌入式学习笔记--前言，在此不再赘述。使用cat /proc/version命令或者cat /etc/issue命令查看各平台的操作系统详细信息。总结如下： - 树莓派3 B：Raspbian GNU/Linux 8 - JS991开发板：openwrt - Intel NUC DE3815TYKHE：Wind River Linux 7.0.0.13 - IOT4412/FS4412开发板：Linux version 3.0.15 实例注意事项总结树莓派/Ubuntu说明 树莓派和Ubuntu都基于Debian系统，因此安装软件首选apt工具。 首先尝试apt-cache search xxx 和 apt-get install xxx。 若提供该软件的软件源，则需要使用apt-key命令导入GPG密钥；配置软件源文件，下载至/etc/apt/sources.list.d/或手动创建编辑；再apt-get update和 apt-get install xxx。 对于ppa个人软件包，使用add-apt-repository命令添加软件源，再apt-get update和 apt-get install xxx。 使用git clone、wget等方法下载安装包，使用提供的脚本安装或者编译源码安装。 实践example Ubuntu下安装mosquitto服务器进行mqtt通信实验 Ubuntu下安装Tomcat web应用服务器进行Java后台开发实验 Ubuntu下安装docker，Intel® System Studio IoT Edition进行Intel网关开发 Ubuntu下安装gsoap进行onvif协议开发 树莓派下安装FFmpeg进行视频推流实验 树莓派下安装node、npm，利用AWS IOT JavaScript SDK进行树莓派连接AWS云实验 树莓派下安装Azure IOT开发包进行树莓派连接Azure云实验 注：有的软件安装涉及环境变量配置，和Windows下类似 JS991开发板说明 openwrt系统下软件包管理工具为opkg,通常使用opkg install xxx.ipk。 如果安装失败，提示缺少依赖的库，可以先使用opkg install安装该库或者找到openwrt系统中该动态链接库，将其复制到开发板的/usr/lib下，再安装相关软件。 ipk软件包可以来源于openwrt下载官网，也可以自己制作并在内核中编译生成，具体制作方法另起专题研究。 支持LuCi进行页面可视化安装软件。 参考文档：openwrt安装软件的两个方法 实践example openwrt下移植opencv，进行视频图像处理实验。 Intel NUC DE3815TYKHE说明 wind river Linux系统作为Intel IoT Gateway Software Suite的一部分提供，此处使用的是免费版本Wind River Linux 7.0.0.13。 Wind River Linux 7.0.0.13系统下的软件包后缀为rpm，软件包管理工具为smart update、smart install、smart channel --add等。可能类似rpm软件包管理，具体需深入学习该系统。 若提供软件源，需要使用rpm --import命令导入GPG密钥，然后使用smart channel --add添加软件源，再使用smart update和smart install。 添加软件源镜像所能访问的文件夹需要和操作系统版本保持一致。 支持页面添加源和软件安装。 实践example wind river Linux下安装AWS IOT SDK,进行Intel nuc3815连接AWS云实验 wind river Linux下安装paho.mqtt.c,进行mqtt客户端通信实验。 wind river Linux下安装OpenSSL，用于mqtt安全通信。 声明：文章中涉及的参考文献并不是随意引用，均是经过笔者阅读大量资料筛选后所得，和本文有密切关系，可放心阅读。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>软件包管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--2文本编辑器VIM]]></title>
    <url>%2F2017%2F09%2F27%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--2%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8VIM%2F</url>
    <content type="text"><![CDATA[本篇文章简要叙述文本编辑器VIM的使用，包括VIM的3种模式，常用的功能键，常用的插件配置。同时给出可供参考的IDE，以作扩展学习。 vim编辑器3种模式 命令模式：主要是光标跳转、复制、粘贴、删除。 编辑模式：主要是文字编辑。 底行模式：主要是保存、退出、查找、替换、设置编辑环境。 注：三种模式叫法可能存在差异，理解每个模式下的功能即可 常用功能键与快捷键这里只列举常用的一些功能键和快捷键。 多窗口与多标签 新窗口 Ctrl+shift+n 新标签 Ctrl+shift+t 跳转 跳转到第n行 ngg 查找字符串 正向查找 /str 跳到下一处 n 跳到上一处 N 反向查找 ?str 替换字符串 m行到n行的str1替换为str2 ：m,ns/str1/str2/g 全文str1替换为str2 ：%s/str1/str2/g 注：最后的g表示一行中所有匹配的字符串，不加则只替换第一处 撤销与反撤销 撤销 u 反撤销 Ctrl+r 重复上一修改正文的操作 .(点号) 显示行号 :set number 分屏 竖分屏 :vsp filename 横分屏 :sp filename 比较两个文件 未打开文件时 vimdiff a.c b.c 打开a.c时，和b.c比较 :vert diffsplit b.c 参考文档：Vim入门基础 配置文件与插件网上有许多关于VIM配置的说明，我认为最重要的是知道自己要做什么，而不是盲目的使用教程做复杂的配置。 作为新手，我主要用vim进行C语言开发，我常用以下功能。 - 查看定义(宏、变量、函数名等) - 符号一览(宏、变量、函数名等) - 查看文件目录 - 代码补全 因此需要下载相关插件，并编辑配置文件，以期实现以上功能。其中插件下载后存放于~/.vim文件夹，配置文件为~/.vimrc，当前用户有效。 ctags插件实现查看定义使用步骤 1. 在源码目录下执行ctags -R，生成tags文件 2. 在.vimrc文件中添加:set tags +=源码路径/tags 3. 跳转定义使用Ctrl+] 4. 返回使用Ctrl+t 注：程序修改后，需重新运行ctags -R taglist插件实现符号一览使用步骤 1. 前提：ctags已经打好标签 2. 打开taglist窗口使用:Tlist 3. 光标选择符号，按enter键跳转到定义 4. 光标选择符号，按空格键，在底行显示tag的完整表达 netrw、WinManager插件实现查看文件目录使用步骤 1. 注：netrw已随vim安装，无需下载 2. WinManager的作用是组合netrw窗口和taglist窗口 3. 打开窗口使用wm,关闭窗口再次使用wm 4. 光标选择文件或文件夹，按enter键进入 5. 返回上级目录使用-键 new-omni-completion、SuperTab插件实现自动补全使用步骤 1. 输入几个单词后，按下Tab键进行选择 注：程序修改后，需重新运行ctags -R 参考文档：手把手教你把Vim改装成一个IDE编程环境(图文) IDE编程环境除了VIM编辑器，还有许多集成开发环境可供选择。比如以下两种。 eclipse CDT QT creator 在实践中，我在Ubuntu16.04上安装过Intel® System Studio IoT Edition(linux版)开发Intel NUC DE3815网关的C语言程序，该IDE是基于eclipse的。同时，也使用过eclipse for ARM(windows 32版)开发FS4412裸板的汇编语言程序，并未做深入研究。 个人观点我认为，IDE的使用原理和vim + Makefile + gcc的方式一致，只是在交叉编译环境配置和可视化编程等方面有所不同。 关于vim的高级配置以及IDE的使用，待基础技能熟悉后，视情况再做深入讨论。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--1基本概念]]></title>
    <url>%2F2017%2F09%2F26%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[本篇文章简要叙述嵌入式Linux中的基本概念：嵌入式系统的定义、Linux的发展、Linux操作系统的组成以及Linux作为嵌入式操作系统的优缺点，以期对嵌入式Linux有一个大致的了解。 嵌入式系统定义嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，对可靠性、成本、功耗、功能、体积有严格要求的专用计算机系统。 Unix家庭树Linux是类Unix系统，通常所谓的Linux系统全称是GNU/Linux。Unix家庭树如下图所示，了解GNU/Linux所在位置。 此外，与GNU/Linux和BSD家族系统有密切关系的是GPL、BSD软件许可协议。关于常见的开源软件许可协议可做专题分析。 Linux操作系统组件Linux操作系统主要由四部分组成：Linux内核、shell、文件系统和应用程序。 Linux内核内核是操作系统的核心，包括设备驱动、内存管理、进程管理、文件系统 、网络管理和系统调用接口。 shellshell是一个命令解释器，它是Linux内核外层的保护工具，完成用户和内核之间的交互。常用的版本为BASH。 文件系统文件系统是文件存放在磁盘等存储介质上的一种组织方式。Linux操作系统中将文件系统组织为一个层次化的树形结构。 个人观点：Linux下一切皆文件，而通信的本质我认为就是文件的读写。 应用程序 参考文档：Linux系统结构 详解 Linux作为嵌入式操作系统的优缺点优点- 低成本开发：开源且免费使用。 - 适用于多种硬件平台：x86、ARM、MIPS、PowerPC等。 - 内核可定制：模块的插入或移除机制。 - 性能优异：占用资源少、运行稳定、速度快。 - 良好的网络支持：实现了TCP/IP协议栈。 缺点- Linux对硬件有一定要求，而嵌入式硬件资源通常有限。 - Linux结构体系复杂，代码量大。 - 产品化时，遇到问题需要自行解决。 - 产品化时，移植优化工作量大。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>unix家庭树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式Linux学习路线]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[概述本篇文章简要说明嵌入式Linux的学习路线，后续系列文章将按照本篇所述内容进行展开。 嵌入式Linux开发基础- Linux操作系统使用 - C语言高级编程 - 数据结构 嵌入式Linux应用层开发- 文件I/O与系统I/O - 进程和线程 - 网络编程 嵌入式Linux底层开发- ARM处理器编程 - ARM硬件接口编程 - 系统移植 - 设备驱动 - Android底层驱动 嵌入式系统项目实战- 电子词典 - 仓储物联系统]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式学习笔记--前言]]></title>
    <url>%2F2017%2F09%2F08%2F%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[写在前面的话动手写博客前，我一直在思考：博客……写点啥，为了啥，有意义么。第一次写博客，难免有些紧张和忐忑。 我从2017年2月到9月系统的学习了嵌入式Linux的相关知识，包括嵌入式Linux应用层和底层开发等。另外，从去年9月工作以来，我在工作项目中也接触了几款嵌入式设备。因此，我希望借写博客开启嵌入式小白的学习成长之旅。 对于开篇的问题，有以下几点说明： 1. 总结的首要目的是梳理知识点，巩固加深理解，熟练掌握开发技能。 2. 总结的内容为嵌入式Linux重点知识整理，掺杂日常实践中的问题分析。 3. 最后，博客不仅分享的是学习资料，也是笔者的学习心得，而后者是不可复制的。我想，这就是最大的意义所在。此外，若这些短文能够带给您一点帮助或启发，那将是我莫大的荣幸。 嵌入式平台树莓派3 B SoC： BCM2837 CPU： ARM Cortex-A53 1.2GHz 四核 GPU： Broadcom VideoCore IV, OpenGL ES 2.0, 1080p 30 h.264/MPEG-4 AVC 高清解码器 内存： 1GB 外设： WiFi、蓝牙4.1、10/100网口、USB2.0*4、microSD、HDMI、3.5mm音频插孔、CSI摄像头接口、DSI显示接口、40pin扩展GPIO OS： Debian GNU/Linux、Fedora、Arch Linux、RISC OS、Windows10、Snappy Ubuntu Core JS9331开发板 SoC： Atheros AR9331 CPU： AR9331 MIPS 24K 400MHz 内存： 64MB DDR2 SDRAM 外存： 8MB/16MB SPI flash 外设： WiFi、10/100网口*2、USB2.0*2、TTL/RS232串口、USB mini串口、LED*4、key*4、板载温度传感器、红外发送接收、5pin扩展GPIO OS： openwrt Intel NUC DE3815TYKHE套件 CPU：Intel x86 Atom E3815 1.4GHz 单核 内存：单条SO-DIMM内存插槽(最大容量8GB) DDR3 缓存：512KB 外存：4GB eMMC闪存、2.5寸SATA硬盘位 外设：半长式mini PCI-E扩展插槽（无线网卡）、10/100/1000网口，USB 3.0、USB 2.0*2、VGA、HDMI、音频插孔 OS：Intel IoT Gateway Software Suite、Ubuntu 16.04 LTS、Wind River Pulsar Linux IOT4412/FS4412开发板 SOC： 三星Exynos4412 CPU： ARM Cortex-A9 1.4GHz 四核 内存： 1GB DDR3 外存： 4GB eMMC 外设： 20针WiFi接口、microSD、USB2.0*2、USB OTG、10/100网口、音频插孔、串口*2、key*5、20PIN扩展GPIO、20针camera接口、HDMI、LVDS_LCD*2、RGB_LCD OS： Android4.2、Linux-QT、Ubuntu 注：此处以IOT4412说明，FS4412与之类似，外设稍有差别 附：uname -a命令结果- 树莓派3 B： Linux raspberrypi 4.9.35-v7+ #1014 SMP Fri Jun 30 14:47:43 BST 2017 armv7l GNU/Linux - JS991开发板： Linux JoySince 3.10.49 #10 Fri Jul 21 18:31:20 CST 2017 mips GNU/Linux - Intel NUC DE3815TYKHE Linux WR-IDP-42C1 3.14.58_IDP-XT_3.1-WR7.0.0.13_idp #1 SMP PREEMPT Tue Jun 7 16:52:19 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux - IOT4412/FS4412开发板 Linux iTOP-4412 3.0.15 #3 SMP PREEMPT Thu Apr 2 18:49:01 PDT 2015 armv7l GNU/Linux]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>嵌入式硬件平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js升级]]></title>
    <url>%2F2017%2F07%2F15%2FNode.js%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Node.js版本更新很频繁，由0.1x版本跃升至4.x乃至目前最新的8.x版本，升级Node.js很有必要 查看Node版本 1$ node -v 安装n模块 1$ npm install -g n 查看所有node版本 1$ n ls 升级Node 12$ n 4.4.0（版本号） # 升级到指定版本$ n stable # 升级最新的稳定版本]]></content>
      <categories>
        <category>日常case</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Git 搭建一个个人博客]]></title>
    <url>%2F2017%2F07%2F04%2FHexo-Git-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Github Pages搭建个人网站 Github Pages是GitHub免费提供给开发者的一款托管个人网站的产品，首先需要创建一个GitHub账号 在GitHub创建一个仓库：username/username.github.io，username是你的账户名，这是特殊的命名约定 在此仓库提交一个index.html文件，网站内容是在master分支下的 访问http://username.github.io，就能看到自己的网站了 绑定独立域名 如果你有自己的域名的话，在之前的仓库点开设置(Settings)，找到GitHub Pages，在Custom domain添加自己的域名，保存(Save)即可 在你的域名注册提供商那里配置DNS解析，获取GitHub的IP地址，添加A记录即可 使用Hexo搭建博客 前提已安装Node.js和Git 安装Hexo 1$ npm install -g hexo-cli 建站 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 安装 hexo-server 1$ npm install hexo-server --save 生成静态文件 1$ hexo generate # 或者 hexo g 启动本地服务 1$ hexo server # 或者 hexo s 查看结果访问http://localhost:4000/，已经可以看到一篇内置的blog了，Hexo使用Markdown解析文章 部署Hexo到Github Pages 安装hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改配置文件_config.xml注：配置文件中，冒号后面一定要加空格 1234deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 执行部署 1$ hexo deploy # 或者 hexo d 使用git部署将我们之前创建的repo克隆到本地，将hexo generate生成public文件夹下的内容copy到本地repo，然后使用git commit提交代码，最后push到远程repo的master branch上即可 查看结果访问http://username.github.io，能看到Hexo内置的blog已经发布到自己的网站了 使用独立域名 123$ cd source/$ touch CNAME$ vim CNAME # 输入你的域名 Hexo主题Next及常用第三方服务 Next主题Hexo支持更换多种主题，本站所用主题是：Next，将喜欢的主题放在themes文件夹内，并修改_config.yml内的theme设定，即可切换主题 1theme: next # Hexo默认主题是landscape 标签与分类确认站点配置文件以及主题配置文件里开启响应设置，新建标签和分类页面内容，在新发布的blog首部设置自定义标签和分类即可 1234567891011121314151617181920212223# 站点配置文件tag_dir: tagscategory_dir: categories # 主题配置文件tags: /tagscategories: /categories # 新建source/tags/index.mdtitle: tagsdate: 2015-10-20 06:49:50type: &quot;tags&quot;comments: false # 新建source/categories/index.mdtitle: categoriesdate: 2015-10-20 06:49:50type: &quot;categories&quot;comments: false # 新发布的blog首部设置categories: 类别tags: [标签1,标签2,标签3] 网站统计百度统计登录百度统计，定位到站点的代码获取页面，复制 hm.js? 后面那串统计脚本 id，修改主题配置文件内的字段 baidu_analytics，值设置成你的百度统计脚本id 12# Baidu Analytics IDbaidu_analytics: **** 阅读次数统计LeanCloud注册LeanCloud帐号，创建一个应用，在应用的配置界面创建Class（名字必须为Counter），由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。在应用Key界面拿到AppID以及AppKey这两个参数，修改主题配置文件内对应的的字段即可。另外，建议开启Web安全选项，在安全中心的Web安全域名中填入我们自己的博客域名，来确保数据调用的安全 1234# leancloud_visitors:enable: trueapp_id: ****app_key: **** 评论系统HyperComments首先需要在文章首部开启评论，Next官网提供的DISQUS、多说、网易云跟帖等都已经停止服务了，只好使用HyperComments，创建一个免费应用即可，拿到WIDGET-CODE，修改主题配置文件内对应的的字段即可 123456# 文章首部设置comments: true # 主题配置文件# Hypercommentshypercomments_id: **** 分享系统jiathis注册jiathis账号，获取uid后更改配置文件内对应的的字段即可 123jiathis: enable: false id: 2139015 搜索服务LocalSearch安装 hexo-generator-searchdb，编辑站点配置文件和主题配置文件 12345678910111213# 安装 hexo-generator-searchdb$ npm install hexo-generator-searchdb --save # 站点配置search: path: search.xml field: post format: html limit: 10000 # 主题配置local_search: enable: true 打赏服务编辑主题配置文件，添加comment和支付二维码即可 1234# 打赏配置 可自己添加reward_comment: 您的支持将鼓励我继续创作！wechatpay: # 微信收款二维码alipay: # 支付宝收款二维码 腾讯公益404页面寻找丢失儿童，让大家一起关注此项公益事业！新建404.html页面，放到主题的source目录下，内容如下 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; &lt;meta name="robots" content="all"/&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>开源工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>