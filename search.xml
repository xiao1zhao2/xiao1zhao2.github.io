<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[标准IO与文件IO]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%A0%87%E5%87%86IO%E4%B8%8E%E6%96%87%E4%BB%B6IO%2F</url>
    <content type="text"><![CDATA[前面从linux操作系统使用、C语言高级编程、数据结构三个方面总结了嵌入式linux开发基础相关的内容。从本篇开始，进入嵌入式linux应用层开发的知识总结。应用层开发知识梳理表面上来看，就是讲解函数的使用方法。那么这就包括理解函数的原理、根据需要选择合适的函数。嵌入式linux是由linux裁剪而来，其系统调用和用户编程API和linux基本一致。因此一般的思路是学习linux相关内容的基本编程开发，再移植到嵌入式开发板中运行。这一点对于第三方库移植也有借鉴思路，先在linux环境下实验，再移植到嵌入式环境中，比如onvif移植。本篇文章从系统调用、库函数等概念引入，详细说明了标准IO和文件IO中重要函数的使用。 先导概念系统调用 系统调用是指操作系统提供给用户程序调用的一组特殊接口。用户程序可以通过这组接口来获得操作系统内核提供的服务。 关于内核态和用户态：出于对内核空间安全保护的考虑，将程序运行的空间分为内核空间和用户空间，它们分别运行在不同的级别上，逻辑上相互隔离。通常情况下，用户进程不能访问内核数据，也无法使用内核函数。如果用户空间要使用系统服务，即调用内核空间程序，那么就需要通过系统调用，规定用户进程进入内核空间的具体位置。进行系统调用，程序运行空间需要从用户空间进入内核空间，处理完后返回用户空间。这就是为什么强调不要频繁陷入内核态的原因。 系统调用是通过软中断的方式向内核提交请求以获得内核服务的接口。linux系统调用继承了unix的系统调用，包括进程控制、进程间通信、文件系统控制、系统控制、存储管理、网络管理、socket控制、用户管理等。 系统调用是用户空间进程访问内核的接口。把用户从底层的硬件编程中解放出来。极大的提高了系统的安全性，使用户程序具有可移植性。 库函数 库函数是为了实现某个功能而封装起来的API集合，提供统一的编程接口，更加便于应用程序移植。 库函数相当于是对系统调用的又一层封装。库函数是面向程序员的应用编程接口，是在用户空间。 一个库函数有可能含有一个系统调用，也有可能有好几个系统调用，也有可能没有系统调用，比如有些操作就不需要涉及内核的功能。 两者的联系区别 使用man man命令可以看到2为系统调用，3是库函数。 库函数是在用户空间，而系统调用是在内核空间。 库函数多用于普通文件读写，而系统调用多用于底层文件访问，例如驱动程序中对设备文件的访问。 系统调用和库函数从实现者角度看有本质区别，但是对于用户来说，都是以C函数形式出现。 系统调用和库函数是调用函数的两种方式，用户可以使用库函数也可以使用系统调用。 注意相关概念：用户编程接口API，通常是指库函数。用户编程接口要遵循POSIX标准，由IEEE和ISO/IEC共同开发。主要是通过C库（libc）实现。-注意相关概念：系统命令，是可执行文件，相对于API更高一层。它的内部引用了用户编程接口来实现相应功能。因此会看到许多同名的命令和函数。 具体的系统调用函数和库函数可以参考《UNIX程序员手册》第二、三章内容。 参考文档：深入理解系统调用与库函数调用Linux系统调用及用户编程接口(API)系统调用与库函数调用库函数与系统调用C标准库，系统调用，系统接口API，内核函数 标准IO基本概念概述 标准IO库由ANSI C标准说明。 标准IO库处理很多细节，比如缓冲区分配，以优化的块长度执行IO，使用户不必关心如何选择合适的块长度。 标准IO库在系统调用函数基础上构造，便于用户使用。 标准IO库以及其头文件stdio.h为底层IO系统调用提供了一个通用的接口。 流与FILE对象 标准IO的所有操作都是围绕流来进行，所有IO操作仅是简单的从程序移进或移出，这种字节流称为流。流用FILE *表示。 流分为文本流和二进制流。文本流：在流中处理的数据是以字符出现。二进制流：流中处理的数据是二进制序列。 FILE *是文件指针。每个被使用的文件都在内存中开辟一个区域，用来存放文件的相关信息，这些信息保存在一个系统定义的结构体中，即FILE。信息中包括实际IO文件描述符，缓冲区的长度，当前缓冲区的字符数等。 在/usr/include目录下使用“ctags -R”生成tags文件，使用“vi -t FILE”查看FILE结构体的定义在libio.h中。 标准IO预定义了三个流，包括标准输入stdin、标准输出stdout、标准错误输出stderr，它们都是FILE *类型。 缓冲 标准IO库提供缓冲的目的是尽量少使用read/write调用。 系统自动在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，装满缓冲区后再一起送到磁盘中。如果要从磁盘读数据，则一次从磁盘文件将一批数据读入内存缓冲区，再从缓冲区逐个将数据送到程序的数据区。 缓冲分类：全缓存，行缓存，不带缓存。 全缓存：当填满IO缓存后才进行实际的IO操作。进行IO操作是指调用read/write。对于驻留磁盘上的文件就是实施全缓冲。在流上执行第一次IO操作时，通常调用malloc获取需使用的缓冲区。刷新条件：缓存满、程序正常结束、fflush。 行缓存：当输入输出遇到’\n’，进行IO操作。当流涉及到终端时就是典型的行缓存。刷新条件：’\n’、缓存满、程序正常结束、fflush。 不带缓存：不对字符进行缓存，标准出错通常是不带缓存的。 使用setbuf和setvbuf函数可以更改缓存类型。 使用fflush可以强制刷新一个数据流。fflush是针对写操作，将缓冲区的数据写到磁盘中。当代码的执行现象和预估不一致时，要考虑是否是和缓冲有关，必要时使用fflush强制刷新。 标准IO是带缓存的IO，这里的缓冲区是在用户空间的流缓存区。 123456789101112131415161718192021222324252627282930313233343536373839示例1：#include &lt;stdio.h&gt;int main(int argc,const char *argv[])&#123; while(1) &#123; fputc(fgetc(stdin),stdout); &#125; return 0;&#125;该程序是循环从标准输入读入，并逐个字符显示在标准输出上。运行现象是输入一些字符后，按回车，显示所有字符，再继续敲入一行，显示一行。这就是因为标准输入标准输出是行缓存，遇到&apos;\n&apos;刷新。示例2：/* * 生成二叉树 * 这里输入字符序列是按照先序输入 * 根左右 * */bitree_t bitree_create()&#123; datatype_t ch; scanf(&quot;%c&quot;,&amp;ch);//这里有输入的缓冲机制，必须要输入正确个数，递归才会结束 if(ch == &apos;#&apos;) //这里认为输入#表示该位置没有数据 &#123; return NULL; &#125; bitree_t root = NULL; root = (bitree_t)malloc(sizeof(bitree)); if(root == NULL) &#123; DEBUG_CUSTOMERR(&quot;malloc error&quot;); return NULL; &#125; root-&gt;data = ch;//填充数据 root-&gt;lchild = bitree_create();//递归生成左子树,这里左右孩子是struct node*类型，也是bitree_t类型，所以可以作为bitree_create的返回值 root-&gt;rchild = bitree_create();//递归生成右子树 return root;&#125; 参考文档：linux 标准IO缓冲机制探究Linux中带缓冲IO和不带缓冲IO的详细说明深究标准IO的缓存scanf函数与输入缓冲区 函数介绍标准IO函数的介绍主要是理解各个函数使用的特点，以便合理的选择。详细使用方法见man手册。 打开流fopen/关闭流fclose打开流 相关函数fopen/freopen/fdopen。fopen最常用，freopen常用于将指定文件打开为预定义的流。fdopen常用于关联由管道、网络通信返回的文件描述符对应的文件。 mode参数各种选项不同，对应不同的方式打开流，在实际应用中根据不同的情况选择。详情可参考man fopen。代码详见gist。 r 打开只读文件，文件必须存在，光标在文件开头。读从文件开头开始。 r+ 打开可读写文件，文件必须存在，光标在文件开头。读写均从文件开头开始。因此如果文件有内容，写操作会覆盖部分内容。 w 打开只写文件，文件不存在则创建，文件存在则清空内容，光标在文件开头。写从文件开头开始。 w+ 打开可读写文件，文件不存在则创建，文件存在则清空内容，光标在文件开头。读写均从文件开头开始。 a 打开只写文件，文件不存在则创建，文件存在则写入的内容在文件尾，光标在文件结尾。 a+ 打开可读写文件，文件不存在则创建。文件存在则读从文件开始读，写从文件结尾写。 fopen函数使用w或者a创建文件时，不能说明文件的访问权限位，系统有默认值0666，文件的最终访问权限为0666 &amp; ～umask。使用umask命令查看当前系统umask值，使用umask xxx命令设置。 除去标准输入、标准输出、标准出错三个流，最多可以打开1021个文件流。 参考文档：fopen中r+和w+的区别 fopen 的参数 w+, r+, a+ 关闭流 fclose通常和fopen配对使用。 不要多次使用fclose，一次即可。 在使用fclose时，将刷新缓冲区中输出的内容，丢弃输入的内容，释放自动分配的缓冲区。 如果程序正常结束，所有带未写缓冲数据的标准IO流将被刷新，打开的标准IO流将被关闭。 读写流每次一个字符的IO 输入：getc/fgetc/getchar 输出：putc/fputc/putchar getc的实现是函数宏，而fgetc实现是函数。getchar相当于getc(stdin)，getchar实现也是函数宏。 输入的三个函数到达文件结尾或者出错均返回EOF，需要使用ferror和feof区分。其返回值是int类型，因为包括0-255,-1。 putc的实现为函数宏，而fputc实现是函数。putchar相当于putc(c,stdout)，putchar实现也是函数宏。 不推荐使用getc。 每次一行的IO 输入：fgets/gets 输出：fputs/puts 输入函数成功返回buf,失败或到达文件尾返回NULL。 fgets从指定流读入。fgets一直读到’\n’结束，但是不能超过n-1个字符，因为自动加’\0’。如果字符长度超过n，下一次调用fgets会继续读该行。fgets会将’\n’包括在内，所以实践中常需要将最后一个字符改变一下。字符长度包括’\n’字符在内。 gets从标准输入读入，不包括’\n’,不推荐使用gets，因为没有指定长度，那么可能超过buf缓存的长度，造成越界，产生不可预料的后果。 输出的两个函数是输出第一个’\0’前的内容。 fputs将第一个’\0’前的内容输出到指定流。不一定每次输出一行，因为不要求在’\0’前面一定是’\n’。这是通常的情况，也有例外。 puts将第一个’\0’前的内容输出到标准输出，输出后会自带换行符。虽然puts不像gets一样不安全，但是也避免使用，以免需要记住它在最后又加上了’\n’。而使用fgets/fputs，在每行终止处需要自己加上’\n’。 二进制IO 输入：fread 输出：fwrite fread/fwrite常用于读写结构体数组到文件。以对象为单位读写，成功返回读写的对象数。 使用fgetc/fputc/fputs/fgets等都有一些限制，比如效率低，遇到’\0’停止等。而fread/fwrite可以读写整个结构。 size参数为一个对象的大小，nmemb参数是要读写的对象数，注意不能超过可读写的最大范围。 格式化IO 输入：scanf/fscanf/sscanf 输出：printf/fprintf/dprintf/sprintf/snprintf 输入函数scanf从标准输入读入，fscanf从指定流读入，sscanf从buf读入。scanf成功返回输入变量的个数。 输出函数printf将格式化数据输出到标准输出，fprintf将格式化数据输出到指定流，dprintf写至指定文件描述符，sprintf将格式化字符送入数组buf，snprintf是限制了buf长度的输出。 scanf可能产生垃圾字符，使用getchar清除。 sprintf和snprintf都会自动在结尾添加’\0’，有多种用途，详见sprintf用法详解。 流结束判断和错误判断 feof函数用于判断是否达到文件结尾。EOF文件结束标志位，其是值为-1的常量。 ferror函数用于判断流是否出错。 clearerr函数清除出错标志位，清除文件结束标志位。 注：出错时，可以进行错误打印，函数有strerror打印出错原因。perror打印出错原因和用户信息，自带换行。还可以自己定义出错打印信息。其中错误码errno在errno.h中定义，全局可见。 定位流 方式一：fseek/ftell/rewind 方式二：fgetpos/fsetpos fseek/ftell是假定文件位置存放在一个长整型中。ftell用于获取文件位置。fseek用于设定光标位置。rewind相当于fseek(stream,0L,SEEK_SET)。 fgetpos/fsetpos是将光标位置记录在fpos_t类型的对象中。fsetpos相当于fseek的whence为SEEK_SET。 文件大小可以使用fseek求得。 文件IO基本概念概述 文件IO是不带缓冲的IO。不带缓冲是指每个read和write都调用内核中的一个系统调用。 不带缓冲的IO操作不是ANSI C的组成部分，但是是POSIX和XPG3的组成部分。 通常可用的文件IO函数主要有五个：open/close/read/write/lseek。 在直接操作设备文件时多用文件IO，而不是普通文件。 文件描述符 文件IO是围绕文件描述符来操作的。所有打开的文件都由文件描述符引用。 文件描述符是一个非负整数。当打开一个现存文件或者创建一个新的文件，内核向进程返回一个文件描述符。此后的read,write操作都使用该文件描述符。 一个系统能够打开的文件个数是有限的，即文件描述符有一个上限值。运行ulimit -a可以看到open file上限值为1024。 POSIX规定幻数0、1、2应被换成符号常数STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，它们定义在unistd.h中。一个进程启动时，会打开这3个文件。 基于文件描述符的IO操作是实现某些IO操作的唯一途径，比如中低级文件操作函数、多路IO、TCP/IP套结字编程接口等。 函数介绍打开open/关闭close open函数返回的文件描述符是最小的未被使用的文件描述符。 open函数用于创建时，会使用第三个参数，指明文件的访问权限mode。 open函数第二个参数oflag指明文件的各选项，常用的有O_RDONLY、O_WRONLY、O_RDWR、O_APPEND、O_CREAT、O_EXCL、O_NONBLOCK、O_TRUNC。多个常量使用或运算构成，前三个常量互斥。 open可以打开设备文件，但是不能创建设备文件，设备文件必须使用mknod创建。 close用来关闭一个打开的文件。当进程终止时，也会由内核自动关闭。 使用示例：123456789101112131415161718192021222324int main(int argc, const char *argv[])&#123; int fd; fd = open(&quot;test1&quot;,O_RDWR | O_CREAT | O_EXCL,0777);//O_CREAT如果文件不存在则创建，并用第三个参数设置权限。O_EXCL测试文件是否存在 if(fd == -1) &#123; if(errno == EEXIST) //分析一下错误原因，如果存在直接打开并清空内容 &#123; printf(&quot;file already exist\n&quot;); if((fd = open(&quot;test1&quot;,O_RDWR | O_TRUNC)) &lt; 0)//O_TRUNC打开文件时先删除文件原有数据 &#123; perror(&quot;fail to open&quot;); return -1; &#125; &#125; else &#123; perror(&quot;fail to open&quot;); return -1; &#125; &#125; close(fd); return 0;&#125; 读read/写write read从一个已打开的可读文件中读取数据。 read一般要根据返回值进行判断。参数nbytes是期望读的字节数。成功返回实际读取的字节数，失败返回-1,达到文件末尾返回0。 读操作是从文件当前位移量处开始，成功返回前，位移量增加实际读取字节数。 write向一个已经打开的可写文件中写入数据。 write调用成功返回已写的字节数，失败返回-1。参数是期望写入的字节数，因此，需要循环将全部待写的数据写入文件。 write出错的原因可能是磁盘已满或者超过了一个给定进程文件长度限制。 写操作从文件当前偏移量处开始。如果打开时指定了O_APPEND则光标在结尾处。成功返回前，位移量增加实际写入的字节数。 定位文件lseek 每个打开的文件都有一个当前文件偏移量，用以度量从文件开始处计算的字节数。 通常读写都是从当前文件位移量处开始。如果打开时指定了O_APPEND参数，则每次从文件结尾开始写。一般情况，打开一个文件，偏移量为0。 lseek定位文件，成功返回新的文件位移量，失败返回-1。可以用来测文件大小。 lseek中如果whence是SEEK_CUR、SEEK_END，则offset可正可负。 lseek只对常规文件有效，对于socket、管道、FIFO等进行lseek操作失败。 lseek仅将当前文件的位移量记录在内核中，它并不引起任何IO操作。该偏移量用于下一次的读或写。 关于空洞：文件位移量可以设置大于文件当前长度，然后对文件的写操作会延长文件，从而形成空洞。位于文件中没有被写过的字节都将被读为0。空洞不会在磁盘上占有存储区。在多线程中有用，具体可另做讨论。 标准IO和文件IO的区别标准IO 由库函数提供的函数接口。 缓冲IO，高级磁盘IO，遵循ANSI C标准，头文件为&lt;stdio.h&gt;。 函数围绕流展开。 通常只用来访问普通文件。 优点：减少对硬件的频繁操作，有利于保护硬件，适应性更强。 缺点：缓存区的数据可能丢失，开发人员写的库源码有问题，影响程序员的操作。 文件IO 由系统调用提供的函数接口。 非缓冲IO，低级磁盘IO，遵循POSIX标准，头文件为&lt;unistd.h&gt;。 函数围绕文件描述符展开。 可以访问不同类型的文件，如普通文件，设备文件，管道文件，套接字文件等。 优点：数据实时写入硬件，代码稳定。 缺点：频繁操作硬件，不利于保护硬件，增加系统开销。 注意：文件IO使用的函数和标准IO是类似的，只是函数原型有所差异，可以对比记忆。 参考文档：标准IO与文件IO 的区别 总结 以何种方式打开文件，根据实际情况而定，主要考虑是否可读，是否可写，读写从什么位置开始。 fopen/fclose，open/close一定配对使用，如果未关闭，可能导致错误。 读和写在一起操作时，需要注意光标的位置，必要时用fseek或者lseek调整光标位置。 使用fgets后，需使用feof判断是否到达文件结尾。 使用fgets要注意可能需要将最后一个’\n’字符转换为’\0’。 使用fputs需要自己添加’\n’，才可以写入’\n’。 区别fwrite、fgets、fprintf，根据其不同的特点选用。 使用sprintf/snprintf会自动加上’\0’，注意buf长度。而strncpy却不能保证有’\0’。 对流的写操作，注意使用fflush刷新流。 实践中，对普通文件的读写通常用标准IO，对设备文件读写用文件IO，比如串口、GPIO、IIC、SPI都有使用open/close,read/write函数。 除了本篇所述的函数外，fcntl和ioctl函数在实践中也经常用到，在进程相关部分进行总结。例如IIC使用ioctl函数设置主从。fcntl设置文件状态使其非阻塞读写，设置异步IO所有权注册信号等。 除了对普通文件的IO进行打开、读、写操作外，还可以获得文件信息，修改文件属性，涉及函数stat,chmod,umask,chown等，详情参考《UNIX环境高级编程》第4章文件和目录，其中还包括了对目录的操作，涉及opendir,readdir,chdir等函数。此处省略。这些函数通常有对应的shell命令，可通过熟知的shell命令了解对应函数的用法。 在实践中曾经遇到读取字符串最后一个字符为’\n’,未处理’\n’，导致拼接的shell命令无法识别，将其转换为’\0’解决问题，详情参考gist。 个人观点 关于标准IO和文件IO的使用，在实践中是十分常用的，只需熟悉各个函数的特点，根据实际情况选用，不需记忆，多查看man手册。 读和写是两种基本的操作。很多情况下要抓住这个本质。比如通信中的发送和接收，比如查看就是读操作，控制就是写操作。比如GPIO中的配置通常是使用write函数完成写操作。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>标准IO</tag>
        <tag>文件IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--4查找与排序]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本篇文章主要总结查找和排序两种面试题中常出现的算法，这里只是简单叙述查找和排序的定义、算法衡量标准和算法分类。具体算法的原理和实现参见参考文档。 概述 算法本身有许多内容，可以单独展开讨论。就嵌入式Linux开发而言，这不是重点内容。因此这里只简单分析查找和排序算法。 分析查找和排序算法的原因是在面试题中可能涉及，因此在此做一个总结。 关于查找和排序的各种算法原理，网上介绍的资料有很多，在此不再赘述。 主要需要关注的方面总结为四个方面： 掌握每种算法的原理。 时间复杂度和空间复杂度分析。 各种算法的对比。 根据不同的应用场合选取合适的算法。 查找定义在记录表L=(R1,R2,……Rn)中，给定某个值k，在表中L确定key=k的记录的过程，称为查找。如果存在Ri的key=K，则查找成功，返回该记录在表中的序号i,否则返回查找失败。 衡量标准 使用平均查找长度（ASL）来衡量一个查找算法的优劣，ASL=∑Pi*Ci。 Pi表示查找到Ri的概率，Ci表示查找到Ri的次数。 通常认为查找到Ri的概率为等概率的。 分类 顺序查找：从前到后挨个查找。 二分查找：又称折半查找，需为有序列。查找一分为二，递归进行。 插值查找：二分查找的改进，mid的选择是自适应的，不是1/2。 斐波那契查找：二分查找的改进，利用斐波那契数确定mid位置。 树表查找：二叉树、2-3树、红黑树、B树、B+树。 分块查找：顺序查找的改进，分块有序，但块内可以无序。先查索引表，再查块内。 哈希查找：以空间换时间。主要关注两个问题：哈希函数如何构造，如何解决冲突。 参考文档：七大查找算法七大查找算法（附C语言代码实现） 排序定义将无序的记录调整为有序的序列。 衡量标准 稳定性：稳定是多个相同关键字的记录，排序后相对顺序不变。 最优、最差、平均时间复杂度。 分类 非线性比较类 冒泡排序：两两交换。改进算法为鸡尾酒排序。 快速排序：分区交换。 直接插入排序 二分插入排序：二分查找的思想。 希尔插入排序：以较大的步长移动数据，又称缩小增量排序。 选择排序 堆排序 归并排序 线性非比较类 计数排序 基数排序 桶排序 注：这里所谓的非线性和线性是指时间复杂度。 参考文档：常用排序算法总结十种常见排序算法从头说12种排序算法：原理、图解、动画视频演示、代码以及笔试面试题目中的应用]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>查找</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--3树和图]]></title>
    <url>%2F2018%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3%E6%A0%91%E5%92%8C%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[本篇总结两种非线性数据结构：树和图。树的内容中主要讨论二叉树的性质、存储和四种遍历方法。图主要讨论基本概念，邻接矩阵表示法的存储结构和广度优先、深度优先两种遍历算法。树和图在实践项目使用中较少，了解基本概念即可。 树基本概念 树是n个节点的有限集合，满足两个条件：(1)有且仅有一个特定的称为根的节点。(2)其余的节点分为m个互不相交的有限集合，其中每一个集合又是一棵树，称为根的子树。 节点的度数：节点的子树个数。 树的度数：节点中的最大度数。 节点的层数：父节点层数+1，根节点层数为1。 树的高度（深度）：节点层数的最大值。 树的逻辑结构 树中任何节点都可以有零个或多个直接后继节点，至多一个直接前驱节点。 根节点没有直接前驱节点。 叶子节点没有直接后继节点。 二叉树定义 二叉树是n个节点的有限集合，它要么是n=0为空集，要么是由一个根节点以及两颗互不相交、分别称为左子树和右子树的二叉树组成。 二叉树严格区分左孩子和右孩子，即使只有一个子节点。 性质 第i层上的节点最多2^(i-1)个。 高度为k的二叉树最多有2^k-1个节点。 树叶的数目比度为2的节点数目多1。 满二叉树：高度为k时，有2^k-1个节点。 完全二叉树：只有最下面两层有度数小于2的节点，且最下面一层的叶节点集中在最左边若干位置。深度为⌊log2n+1⌋或者⌈log2(n+1)⌉。 顺序存储结构 完全二叉树可以按照从上到下、从左到右的顺序为每一个节点编号，然后用一维数组存储，就是完全二叉树的顺序存储。 一般二叉树可以添加虚节点，成为完全二叉树，然后按照完全二叉树的方式进行顺序存储,如下图所示。 特点是：如果是完全二叉树，则存储结构既简单又节省空间。如果是一般二叉树，则存在空间浪费的情况。 注：关于顺序存储的具体结构体实现此处省略，参见参考文档。 参考文档：二叉树的存储结构树的三种存储结构二叉树的顺序存储 链式存储结构二叉树的链式存储，每个节点包括数据域存储数据，指针域存储左孩子和右孩子指针，如图所示。 其实现的结构体如下：123456typedef int data_t;//定义数据类型typedef struct node_t&#123; //定义二叉树内部结点 data_t data; //数据域 struct node_t *lchild,*rchild; //指向左孩子和右孩子的指针&#125;bitree_t;bitree_t *root; //根节点 数据运算：遍历 对于二叉树的数据运算有建立空的二叉树、求根节点、求双亲结点、求左右孩子结点、插入左孩子或右孩子、删除左孩子或右孩子、遍历等，这里只谈遍历的几种方法。 遍历是指沿着某条搜索路径周游二叉树，对树中每个节点访问有且仅有一次。注意，遍历是任何类型均有的操作，对于线性结构，因为只有一条搜索路径因此不做讨论。但是二叉树有两个直接后继，因此有不同的搜索路径。 根据根的访问次序，分为三种：前序遍历(根左右)、中序遍历(左根右)、后序遍历(左右根)。此外还有一种按层次遍历。 遍历操作是将非线性结构线性化的过程。许多其他操作都是在此基础上进行扩展。 说明： 先序、中序、后序遍历三种算法的实现十分简单，理解原理即可，使用递归的方式完成，这是由二叉树的递归定义决定的。 层次需要利用链式队列的入队和出队，这里队列的数据类型是二叉树指针，当出队时返回指针，就可以知道左孩子和右孩子。 关于先序、中序、后序三种遍历方式，面试题中考题有两种：(a)根据二叉树的结构图，求出某一种遍历顺序。(b)根据两种遍历方式求第三种遍历方式和二叉树结构图。需要注意的是必须已知中序遍历。先序和后序不能唯一确定二叉树。 由遍历顺序确定二叉树结构图时，注意各种遍历方法的特点，例如先序是根左右，中序是左根右，后序是左右根，因此先序序列中第一个结点是根节点，然后在中序中找到根节点，则根节点以左为左子树，根节点以右为右子树。 在确定某一种遍历顺序时，要记住一条原则：如果遇到没有遍历的结点，当做根节点处理。 扩展：求二叉树的深度 求二叉树的深度也是基本的运算，可以采用后序遍历的思想完成。 先求左右子树的高度，再求根的高度，根的高度为左子树高度加1和右子树高度加1中的较大者。参见求二叉树的高度。 图基本概念 图是一种比线性表和树更为复杂的数据结构。树是图的特例，有向无环图。 图的形式化描述：G=(V,R)。V是图中元素顶点的集合，R是顶点之间的关系集合。 基本术语包括：有向图、无向图、路径、网、顶点的度、连通性等，此处省略。 图的逻辑结构中结点之间是多对多的关系，根据是否有向、是否有权值、是否连通等特点会有不同的结构，此处省略。 存储结构 图的存储结构不能再使用顺序存储和链式存储表征结点与结点之间的关系。这里图有五种存储结构：邻接矩阵、邻接表、十字链表、邻接多重表、边集数组等。这里只谈邻接矩阵方法。 邻接矩阵表示法(数组表示法)即用二维数组表示图，邻接矩阵是一个方阵，行和列都表示顶点，其值表示为两个顶点之间的关系。如果有关系则为1,如果没有关系则为0。 对于在图的关系上附加一个权值的，称为网。网的邻接矩阵则是，如果有关系则为w,如果没关系则为无穷大。 邻接矩阵方法的结构体实现如下： 1234567#define MAXN 64 //最大顶点数typedef char vtype; //定义顶点数据类型typedef int adjtype; //邻接矩阵中的元素typedef struct&#123; vtype V[MAXN];//顶点存储空间 adjtypde A[MAXN][MAXN];//邻接矩阵&#125;mgraph; 参考文档图的五种存储结构 数据运算：遍历 图的数据运算包括：建立一个图、定位结点位置、取第i顶点、取第一邻接点、插入顶点、插入弧或边、删除顶点、删除弧或边、遍历等，这里只谈遍历。 图的遍历有两种：深度优先遍历，类似于树的先序遍历。广度优先遍历，类似于树的层次遍历。 说明： 这里是以邻接矩阵表示法构成的无向图，讨论深度优先遍历和广度优先遍历。 深度优先遍历使用递归完成，广度优先遍历使用链式队列入队和出队完成。 主要是理解算法原理。 深度优先搜索和广度优先搜索有各自适合的应用场景，需要时可做深入分析，参见什么时候用DFS，什么时候用BFS?(DFS和BFS的特点和异同)。 个人观点 关于树和图的基本概念参见数据结构自考网。 对于树和图的掌握：了解基本概念，掌握树和图的遍历方法。在实践项目中很少使用树和图这两种数据结构，一般在面试题中考察。 对于使用递归的算法，编程实现上是非常简单的，只需要想清楚何时递归，退出条件是什么等问题即可。例如链表的逆序输出、二叉树的遍历，二叉树的高度求解、图的DFS等都可以使用递归的方法。 至此，总结了线性表、栈、队列、树、图几种数据结构及其基本操作，如数据结构系列文章第一篇所述，可将这些数据结构的操作代码形成模板，当做工具使用，详见GitHub。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>树</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--2栈和队列]]></title>
    <url>%2F2018%2F01%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本篇介绍了两种特殊的线性表：栈和队列。栈的特点是先进后出，队列的特点是先进先出。同样按照逻辑结构、存储结构、数据运算三个方面展开进行分析。最后还列举了一些栈和队列在实践中的应用。 栈基本概念 栈是限制在一端进行插入和删除操作的线性表，也称堆栈。允许操作的一端称为栈顶，固定的一端称为栈底。特点是先进后出。 同样有两种存储方式，顺序存储和链式存储，其结构如图所示。 顺序栈它是顺序表的一种，具有顺序表同样的存储结构，由一维数组表示，配合数组下标表示栈顶位置top，完成各种操作。 结构体表示顺序栈的实现结构体如下： 123456789101112131415方式一：#define N 100 //定义顺序栈的最大长度typedef int data_t; //定义存储数据的类型，可以替换为其他,如结构体typedef struct&#123; data_t data[N]; //栈的存储空间 int top;//当前栈顶下标&#125;seqstack,*seqstack_t;//顺序栈类型方式二：typedef int data_t;//定义栈中数据元素的数据类型typedef struct&#123; data_t *data;//用指针指向栈的存储空间 int maxlen;//栈的最大元素个数 int top;//栈顶位置&#125;seqstack,*seqstack_t;//顺序栈类型 说明： 顺序栈和线性表的顺序存储结构体一样，只是将last成员改为top成员。下标为0是栈底，下标为last是栈顶。 方式二的写法，未预先指定数组大小，而是定义数据指针和栈的最大大小，在创建栈时指定栈的最大长度，然后malloc出最大长度个空间来存储。 数据运算顺序栈的基本数据运算和顺序表类似，有： 创建空的顺序栈：s-&gt;top=-1 清空顺序栈 销毁顺序栈 判断顺序栈是否为空 判断顺序栈是否为满 求顺序栈长 入栈：相当于在last+1位置插入 出栈：相当于删除last位置元素 取栈顶元素：相当于查询last位置的元素 链式栈链式栈即为链式存储的栈。其中插入和删除操作都在链表头进行，链表尾就是栈底，栈顶指针就是头指针。 结构体表示链式栈的实现结构体如下：12345typedef int data_t;//定义栈中数据元素数据类型typedef struct node_t&#123; data_t data;//数据域 struct node_t *next;//指针域&#125;linknode，*linknode_t;//链栈类型定义 说明：链式栈的结构和单向不循环链表的结点结构一样，无需改动。 数据运算链式栈的基本数据运算和链表类似，有： 创建空的链式栈 清空链式栈 销毁链式栈 判断链式栈是否为空 求链式栈长 入栈：相当于头插法 出栈：相当于头删法 取栈顶元素：相当于查询第一个数据元素 队列基本概念 队列是限制在两端进行插入和删除操作的线性表，允许在队尾进行插入操作，允许在队头进行删除操作。特点是先进先出。 同样有两种存储方式，顺序存储和链式存储，其结构如图所示。 顺序队列它是顺序表的一种，具有顺序表同样的存储结构，由一维数组定义，配合数组下标表示队头位置和队尾位置完成各种操作。 结构体表示顺序队列的实现结构体如下：123456typedef int data_t;//定义队列数据元素的类型#define N 64//定义队列的容量typedef struct&#123; data_t data[N];//用数组作为队列的存储空间 int front,rear;//队头和队尾位置&#125;sequeue，*sequeue_t; //顺序队列类型定义 说明：顺序队列的结构和线性表顺序存储的结构类似，只是last位置变为front和rear位置。 循环队列 顺序队列和线性表的顺序存储操作一样，只是在队尾插入（下标为last+1），在队头删除（下标为0）。 和线性表一样，如果在队头删除时，后面的元素需要挨个向前移动，因此效率很低。 为了解决这个问题，以调整下标位置代替元素移动，不限制队列的元素一定存储在数组的前n个单元。因此删除时，不将后面的元素向前移动，而是将队头向后移动。 但是还存在一个问题，插入时在队尾插入，如果满了就不能插入了，但是前面位置还有空闲空间，称为假溢出。 因此将队头和队尾相连，构成循环队列。 定义：队列头尾相接的顺序存储结构，称为循环队列。 说明： 如果将队头和队尾相连，那么队列满和队列空都是front==rear。为了区分队列满和队列空，因此满队元素个数比数组元素个数少一个。 因此有两种方式：(a)front指向队头元素的前一个位置，rear指向队尾元素所在位置。(b)front指向队头元素的位置，rear指向队尾元素的下一个位置。 数据运算循环队列的基本数据运算和顺序表类似，有： 创建空的循环队列：sq-&gt;front=sq-&gt;rear=0 清空循环队列 销毁循环队列 判断循环队列是否空：sq-&gt;front==sq-&gt;rear 判断循环队列是否满：(sq-&gt;rear+1)%N=sq-&gt;front 求循环队列长度：(sq-&gt;rear-sq-&gt;front+N)%N 入队：队尾下标移动，sq-&gt;rear=(sq-&gt;rear+1)%N 出队：队头下标移动，sq-&gt;front=(sq-&gt;front+1)%N 链式队列链式队列即为链式存储的队列。队头指针指向头结点，队尾指针指向最后一个结点。 结构体表示链式队列的实现结构体如下： 123456789typedef int data_t; //定义链队列中数据元素的数据类型typedef struct node&#123; data_t data;//结点数据域 struct node *next;//结点指针域&#125;linknode,*linknode_t;//结点类型定义typedef struct&#123; linknode_t front,rear;//链队列指针&#125;linkqueue,*linkqueue_t;//链队列类型定义 说明： 链式队列的结点结构和单向不循环链表的结点结构一样，无需改动。 链式队列还需要用两个指针来定义。其中front指针相当于单向不循环链表的头指针，相比之下，多了一个队尾指针。 数据运算链式队列的基本数据运算和链表类似，有： 创建空的链式队列：需要先申请结点空间，再申请队列指针的空间。 清空链式队列：挨个数据出队。 销毁链式队列：先清空队列，置front、rear指针为NULL，再释放队列指针。 判断链式队列是否空 求链式队列长度 入队：在队尾插入，使用rear指针操作。 出队：在队头删除，使用front指针操作。 说明：出队有两种方式：(a)删除头结点空间;(b)删除出队元素的空间，如果这种方式，在删除最后一个元素时，需要将rear指针赋值为front指针，否则rear成为野指针。 实例分析栈和队列两种数据结构在实际项目中使用较多，这里简单举几个例子。 四则运算表达式求值 需要使用栈完成，涉及两个栈，一个用来存放运算符，一个用来存放操作数。 具体的算法涉及如何将中缀表达式转化为后缀表达式，以及如何用后缀表达式求值，详情参见栈的应用：四则运算表达式求值。 判断进栈顺序或者出栈顺序的合理性。 一般为面试选择题。通常是已知入栈顺序，求可能的出栈顺序。 思路是按照出栈顺序，判断目前栈顶的元素是否与之相等，如果相等则出栈，如果不相等，则继续入栈。详情参见面试题之判断栈的入栈和出栈序列的合法性。 扩展问题是已知某种入栈顺序，求所有可能的出栈顺序。详情参见所有可能的出栈序列问题及卡塔兰数的应用。 两个堆栈实现一个队列 入队，直接压栈到stack1。 出队，判断stack2是否为空，若为空则将stack1中所有元素全部出栈压入stack2,如果不为空直接弹出stack2中数据。（除了连续进栈出栈操作，也适合不连续入栈出栈的情况）。详情参见两个栈实现一个队列。 两个队列实现一个堆栈 入栈，直接入队queue1。 出栈，将queue1中除最后一个元素外的所有元素出队，再入队queue2，queue1中最后一个元素出队即可。下一个元素出栈，以此类推，再将queue2中元素除最后一个出队并入队到queue1。详情参见栈和队列高频面试题精讲_七月算法出品。 两栈共享存储空间 两栈共享存储空间适合于两个栈的数据具有相同数据类型，且空间需求为相反关系的情况，使用顺序栈实现。 入栈就是向中间靠拢，出栈就是向两边移动。具体入栈和出栈的操作参见两栈共享空间。 球钟问题 利用球的移动来记录时间的简单装置，包含一个球队列和三个指示器(分钟/五分钟/小时)。分钟指示器最多装4个球，第五个向前进一位即进入五分钟指示器，同时前4个球按照进入指示器相反的顺序加入球队列的队尾。同理，五分钟指示器最多容纳11个球，小时指示器可容纳11个球。 假设初始有27个球，问经过多久球队列回复到原来的顺序。 该问题涉及到队列和栈的使用，具体代码参见球钟问题或球钟问题的解决–栈和队列 。 队列在实际项目中的应用多为通信发送消息和接收消息的处理或者多任务分时服务系统。可能与之相关还有一些知识点，例如消息队列等，后续结合多线程、进程间通信等内容再做深入讨论。 个人观点 只需要理解线性表的存储模型，再结合栈和队列的特点，做相应的改动即可。另外数据存储模型中即结构体，只是规定了必须的成员，其他的成员可以根据实际情况进行增加。 实例分析中主要掌握利用某种数据结构的算法思路，这里未给出具体代码实现，后续有需求再做深入探究。 到此，学习了线性表的顺序存储和链式存储，以及两种特殊的线性表：栈和队列。各种数据结构都有各自的特点，选择时应结合实际需求进行合理的选择。参见常见数据结构应用场景。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用环形队列处理定时任务]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%B7%A7%E7%94%A8%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[使用QQ聊天的用户会有在线、离开、离线等状态，正常聊天时对应在线状态，退出登录时对应离线状态，用户隔一段时间(假设5分钟)没有聊天等行为会自动变成离开状态。如何实现用户离开状态的变更，是今天讨论的主题。 设计之初思路 用户每次发消息时，新增or更新对应的活跃时间Map(uid,t1)； 启动一个Timer，一直轮询Map，如果用户对应的活跃时间超过间隔，设置为离线。 优点只需要一个Map和一个Timer，实现简单 缺点不确定用户准确的离线时间，每次需要轮询Map中所有用户，大部分是无效判断 设计改进-定时处理改进用户每次发消息时，启动or更新一个Timer并且5min后执行，设置为离线。 优点定时处理，不再无效轮询 缺点启动大量Timer浪费资源 设计改进-批量处理改进 创建一个5*60个index的环形队列(数组)，每个index处存放将同一时刻即将离线的用户Set(uid)； 创建一个指针Pointer，每秒钟在环形队列上移动(0&gt;1&gt;2&gt;…n&gt;0&gt;1…)，并记录当前位置NowIndex； 用户第一次发消息时，将用户存在NowIndex-1的位置，这样Poniter转了一圈再次到达这个位置时，刚好是用户离线的时刻； 用户再次发送消息时，需要将原来index上的记录删除，因此还需要记录用户所在index信息Map(uid,index)； 启动一个Timer，每秒查看Poniter指定的index，设置这个index上的所有用户为离线。 优点只需1个Timer+1个Map，Timer每1s执行一次，节省资源；定时处理，批量处理，提高效率；更优雅 缺点每个环节需要执行的步骤增多；更复杂 代码实现经过两次改进，用代码实现改进后的方案如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.text.SimpleDateFormat;import java.util.*;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.atomic.AtomicInteger;public class UserStateManage &#123; private static UserStateManage instance = new UserStateManage(); public static UserStateManage getInstance() &#123; return instance; &#125; /** * 指针Pointer,每秒移动一个位置 */ private AtomicInteger pointer = new AtomicInteger(0); /** * 超时时间,每秒扫一次时,长度刚好对应超时时间 */ private int WHEEL_NUMBER = 5; /** * 环形队列,每秒扫一次时,长度刚好对应超时时间 */ private Set&lt;Long&gt;[] userWheel = new Set[WHEEL_NUMBER]; /** * 记录用户id所在环形队列的位置 */ private Map&lt;Long, Integer&gt; userPositionMap = new ConcurrentHashMap&lt;Long, Integer&gt;(); /** * 定时Timer和TimerTask */ private Timer timer = new Timer(); private TimerTask task = new TimerTask() &#123; @Override public void run() &#123; //1.获取当前位置所有用户,设置为离线 final int nowPosition = pointer.get(); for (long userId : userWheel[nowPosition]) &#123; setOffline(userId); &#125; //2.清空已处理过的位置上的用户 userWheel[nowPosition].clear(); //3.Pointer继续扫描下一个位置 if (pointer.incrementAndGet() &gt;= WHEEL_NUMBER) &#123; pointer.set(0); &#125; &#125; &#125;; /** * 初始化 */ private UserStateManage() &#123; initUserWheel(); startTimer(); &#125; private void initUserWheel() &#123; for (int i = 0; i &lt; userWheel.length; i++) &#123; userWheel[i] = new HashSet&lt;Long&gt;(); &#125; &#125; private void startTimer() &#123; timer.scheduleAtFixedRate(task, new Date(), 1000); &#125; public void setActivate(long userId) &#123; //1.获取用户之前在队列中的位置并移除 Integer lastPosition = userPositionMap.get(userId); if (lastPosition != null &amp;&amp; lastPosition &gt;= 0 &amp;&amp; lastPosition &lt; WHEEL_NUMBER) &#123; userWheel[lastPosition].remove(userId); &#125; //2.在新位置插入用户 int newPosition = (pointer.get() + WHEEL_NUMBER - 1) % WHEEL_NUMBER; userWheel[newPosition].add(userId); //3.在Map中更新用户所在的队列位置 userPositionMap.put(userId, newPosition); System.out.println(String.format("set %s active , current time : %s", userId, getNowTime())); &#125; private void setOffline(long userId) &#123; //设置用户离线,并在Map中清除用户和位置信息 userPositionMap.remove(userId); System.out.println(String.format("set %s offline , current time : %s", userId, getNowTime())); &#125; private String getNowTime() &#123; return new SimpleDateFormat("HH:mm:ss").format(new Date()); &#125;&#125; 测试代码如下12345678910111213141516171819202122import java.util.Random;public class Main &#123; public static void main(String[] args) throws Exception &#123; Random random = new Random(); long[] userIds = new long[]&#123;10001, 10002, 10003, 10004, 10005&#125;; UserStateManage manage = UserStateManage.getInstance(); /** * 模拟用户发送消息,每隔2s让一个人发送一条,观察结果 */ for (int i = 0; i &lt; 100; i++) &#123; manage.setActivate(userIds[random.nextInt(userIds.length)]); Thread.sleep(2000); &#125; &#125;&#125; 输出结果如下12345678910111213141516171819set 10001 active , current time : 20:41:31set 10003 active , current time : 20:41:33set 10001 offline , current time : 20:41:35set 10005 active , current time : 20:41:35set 10005 active , current time : 20:41:37set 10003 offline , current time : 20:41:38set 10002 active , current time : 20:41:39set 10003 active , current time : 20:41:41set 10005 offline , current time : 20:41:42set 10003 active , current time : 20:41:43set 10002 offline , current time : 20:41:44set 10001 active , current time : 20:41:45set 10005 active , current time : 20:41:47set 10003 offline , current time : 20:41:48set 10005 active , current time : 20:41:49set 10001 offline , current time : 20:41:50set 10003 active , current time : 20:41:51set 10001 active , current time : 20:41:53set 10005 offline , current time : 20:41:54 总结工作原理是参考了Netty中的HashedWheelTimer，定时超时等场景都可以使用。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>环形队列</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--1线性表]]></title>
    <url>%2F2018%2F01%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[从本篇开始，分四篇总结数据结构和算法的相关内容。数据结构方面，主要总结线性表的顺序存储和链式存储，应重点掌握。栈和队列是两种特殊的线性表，理解其特殊性。树和图目前只做简单了解，后续有需求再做深入研究。存储方式中的索引存储和散列存储仅作了解。算法方面，这里并不展开分析，只总结面试中常出现的查找算法和排序算法。 数据结构的基本概念定义 数据结构是研究非数值性程序设计中计算机操作的对象（数据）及其相互关系和运算的学科。 更详细的解释为：按照某种逻辑关系组织起来的一批数据，应用计算机语言，按照一定的存取方式将其存储到存储器中，并为这些数据定义运算集合。 数据结构的三个方面当谈到数据结构时，我们主要关心它的三个方面：逻辑结构、存储结构和运算。后面具体分析的某种数据结构也按照该思路展开。 逻辑结构 数据之间的相互关系。 按照每个元素可能具有的直接前驱数和直接后继数分类，可以分为线性结构和非线性结构。 线性结构又包括线性表、栈、队列等。非线性结构包括树、图等。 线性结构中的元素是一对一的关系，树形结构中的元素是一对多的关系，图状结构中的元素是多对多的关系。 存储结构 逻辑结构在计算机中具体的实现方法。 分为顺序存储、链式存储、索引存储、散列存储等。 顺序存储：把数据存放在地址连续的存储单元里，数据间的逻辑关系和存储关系是一致的。 链式存储：借助元素在存储器中的指针表示元素间的逻辑关系，可以存放于连续的空间，也可以存放于不连续的空间。 索引存储：在存储数据的同时还存储一张索引表，通过索引表中的索引项定位结点，可以提高查询速度。 散列存储：根据元素的特殊字段（关键字key）计算数据元素的存放地址，数据元素按地址存放，可以提高查询效率。 参考文档：数据的四种基本存储方法 数据运算 对数据的操作。 包括增、删、改、查、排序、合并等。 顺序存储和链式存储的对比 顺序存储 优点：存储密度高；按元素序号随机存取。 缺点：插入、删除的时间复杂度差；需要预先分配存储空间。 链式存储 优点：插入、删除方便；动态申请空间。 缺点：存储密度低，需要额外为指针分配空间；只能顺序存取。 选择时的考虑 算法设计的要求通常是时间效率高、存储量低。 是否能预先确定存储空间的大小，能则使用顺序存储，否则使用链式存储。 频繁进行何种运算，多查询则使用顺序存储，多插入删除则使用链式存储。 注：因为顺序存储是用数组实现，因此也有数组和链表对比的提法，内容见上。另外，数组是在栈上，而链表是在堆上，因此其区别也涉及内存中堆和栈的区别。 参考文档：顺序存储结构与链式存储结构的比较 线性表线性表是包含若干数据元素的线性序列。 特征 对于表头，无前驱。 对于表尾，无后继。 其他每个元素有且仅有一个直接前驱和一个直接后继。 逻辑结构见图，是一种线性结构。 存储结构顺序存储线性表的顺序存储结构，用一维数组表示。如图所示。 结构体表示顺序存储的实现结构体如下：123456#define N 100 //定义顺序表的最大长度typedef int data_t; //定义存储数据的类型，可以替换为其他,如结构体typedef struct&#123; data_t data[N]; //顺序表的存储空间 int last;//当前表尾下标&#125;seqlist,*seqlist_t;//顺序表类型 数据运算顺序存储结构的线性表的基本数据运算有： 建立空的顺序表 清空顺序表 销毁顺序表 判断顺序表是否空 判断顺序表是否满 求顺序表长度 将数据插入顺序表某一位置 删除顺序表某一位置的数据 查询顺序表中某一位置上的数据 查询顺序表中某一数据的位置 修改顺序表中某一位置上的数据 修改顺序表中某一数据 顺序表的遍历 说明： 表尾下标从-1开始，当有元素插入时，下标加1，正好和数据下标对应。 销毁顺序表时，在函数内置指针为NULL，并不能影响函数外的实参，指针还可以访问堆上的内容，因此需要在函数外置NULL。 顺序表的插入和删除操作，需要大片移动数据。 顺序表的查找是按下标随机查找。 函数传参为指针，函数内改变指针的值，函数外并不会有改变，属于按值传参。比如在函数内头指针位置的改变不会影响主函数中头指针的值。 其余操作均是在此基础上变化，比如合并、拆分、复制、排序等。 链式存储线性表的链式存储，即通常说的链表。链表的结构是动态的，通过结点的指针域确定结点间的关系。结点和链表结构如图所示。其中结点包括data域，存放数据元素,还包括next域，它是一个指针，指向该元素的直接后继所在的结点位置。 结构体表示链式存储的实现结构体如下：12345typedef int data_t;typedef struct node&#123; data_t data;//结点的数据域 struct node *next;//结点的后继指针域&#125;linknode,*linknode_t; 数据运算链式存储结构的线性表的基本数据运算有： 创建空的链表 清空链表 销毁链表 判断链表是否空 求链表长度 头插 头删 查询链表中某个元素 修改链表中某个元素 链表的遍历 将数据插入链表某一位置 删除链表中的某个元素 链表倒置 说明： 链表的结构是动态生成的，不需要判断是否满。 清空链表和清空顺序表不一样，不能使用h-&gt;next=NULL,因为链表中的结点均为动态申请，因此需要挨个释放空间，即删除。 销毁链表则需先清空链表，再释放头结点。 链表的头结点比较好操作，因此常使用头插法和头删法。 链表中结点有一个指针域，因此操作中涉及指针的连接、断开等问题，可使用画图辅助理解。 链表倒置最好的思路：挨个指向数据，使用头插法的思路调整指针指向即可。无需malloc和free函数。 单向循环链表以上所述链表为单向不循环链表，简称为单链表。将单链表首尾相连，就构成了单向循环链表，如图所示。单向循环链表可以使得从链表当中一个结点出发，访问到链表的全部结点。 单向循环链表的运算和单链表比较： 创建空链表时，填充头结点的指针域为h-&gt;next=h。 判断链表是否为空：h-&gt;next==h。 插入与删除和单链表操作一样。 判断指针是否到达表尾：p-&gt;next==h。 对于在表尾频繁操作时，可以求得表尾指针，再进行操作，而不必使用头指针遍历到表尾。例如用尾指针实现两个单向循环链表的连接。 双向不循环链表单链表存在两个问题： 在查找直接前驱时时间复杂度依赖于链表的长度，耗时较多。 如果其中有一个指针被破坏，则整个链表脱节。 因此引入双向不循环链表，其结构如图所示。双向是指增加一个指针指向直接前驱。双向链表是以空间换时间的思想，解决单链表存在的问题。 其实现的结构体为：12345678typedef int data_t;typedef struct dnode&#123; data_t data; struct dnode *prior,*next;&#125;dlinknode,*dlinknode_t;对称性：(p-&gt;prior)-&gt;next=p=(p-&gt;next)-&gt;prior 双向不循环链表的运算和单链表比较： 创建空链表时，多一个指针。 求链表长度、查找元素、获取元素位置等和单链表一样。 查找或者访问链表元素，可以正向也可以反向。 将数据插入链表某一位置时，需要处理四个指针。 删除链表中的某个元素时，需要处理两个指针。 说明： 改变指针关系时，要注意先后顺序，如果写反了，可能就不能操作了，比如丢失了某个指针。解决思路：先连上新增的，这样原来的指针可以使用。然后再断开需要断开的指针。如果先删除需要删除的指针，那么可能需要新连接的指针就不知道连到哪里。 以上介绍了单向循环链表和双向不循环链表。其中循环是指链表首尾相连，双向是指一个指针指向后继，一个指针指向前驱。因此，根据这两个特征，可以组合为四种形式的链表。使用场合应根据各自的特点来区分。其异同点如图所示。 例如Linux内核中的链表。头文件为include/linux/list.h。其中有一个list_head结构体。list_head有两个指针，一个是next,一个是prev，通常组织为双向循环链表。注意：在linux内核链表中，不会在链表结构中包含数据，而是在数据结构中包含链表。因为链表数据类型差别很大，如果在每一个链表结构中定义数据类型，则不利于抽象为公共模板。 实例分析员工信息系统的增删改查 员工信息系统涉及每个员工的许多信息，因此通常用结构体表示，即数据是构造数据类型。 考虑到总体员工数量不确定，可以采用链式存储结构，而非顺序存储结构。 员工信息的结构体可以表示为方式一，包含指向下一个结点的指针。那么增删改查函数需要根据实际需求编写。 也可以采用方式二，员工信息的结构体单独定义，链表结构体单独定义，那么增删改查可以使用模板函数，获得结构体或者结构体指针后，再进一步访问结构体成员。 结构体表示：1234567891011121314151617181920212223242526方式一：struct node&#123; int id; char name[10]; int age; bool sex; float salary; struct node *next;&#125;;方式二：typedef struct staff&#123; int id; char name[10]; int age; bool sex; float salary;&#125;staff,*staff_t;typedef staff_t datatype;//或者typedef staff datatype;struct node&#123; datatype data; struct node *next;&#125;; 参考文档：C语言中怎样用链表保存结构体数据（动态数据结构） 视频诊断项目中顺序表的使用 视频诊断项目其中一个需求是诊断摄像头的网络通断情况。采用的思路是：保存一份网络内正常情况下所有摄像头IP的顺序表La，实时的按一定频率扫描网络，得到实时扫描到的IP顺序表Lb,对La、Lb两个顺序表进行对比合并等操作，判定摄像头网络故障。 主要涉及创建顺序表、插入数据、查找数据、顺序表遍历、两顺序表合并等操作。 注意这里入表的数据类型为char *型，因此查找操作不能使用“=”运算符判断是否找到，而需使用strcmp函数。 由于项目中使用顺序表是为了比较多个IP字符串，因此需要按照功能封装函数，函数内可能包含了顺序表的操作。此时需要注意，如果形参为顺序表指针，那么在函数内使用顺序表指针进行操作后，并不会影响函数外的顺序表指针。解决方案是：要么函数返回值返回顺序表指针，要么形参传递顺序表指针的地址。 如下的代码，运行时将在main.c出现段错误，原因即是在函数内的La的值并不会影响main.c中La的值，所以再通过La访问数据时，由于La=NULL，所以出现段错误。 1234567891011121314151617181920212223242526272829303132333435363738info_management.cint cameraIP_enter_sqlist(sqlist * La,uint8_t (*IPlist)[16],int count)&#123; int i; if((La = list_create()) == NULL) &#123; printf(&quot;fail to create list La\n&quot;); return -1; &#125; for(i=0;i&lt;count;i++) &#123; list_insert(La,IPlist[i]); &#125; list_show(La); return 0; &#125;main.cint main(int argc,char *argv[])&#123; …… cameraIP_enter_sqlist(La,IPlist,camera_num); for(i=0;i&lt;=La-&gt;last;i++) &#123; if(strcmp(La-&gt;data[i],localIP)!=0) &#123; strcat(scan_target,La-&gt;data[i]); strcat(scan_target,&quot; &quot;); &#125; &#125;&#125; 仓储物联项目中链表的使用 该项目是由FS4412、M0(NXP LPC11C14)、PC等组成的系统，各自的作用是PC为核心服务器端，FS4412为前端数据中心，M0为远程监控终端。 主要是实现M0采集环境参数，物品参数，通过zigbee网络将信息发送给FS4412，同时在FS4412上构建嵌入式web服务器，使用户在PC机上对环境信息货物信息进行监控。 这是一个多线程的项目，涉及数据库线程、接收M0数据线程、M0数据分析线程、M0控制命令发送线程、短信模块控制线程、蜂鸣器控制线程、摄像头控制线程、处理消息队列请求线程、更新共享内存实时数据线程等。具体在多线程一节和项目实践分析中详细叙述。 其中很多地方使用了数据结构。比如：数据库线程中，创建一个用于存储对数据库操作（增删改查）的链表。在while(1)循环中判断链表是否为空，如果空则跳出，如果不为空，则取出链表头的内容进行解析，完成相应的数据库操作并释放结点，如此循环。接收M0数据线程中，从ttyUSB0设备结点中读取数据，判断包头是否正确，判断是货物还是环境信息，并插入数据缓存链表中。M0数据分析线程中，从数据缓存链表中取表头数据，如果是环境信息，将数据加入到数据库链表中，并激活更新共享内存实时数据线程。如果是货物信息，也将其加入到数据库链表中。 相关源代码详见gist。 开源项目中的数据结构使用mosquitto源码对某一个topic的所有订阅者被组织成一个双向链表。每一个结点保存一个订阅者。实现结构体如下：123456struct _mosquitto_subleaf &#123; struct _mosquitto_subleaf *prev; struct _mosquitto_subleaf *next; struct mosquitto *context; int qos;&#125;; 用于保存订阅树的结点，包括叶子结点和中间结点。采用孩子-兄弟链表法进行存储。实现结构体如下：12345678struct _mosquitto_subhier &#123; struct _mosquitto_subhier *parent; struct _mosquitto_subhier *children; struct _mosquitto_subhier *next; struct _mosquitto_subleaf *subs; char *topic; struct mosquitto_msg_store *retained;&#125;; 参考文档：mosquitto 源码分析 （二）订阅树的搭建mosquitto 源码分析 （一）核心数据结构 cJSON源码cJSON结构体是一个双向链表。对节点的操作包括增删改查等。实现结构体如下：12345678910111213141516171819202122/* The cJSON structure: */typedef struct cJSON&#123; /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */ struct cJSON *next; struct cJSON *prev; /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */ struct cJSON *child; /* The type of the item, as above. */ int type; /* The item&apos;s string, if type==cJSON_String and type == cJSON_Raw */ char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; /* The item&apos;s number, if type==cJSON_Number */ double valuedouble; /* The item&apos;s name string, if this item is the child of, or is in the list of subitems of an object. */ char *string;&#125; cJSON; 参考文档：cJSON源码分析cJSON源码分析 注：关于开源项目源码阅读另作专题讨论。一般的开源项目中都有一些数据结构的使用，比如另外在paho.mqtt.c源码中有链表、树、堆等数据结构的使用，有需要时可以做深入分析。 面试相关问题 链表的倒序打印 除了上面提到的方法，还可以使用递归逆序打印，或者每个元素依次入栈再依次出栈。 递归的方法可以很好的保留现场，本质是一个栈，利用这个特征可以解决一些问题。例如在图的深度优先搜索算法也是用了递归，在回溯过程能够方便的获取某个结点的其他邻接点。 查找单向链表中倒数第k个结点 首先想到的思路是遍历第一遍，确定链表长度N。遍历第二遍，指针移动到N-k+1的位置取得数据。 改进的思路是只遍历一遍完成，先使用一个指针移动到K-1位置，然后再使用另一指针指向头结点，此时两个指针同时向后移动，当第一个指针到达尾部，第二个指针恰好到达N-K+1位置，即倒数第K个。 确定单向链表是否有环 首先想到的思路是取每一个结点，再取其他所有结点的next指针与之对比是否相等，如果没有则跳到下一个结点，再和所有其他结点对比，以此类推，时间复杂度高。 改进的思路是设计两个指针，快指针每次移动两个位置，慢指针每次移动一个位置，如果有环，则某时刻两个指针相等，如果没有环，则快指针先到达表尾。 约瑟夫环问题 问题描述为一个圆环，包括n个数，每次第m个数出列，之后的数重新从1开始计数，问最后一个出列的数是什么。 使用循环链表实现，指针移动到第m个数时，删除该节点，再重新开始计数，依次删除，直到只剩下最后一个数据，打印该数据。 参考文档：关于数据结构的10个面试题(c语言实现)面试常备题—链表总结篇如何判断链表中是否有环 个人观点 数据结构在嵌入式系统开发中，应该作为一种工具使用，而无需花过多精力探讨其内部实现。因此需熟练掌握其实现原理，主要理解其存储方式即结构体表达，和基本的运算即增删改查等。在此基础上，可以形成各种数据结构基本运算的代码模板，在实际项目中直接使用即可。此外，链表、栈、队列等在实际项目和面试中经常出现，其使用方法应熟练掌握。 数据结构的编程是C语言高级编程的综合应用，包括：指针的操作、结构体的操作、动态内存分配的操作等，相当于是前面知识的实践应用，所以可以综合前面知识总结的内容进行分析。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--7内存管理]]></title>
    <url>%2F2017%2F12%2F25%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇围绕C语言内存管理，讨论了变量存储模型、程序内存分配以及动态内存分配的使用方法，以及其使用注意事项，这些内容需结合函数、指针等知识进行综合分析。 存储模型 变量是对程序中数据的存储空间的抽象。一个变量可以通过存储期、作用域、链接点来描述。 存储期（生命期）：表示变量在内存中保存的时间。分为静态变量和动态变量。静态变量是编译时分配存储空间，从程序开始到程序结束。文件作用域的变量具有静态存储期。动态存储变量在程序执行中使用它时才分配存储空间，使用完立即释放。代码块作用域的变量具有动态存储期，例如函数的形参。函数定义时并不给形参分配存储空间，只有在函数被调用时，才予以分配。 作用域：表示变量出现有效区域。分为三种，代码块内作用域（即局部变量的情况）、函数原型作用域（从变量定义处到原型声明末尾，编译器只关心参数类型，不关心名字）、文件作用域（函数之外定义的变量具有文件作用域，也称为全局变量）。 链接点：用来说明程序哪些部分可以使用该变量。分为内部链接（一个文件内有效，使用static）、外部链接(一个或多个文件有效)、空链接（代码块作用域或者函数原型作用域）。 分类从存储期、作用域、链接点三个方面考虑，将变量的存储模型分为五类。 自动：使用关键字auto，可省略。一个代码块内或者函数头部声明的变量，即所谓的普通局部变量，具有动态存储期，代码块作用域、空链接。如果未初始化，则值不确定。 寄存器: 使用关键词register，具有自动存储期、代码块作用域和空链接。由于变量在寄存器中，不能使用取地址运算符获取变量的地址。未初始化则值不确定。 具有外部链接的静态：在所有函数外定义未使用static修饰的变量，即通常的全局变量，具有静态存储期，文件作用域和外部链接。仅在编译时初始化一次，默认为0,如果要在其他文件中使用，需要使用关键词extern。通常在.c文件定义，在.h文件中声明为外部变量。但不能在头文件为变量赋初值。 具有内部链接的静态：使用static修饰的全局变量，具有静态存储期、文件作用域、内部链接，只能在同一个文件中使用。仅在编译时初始化一次，默认为0。 空链接的静态：即static修饰局部变量，具有静态存储期、代码块作用域和空链接，仅在编译时初始化一次，默认为0。适用于多次调用函数且要求保留这些变量的值，可以考虑使用静态局部变量。 说明： 存储期是从时间上考虑变量，而作用域是从空间上考虑变量。要注意区别。 在函数专题中，提及函数返回值不能是局部变量，可以是静态局部变量或者堆上的内容。 注意区分一些概念。例如动态存储期。动态存储期是指局部变量空间在使用时才分配，且使用完就释放了，是相对于静态存储期而言。而动态分配是指程序员可以自己手动分配内存空间，是相对于自动分配而言。 static关键词的作用： 修饰全局变量，限制其作用域，只能在本文件中使用。 修饰局部变量，扩展其生存期，其值能保持到下一次调用，到程序结束时释放。 修饰函数，限制其作用域，只能在本文件中使用。 参考文献：C语言编程之存储模型、链接C语言存储模型 内存分配一个在运行的C语言程序占用内存的情况，分为以下几个区域： 代码区：只读，存放CPU执行的机器指令。 已初始化的全局数据与静态数据区：包括全局变量、静态变量（全局或局部）、常量数据（如字符串常量）。 未初始化数据区：即BSS区，存放未初始化的全局变量。 堆区：用于动态分配内存。位于BSS区和栈区之间。 栈区：存放函数参数、局部变量等。 说明： 这里的堆区别于数据结构中的堆，类似于链表。这里的栈，类似于数据结构中的栈，符合先进先出的规则。 size exename可以看到可执行文件各个区的大小，包括text、data、BSS，这里没有堆和栈，是存储时的三个区域，当程序执行时，才会有堆和栈。 ulimit -a命令可以查看资源限制的设定，包括栈空间、可打开的文件数等。 堆和栈的区别如下： 管理方式：堆区空间申请和释放需要程序员控制，而栈区由编译器自动管理。 空间大小：堆区内存不连续，空间大，而栈区连续空间，空间较小。 是否产生碎片：堆区需要频繁的malloc，容易造成内存空间不连续，产生碎片。 增长方向：堆区向着内存地址增加的方向，栈区向着内存地址减小的方向。 分配效率：堆区的效率低于栈区。 参考文档：C语言中内存分配 动态内存 通常情况下，编译器根据变量的类型知道所需的内存空间，在合适的时间分配确定的存储空间。在栈上创建局部变量，函数执行完毕自动释放存储单元，效率高，但分配的内存空间有限。该方式的分配和释放都是自动进行。 而有的情况只有在程序运行的时候才能确定内存分配大小，系统根据运行时的要求进行内存分配，称为动态存储分配。动态存储分配在堆上进行。使用malloc函数手动分配，使用free函数手动释放，因此其生存期由程序员决定。 对于动态分配的内存唯一的访问方式是通过指针间接访问。malloc函数在内存中动态的分配一个长度为size的连续空间，返回指向所分配连续空间起始地址的指针。内存空间有限，须在不用时，使用free函数显式释放空间。函数原型如下： malloc函数1void *malloc(size_t num); free函数1void free(void *p); 说明： malloc函数本身并不识别要申请的内存是什么类型，只关心申请内存的大小。在实际调用中，需要显式的进行强制类型转换。如果申请失败，返回NULL，因此要做错误判断。 堆区不会自动在分配时初始化，必须显式的进行初始化。例如：memset(p,0,n*sizeof(int));这一点在实践中应该注意。 分配的内存如果操作越界，会造成不可估量的后果，比如给char类型指针动态分配空间，需要考虑’\0’的存储空间。 使用堆上的空间，必须记得使用free释放，且只能释放一次。如果忘记释放，则会造成内存泄露。如果释放多次也会出错。 free 不允许释放部分内存。即free(p+2)是错误的。必须提供释放内存的起始地址。 free只是告诉系统这段空间不使用了，可以再次分配。但是其空间上的内容尚未改变，还可以访问，因此free后，通常置指针为NULL。释放的是堆空间，指针P在栈上，还指向原来的位置，因此可以访问，所以让其置NULL。 free只能释放堆空间。代码区、全局变量、静态变量区、栈区上的指针变量都不能用free释放空间。 malloc与free必须配对使用。不需要的内存空间都需要释放回收。 在函数内建立的动态对象在函数外仍然可以使用，这就是为什么函数可以返回堆上的地址的原因。因此堆上的空间称为自由空间。在函数运行时才能确定大小的情况，通常会在函数内动态分配内存并返回指针。但是在函数内申请动态空间而在函数外释放是一件很容易失控的事情，往往会出错。此种情况，要保证指针起始位置的正确赋值，并在函数外不使用指针时及时释放。 关于野指针：指向垃圾内存的指针。形成原因：（1）指针没有初始化；（2）指针free后没有置NULL。（3）指针操作超过了变量的作用范围，访问了非法内存。（4）返回指向栈内存的指针。 关于野指针会造成什么后果是难以估计的。若内存暂时空闲，可能程序正常运行，若内存再次被分配，又通过野指针对内存进行写操作，则原有合法数据会被覆盖。尽量应避免出现野指针。即指针初始化时置NULL，使用完毕释放后再次置NULL。 参考文档：C动态内存分配：（三）malloc/calloc/realloc/free使用注意事项 浅谈C语言内存管理、内存泄露、堆栈结构体指针内的指针变量成员的内存分配结构体内指针字符数组的释放free函数的实质 个人观点对于本节内容，主要是要掌握动态内存分配使用的各种注意事项，在实践中避免不规范的使用造成的内存错误。结合前面总结的指针、函数等内容综合分析。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>内存管理</tag>
        <tag>malloc</tag>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用JVM分析命令]]></title>
    <url>%2F2017%2F12%2F24%2F%E5%B8%B8%E7%94%A8JVM%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用JVM分析命令基本就是jps、jstack、jmap、jstat几个命令，配合top等命令可以定位大多数的问题。 jpsJVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 命令格式:1jps [options] [hostid] option参数:1234-l : 输出主类全名或jar路径-q : 只输出LVMID-m : 输出JVM启动时传递给main()的参数-v : 输出JVM启动时显示指定的JVM参数 用例:12345$ jps -l46644 sun.tools.jps.Jps46582 com.intellij.rt.execution.application.AppMain46378 org.jetbrains.idea.maven.server.RemoteMavenServer46581 org.jetbrains.jps.cmdline.Launcher jstatJVM statistics Monitoring,是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 命令格式:12345jstat [option] pid [interval] [count][option] : 操作参数pid : 本地虚拟机进程ID[interval] : 连续输出的时间间隔[count] : 连续输出的次数 option参数:1234567-class : class loader的行为统计-compiler : HotSpt JIT编译器行为统计-gc : 垃圾回收堆的行为统计-gccapacity : 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计-gccause :垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因 -gcutil : 垃圾回收统计概述others : ... 用例:1234567$ jstat -gcutil 46582 1000 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 0.00 4.00 42.73 14.19 15 0.059 4 0.573 0.632 0.00 0.00 4.00 42.73 14.19 15 0.059 4 0.573 0.632 0.00 0.00 4.00 42.73 14.19 15 0.059 4 0.573 0.632 0.00 0.00 4.00 42.73 14.19 15 0.059 4 0.573 0.632 0.00 0.00 4.00 42.73 14.19 15 0.059 4 0.573 0.632 jstackjstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 命令格式:1jstack [option] pid option参数:123-F : 当正常输出请求不被响应时，强制输出线程堆栈-l : 除堆栈外，显示关于锁的附加信息-m : 如果调用到本地方法的话，可以显示C/C++的堆栈 用例:1234567891011121314151617181920212223$ jstack -l 46582Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.79-b02 mixed mode):"Attach Listener" daemon prio=5 tid=0x00007fb30a186800 nid=0x3307 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None"DestroyJavaVM" prio=5 tid=0x00007fb30a08d000 nid=0xd03 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None"Thread-1" prio=5 tid=0x00007fb30991e800 nid=0x4c03 runnable [0x0000000114bb5000] java.lang.Thread.State: RUNNABLE at java.util.HashMap.put(HashMap.java:494) at jvm.ResizeDemo$2.run(ResizeDemo.java:26) at java.lang.Thread.run(Thread.java:745) Locked ownable synchronizers: - None 注意: stack文件是瞬时线程堆栈,一定要多个时刻的stack文件,以便于确定哪些线程是真正有问题的。 top -Hp pid可以查看某个进程内的线程状态,线程id换算成16进制对应stack文件中nid的值,通常用来定位有问题的线程(cpu消耗过高等)12345top -Hp 17072PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND18167 work 20 0 8793m 2.5g 14m S 10.6 16.3 16:19.55 java17927 work 20 0 8793m 2.5g 14m S 1.0 16.3 5:15.71 java20516 work 20 0 8793m 2.5g 14m S 1.0 16.3 3:52.57 java jmapJVM Memory Map,用于生成heap dump文件,可以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候自动生成dump文件,以便分析问题。 命令格式:1jmap [option] pid option参数:1234dump : 生成堆快照heap : 显示Java堆详细信息histo : 显示堆中对象的统计信息others : ... 用例:123$ jmap -dump:live,format=b,file=dump.bin 46582Dumping heap to /Users/xiao1zhao2/blog/dump.bin ...Heap dump file created 生成的dump文件一般用mat等分析工具进行查看。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--6用户自定义数据类型(结构体)]]></title>
    <url>%2F2017%2F12%2F15%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--6%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E7%BB%93%E6%9E%84%E4%BD%93)%2F</url>
    <content type="text"><![CDATA[本篇文章以用户自定义数据类型为核心，重点讲解了结构体使用的相关知识点：包括定义、初始化、使用，结构体数组，结构体指针，以及讨论了一些在实践中需要考虑的问题。最后简要介绍了共用体和枚举。 结构体基本使用 结构体是一种构造类型，用户自定义的数据类型。包含多个不同数据类型的数据组合在一起进行描述。其中可以是基本类型也可以是构造类型。 结构体的作用：结构体的使用为处理复杂数据结构（如动态数据结构）提供了有效的手段。而且，为函数间传递不同类型的数据提供了方便。 结构体变量定义123456789101112131415161718192021222324252627方法1.先定义结构体，再定义变量名。适合于同时定义多个变量。struct 结构体名&#123; 数据类型 成员名１; 数据类型 成员名２; …… 数据类型 成员名n;&#125;;struct 结构体名 变量名;方法2.在定义结构体类型的同时定义变量。适合于定义全局结构体。struct 结构体名&#123; 数据类型 成员名１; 数据类型 成员名２; …… 数据类型 成员名n;&#125;变量名;方法3.直接定义结构体变量。适合于函数内部或者结构体嵌套，因为其他地方不可以再声明。struct &#123; 数据类型 成员名１; 数据类型 成员名２; …… 数据类型 成员名n;&#125;变量名; 说明： 在定义结构体时，不占内存空间，只有在定义结构体变量时，才分配内存空间。 struct关键字和结构体名必须写在一起，代表结构体类型名。因此为了方便，可以在定义结构体时使用typedef，这样在后面定义变量时则可以少写struct。 一般在头文件定义结构体，如果在定义结构体同时定义结构体变量，则是全局的结构体变量，在其他文件可以包含该头文件，使用该结构体变量，但是不能再定义其他结构体变量。因此定义结构体同时定义结构体变量只适合于该结构体只使用一次的情况。通常的做法是在头文件使用typedef 定义结构体新数据类型，在其他文件定义该数据类型的结构体变量。 结构体变量初始化按照结构体变量定义的方式不同，也有不同的初始化方法。1234567方法1：struct 结构体名 变量名=&#123;初始数据表&#125;;方法2：struct 结构体名&#123; 成员列表;&#125;变量名=&#123;初始数据表&#125;; 说明：可以对结构体部分成员赋初值。另外，在驱动编程部分也涉及结构体初始化问题。通常写法如下：1234567891011121314151617181920结构体变量初始化struct device=&#123; .id=-1, .name=&quot;key&quot;, ……&#125;;结构体数组变量初始化struct device[]=&#123; [0]=&#123; .id=-1, .name=&quot;key1&quot;, …… &#125;, [1]=&#123; .id=-1, .name=&quot;key2&quot;, …… &#125;,&#125;; 结构体变量使用 结构体变量的成员表示为：结构体变量名.成员名。 定义了结构体变量后，可以对结构体变量的成员赋值，也可以引用其地址。如果结构体当中又嵌套结构体，则只能一层一层找到最低层进行运算。 不能将一个结构体类型变量作为一个整体引用，只能对结构体变量中的成员加以引用。 同一类型的结构体变量之间可以互相赋值，但是数组不可以互相赋值。赋值后就相当于所有成员被赋值了。 两个结构体变量进行比较，可以各成员逐个比较，也可以使用memcpy比较内存内容。 结构体数组与结构体指针结构体数组 首先结构体数组是指数组元素为结构体，那么结构体数组的定义、初始化、使用和结构体变量的定义、初始化、使用类似，此处省略。 其次它又是数组，因此有数组的特性，数组的个数等于sizeof(数组名)/sizeof(结构体名)。 在使用时，结构体数组的元素值可以赋值给同一类型的另一个数组的元素，也可以赋值给同类型的结构体变量，也就是允许结构体之间互相赋值。 结构体指针用一个指针变量指向一个结构体变量，该指针变量的值是结构体变量的起始地址，该指针为结构体指针。 定义：1struct 结构体名 *结构体指针名; 说明： 在定义结构体变量的同时，也可以定义结构体指针变量，并且使用typedef定义一种新的数据类型。详见《C语言高级编程–1基础零碎知识》。 定义结构体指针变量只是说明该指针指向这种结构体类型，规定了其数据特性，并为结构体指针本身分配了内存空间，但是指针的内容尚未确定，指向随机的对象。 使用结构体指针访问成员，使用-&gt;。 扩展问题总结 在实践中经常用到结构体。在项目详细功能设计阶段需要设计项目所需的各个结构体。在阅读开源代码时，也需着重分析核心结构体，例如mosquitto源码、cJSON源码、onvif源码等，其中涉及的结构体举例详见gist。 结构体可以理解为面向对象编程语言中的对象，其中普通数据类型的成员相当于属性，函数指针成员相当于方法。 结构体中成员为函数指针：通常会在某个函数里赋初值，即赋值为某函数名(回调函数)。然后使用结构体成员调用函数，即会执行回调函数。 结构体中成员要使用字符串，可以用字符数组也可以使用字符指针。但是使用字符指针，需要使用malloc先动态分配内存，才可以赋值内容。字符数组和字符指针赋值，即填充字符串，都使用strcpy，strncpy，snprintf等函数，但需要注意这些函数各自的特点。 如果函数返回结构体指针，在函数体内对结构体填充内容，首先需要对结构体指针malloc动态分配内存。如果其中成员含有字符指针，需要使用malloc二次动态分配空间填充字符串。 为结构体指针分配动态内存时，只是为其中字符指针成员分配空间，并没有为其指向的字符串分配空间，因此需要二次分配。 注意free的时机，两次分配的内存空间并不连续。如果在函数外需要访问结构体内容，访问完毕需要先释放字符指针成员的空间，再释放结构体指针的空间。且不可以在函数内释放字符指针成员空间。 正是由于第二点使用的不方便，可以定义零长度数组成员，实现连续空间的分配和释放，详见参考文档《C语言结构体里的成员数组和指针》。 关于结构体作为函数返回值：如果返回结构体，在函数内错误处理不便于返回。若返回结构体指针，出错时可以返回NULL。 关于结构体做形参：若使用结构体做形参，需要大面积赋值，且也不能改变实参的值，因此多使用结构体指针做形参。 关于函数返回结构体指针和函数形参为结构体指针的选择：和其他函数考虑一样，如果是在函数内确定结构体数组大小，返回动态分配的内存内容，考虑返回结构体指针。如果要返回多于一个返回值，考虑使用多个形参。 使用示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889头文件 b.h：#ifndef _B_H_#define _B_H_typedef struct&#123; int num; char *name;&#125;student,*student_t;#endifmain.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;b.h&quot;student_t set_info()&#123; int n = 2; //为结构体指针分配空间 student_t studentP=(student_t)malloc(sizeof(student)*n); //64位系统，8字节对齐 printf(&quot;%lu\n&quot;,sizeof(student));//16 printf(&quot;%lu\n&quot;,sizeof(int));//4 printf(&quot;%p\n&quot;,studentP); printf(&quot;%p\n&quot;,&amp;studentP[0].num); //只是分配了存放指针成员的内存空间，指针指向的内容空间没有分配 printf(&quot;%p\n&quot;,&amp;studentP[0].name); printf(&quot;%p\n&quot;,&amp;studentP[1].num); printf(&quot;%p\n&quot;,&amp;studentP[1].name); studentP[0].num=1; //为字符指针成员所指向的内容分配空间 studentP[0].name = (char *)malloc(sizeof(char)*10); //使用snprintf赋值 snprintf(studentP[0].name,10,&quot;%s&quot;,&quot;youbo&quot;); studentP[1].num=2; studentP[1].name = (char *)malloc(sizeof(char)*10); snprintf(studentP[1].name,10,&quot;%s&quot;,&quot;xiaozhao&quot;); //其值为所指向字符串的首地址，和前面的地址并不连续 printf(&quot;%p\n&quot;,studentP[0].name); printf(&quot;%p\n&quot;,&amp;studentP[0].name[0]); printf(&quot;%p\n&quot;,&amp;studentP[0].name[1]); printf(&quot;%p\n&quot;,studentP[1].name); printf(&quot;%p\n&quot;,&amp;studentP[1].name[0]); printf(&quot;%p\n&quot;,&amp;studentP[1].name[1]); //如果在该处释放后，函数外不能访问内容 //free(studentP[0].name); //free(studentP[1].name); return studentP;&#125;int main(int argc,const char *argv[])&#123; student_t studentP = NULL; studentP = set_info(); printf(&quot;%d %s\n&quot;,studentP[0].num,studentP[0].name); printf(&quot;%d %s\n&quot;,studentP[1].num,studentP[1].name); free(studentP[0].name); free(studentP[1].name); studentP[0].name = NULL; studentP[1].name = NULL;// printf(&quot;%s\n&quot;,studentP[0].name); free(studentP); // 如果不释放studentP[0].name,只释放studentP,在置NULL之前还可以访问成员指向的内容// printf(&quot;%s\n&quot;,studentP[0].name); studentP = NULL; // 置NULL后再访问一定会出现段错误，可以避免错误。// printf(&quot;%s\n&quot;,studentP[0].name);// 必须在studentP释放之前释放指针成员空间// free(studentP[0].name);// free(studentP[1].name);// studentP[0].name = NULL;// studentP[1].name = NULL; return 0;&#125; 参考文档：c语言里用结构体和指针函数实现面向对象思想对结构体中字符串指针和字符数组赋值的区别是什么C语言，结构体中字符串的声明（采用字符指针还是字符数组）C语言结构体里的成员数组和指针strcpy和strdup比较和详解结构体内的指针需要逐个释放吗？ 位域位域是指把一个字节的二进位划分为不同的区域，并说明每个区域的位数。每个域有一个域名，允许程序按域名操作。这样可以将几个不同对象用一个字节的二进制位域来表示，从而可以节约空间。 定义：1234struct 位域结构体名&#123; 类型说明符 位域名:位域长度;&#125;; 使用示例:123456789101112131415161718192021222324252627282930313233343536linux内核源码 linux-3.14/include/linux/tcp.hstruct tcphdr &#123; __be16 source; __be16 dest; __be32 seq; __be32 ack_seq;#if defined(__LITTLE_ENDIAN_BITFIELD) __u16 res1:4, doff:4, fin:1, syn:1, rst:1, psh:1, ack:1, urg:1, ece:1, cwr:1;#elif defined(__BIG_ENDIAN_BITFIELD) __u16 doff:4, res1:4, cwr:1, ece:1, urg:1, ack:1, psh:1, rst:1, syn:1, fin:1;#else#error &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;#endif __be16 window; __sum16 check; __be16 urg_ptr;&#125;; 说明: 位域不可以跨越字节，如果剩下的位不足以存放一个位域时，应该从下一单元起存放该位域，而上一字节剩下的部分用无名的位域来填充。 位域其实是一种结构类型，只是其成员是按照二进制位进行分配。 位域变量定义和使用方法都和结构体类似，此处省略。 位域在实践中用的较少，仅作了解。 共用体共用体又称为联合体。其定义、初始化、使用方法和结构体类似，但是在使用内存上有所不同。特点： 不同数据类型的数据使用共同的存储空间。 由于第一条的特点，因此各个成员的首地址相同。 由于第一条的特点，因此共用体变量起作用的成员是最后一次存放的成员，新的成员值会将旧的成员值覆盖。 共用体用在各数据类型占用空间差不多，且对各变量同时使用要求不高的场合。例如共享内存，每次只用到其中一个成员的情况。 使用示例：123456789101112131415161718192021e.g1信号灯集操作函数,第四个参数是一个共用体，适用于不同的情况。 int semctl(int semid, int semnum, int cmd, ...); union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */ unsigned short *array; /* Array for GETALL, SETALL */ struct seminfo *__buf; /* Buffer for IPC_INFO (Linux-specific) */&#125;;e.g2共用体测试字节序是大端还是小端union gy&#123; char a; short b; int c;&#125;;union gy t;t.c = 0x12345678;printf(&quot;%#x %#x %#x\n&quot;,t.a,t.b,t.c); 参考文档联合体（union）的使用方法及其本质共用体的定义与应用详细解析 sizeof作用于结构体和共用体 不考虑字节对齐，结构体的大小是所有成员大小之和。 不考虑字节对齐，共用体的大小是成员中占字节最大的字节数。 如果考虑字节对齐，结构体大小可能会变大，32位机4字节对齐，64位机8字节对齐。 如果考虑到对齐原则，那么定义结构体时，尽量注意顺序，4字节成员放前面，接着是2字节成员，最后是1字节成员。 如果出现某个数据总是与期望的不符，但不会波动，要考虑字节未对齐的问题。 参考文档：C语言字节对齐问题详解（对齐、字节序、网络序等） 枚举枚举用于变量取值有限的情况。定义：123enum 枚举名&#123;枚举列表&#125;; 说明： 如果不写取值，默认从0开始，是整型数据。如果想要改变，可以自定义每一个成员等于几。 如果没有显式赋值的成员值总是在前一个枚举成员的值上加１，允许不同成员具有相同的值。 枚举变量的定义，使用都是和结构体共用体类似，此处省略。 枚举是一种基本数据类型，因为其不可再分。 个人观点 至此，完成了C语言中四个重要知识点的梳理，包括数组、指针、函数、结构体。 总结起来，讨论了两个内容，一是数据类型：数组、指针、结构体。二是函数。而函数中有形参和返回值，这些都是变量，因此又和数组、指针、结构体等数据类型产生关系。因此需要综合考虑。 应先理解每一个知识点的含义，再进行组合考虑。比如数组指针、指针数组、字符数组、字符指针、函数指针、指针函数、函数指针数组、函数传递指针、函数传递数组、函数传递字符数组、函数传递字符指针、函数传递结构体、函数传递结构体指针、函数返回指针、函数返回指向数组的指针、函数返回结构体 、结构体指针、结构体数组、结构体成员为字符数组、结构体成员为字符指针、结构体成员为函数指针。 要理解各个内容是在什么情况下使用，有什么特点好处，才会在遇到同样的情况下有意识的去使用这个知识点。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>指针</tag>
        <tag>结构体</tag>
        <tag>共用体</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--5函数]]></title>
    <url>%2F2017%2F12%2F11%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--5%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本篇文章以函数为核心，重点讲解函数指针和指针函数，以及与之密切相关的函数传参和函数返回值。在实践中应该结合这几个知识点综合考虑其使用。最后简单提及递归函数。 函数基础 函数是一个完成特定功能的代码模块，通常有参数，也可以沒有参数。通常要求有返回值，也可以是空值。 使用函数可以实现代码的复用，使程序更整洁，可读性更好。函数是实现模块化编程的重要工具。 定义12345&lt;数据类型&gt; &lt;函数名&gt;(形参说明)&#123; 语句序列； return (&lt;表达式&gt;);&#125; 说明： 这里的数据类型是指函数返回的数据类型。 return 表达式的类型要和函数返回类型一致，如果返回值为void,可以省略return不写。 如果不写数据类型，则默认为返回int型，而不是void型。 形参出现在被调函数当中，在整个函数体内都可以使用。形参在定义时编译系统并不分配存储空间，只有在调用该函数时才分配内存单元。调用结束内存单元被释放，故形参只有在函数调用时有效，调用结束时不能再使用。可结合《C语言高级编程–7内存管理》中的内容理解。 函数前可以使用static修饰，表示该函数只能在本文件内使用。默认函数是外部函数，用extern修饰，可以省略不写。 声明1&lt;数据类型&gt; &lt;函数名&gt;(形参说明); 说明： 函数声明又称为函数原型，function prototype。 形参说明中可以省略变量名，但是不能省略类型。因为编译器并不会检查变量名。 在调用函数前必须已进行了声明，要么是在头文件里面声明，要么被调用函数写在调用函数之前。 声明的作用是为了把函数名、返回值类型以及形参类型、个数和顺序通知编译系统，以便在调用该函数时，编译系统进行对照检查。 调用1函数名(实参说明) 说明： 实参可以是确切的数据，也可以是有确切值的表达式。 实参出现在主调函数当中，当函数调用时，主调函数把实参的值或者地址传送给被调函数的形参，从而实现函数间的数据传递。 函数调用可以作为一个运算量出现在表达式中,也可以作为单独的语句。 函数传参两种方式复制传递方式 原理：调用函数把实参传递给被调用函数，被调用函数会创建同类型的形参，并用实参进行初始化。即把实参赋值给一个新的变量，把实参的值复制到新建的形参的存储区域中，也就是函数内的变量和函数外的变量是存储在不同位置。 特点：被调用函数不能访问调用函数里的实参。即使改变了形参的值，函数调用完成后，形参被系统释放，不会改变实参的值。 地址传递方式 原理：调用函数把实参的地址传递给被调用函数。被调用函数对该地址的目标进行操作，相当于对实参本身的操作。此时，实参为变量的地址，形参为同类型的指针。 特点：被调用函数中通过地址解引用方式可以访问到函数外的实参，从而间接的改变实参的值。 说明： 复制传递和地址传递方式的区别，经典例子是交换两个数。 参数的传递是单向的，只能实参传递给形参。 除了复制传递和地址传递，也可以使用全局变量传参，但是使用全局变量传递参数的先后顺序不同会影响计算结果，应该少用。 C语言中都是按值传递。可以传递变量（复制传递），也可以传递变量的指针（地址传递）。而按引用传递的概念应该是出现在C++中。 关于结构体作为参数，因为结构体通常很大，而将实参赋值给形参会效率低下，因此通常考虑传递结构体指针。 关于函数返回值与函数传参，因为地址传递方式可以改变函数外的变量，相当于函数返回。因此当函数需要返回多于一个的值时，应考虑使用形参传递地址。 参考文档：24.C语言函数传参详解C语言中的值传参和引用传参是指什么？值传递和引用传递—–函数参数传递的两种方式 传递数组由于其特殊性，单独说明数组在函数之间的传递。这里是指在函数的形参里可以是数组形式。使用示例:12345678double testArray(double b[], int size)//相当于double testArray(double *b,int size)int test_array(int n,int m,int a[][m],int *p)//相当于int test_array(int n,int m,int (*a)[m],int *p)int main(int argc,const char *argv[])//相当于int main(int argc,const char **argv) 说明: 形参为数组形式时，本质是同级别的指针。相当于传递的是数组的首地址，由于数组存储的连续性，因此可以依次访问数组的所有元素。 通常除了传递数组名还要传递数组元素个数。此时实参为数组名。 在函数的内部，传入的数组名相当于是指向数组首地址的指针，因此此时求sizeof不是数组的大小，而是为4或者8。 形参中使用数组形式时，[]里的数字可有可无，因为它相当于一个指针，并不需要数组长度信息。 理解形参出现数组形式的原因可能是在函数内看起来像一个数组，可以作为数组使用。但实际上它会退化为一个指针。它带来的方便可能比它带来的歧义更多，因此最好使用同类型的指针，而不使用数组形式。 参考文档：《你必须知道的495个C语言问题》p65 6.4 指针函数与函数指针指针函数如果一个函数返回值是指针，则称函数为指针函数。定义:12345&lt;数据类型&gt; *&lt;函数名&gt;(形参说明)&#123; 语句序列； return (&lt;表达式&gt;);&#125; 错误使用示例：12345678910char *mystring(void)&#123; char str[20] =&#123;0&#125;; strcpy(str,&quot;hello&quot;); return str;&#125;int main(void)&#123; printf(&quot;%s\n&quot;,mystring);&#125; 分析：编译出现警告：function returns address of local variable(返回了局部变量的地址)，运行结果是打印乱码。局部变量是分配在栈上，函数执行完毕，局部变量自动释放，在主调函数中不能再访问。访问一段释放的内存是非法操作，显示乱码。如果修改了非法内存中的值，可能会有更严重的后果，不可预料。 函数正确返回指针的三种方法 12345678910111213141516171819202122232425262728293031323334353637383940414243441.使用static,static变量到程序结束时才会回收内存。char *mystring(void)&#123; static char str[20]; strcpy(str,&quot;hello&quot;); return str;&#125;int main(void)&#123; printf(&quot;%s\n&quot;,mystring);&#125;2.使用字符串常量，和静态变量类似，字符串常量也在程序结束时才释放内存。char *mystring(void)&#123; char *str = &quot;hello&quot;; return str;&#125;int main(void)&#123; printf(&quot;%s\n&quot;,mystring);&#125;3.使用malloc,动态分配空间。char *mystring(void)&#123; char *str = NULL; str = (char *)malloc(20); if(str == NULL) &#123; return str; &#125; strcpy(str,&quot;hello&quot;); return str;&#125;int main(void)&#123; char *s; if((s = mystring()) != NULL) &#123; printf(&quot;%s\n&quot;,s); free(s); &#125;&#125; 说明： 指针函数返回的地址在主调函数中必须是有效的，是可以访问的内存。 指针函数不可以返回局部变量的地址，可以返回的地址有三种：静态变量的地址，字符串常量的地址，堆上的地址。 在实践中使用较多的是第三种方式，在函数内使用malloc动态分配内存，填充内容后，返回指针。应注意可能涉及多次的malloc,例如为结构体指针分配内存空间，再为结构体成员分配内存空间。此外，还需注意在函数外合适的位置使用free释放指针并置NULL。 函数指针函数指针是用来存放函数地址的指针。函数地址是一个函数的入口地址。函数名代表了函数的入口地址。当一个函数指针指向了一个函数，就可以通过这个指针来调用这个函数。 定义：1&lt;数据类型&gt; (*&lt;函数名&gt;)(形参说明)； 说明： 数据类型是指函数指针所指向的函数的返回值的类型。 形参说明应该和指向的函数的形参说明保持一致。 函数指针做形参，使用函数名做实参。定义函数指针变量，也用函数名赋值。 使用函数指针调用函数时，写法为去掉数据类型，填入实参即可。相当于地址解引用调用函数。 定义函数指针时，形参里面的变量可以不写，但是类型不能省略。 关于函数名：函数名是一个符号，表示整个函数代码段的首地址，其实质是一个指针常量，所以在程序中使用到函数名时都是当地址用的，表示调用该函数。 关于回调函数：回调函数就是一个通过函数指针调用的函数。这个在实践中经常出现，应掌握。常用在中断发生，调用某个函数。该内容涉及结构体、多线程等内容，可另作讨论总结。 结构体中也可以定义函数指针成员，赋值为函数名，在适当时候调用回调函数。 参考文档：C语言函数指针基础Linux C 函数指针应用—回调函数C语言中的回调函数（Callback Function）结构体中定义函数指针 使用示例：12345678910111213141516171819202122232425262728293031323334353637383940e.g1用函数指针使用不同功能的函数int test(int a,int b,int (*pFunc)(int m,int n));int plus(int,int);int minus(int,int);int main()&#123; int x=5,y=8; int (*pFunc)(int a,int b);//注意定义函数指针的写法 pFunc = minux; printf(&quot;%d\n&quot;,(*pFunct)(x,y));//注意使用函数指针调用函数的写法 printf(&quot;%d\n&quot;,test(5,15,plus));&#125;int plus(int a,int b)&#123; return a+b;&#125;int minus(int a,int b)&#123; return a-b;&#125;int test(int a,int b,int (*pFunc)(int m,int n))&#123; return (*pFunc)(a,b);&#125;e.g2信号注册typedef void (*sighandler_t)(int);sighandler_t signal(int signum,sighandler_t handler);注意理解这里的typedef，typedef的作用是定义一种数据类型，这里相当于定义了一种函数指针类型，因此在其他地方使用时，就可以简化只写sighandler_t。例如函数原型中的形参和返回值。如果还是原来那种复杂的写法，则不易看懂。e.g3创建线程int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);e.g4快速排序，需要用户自定义元素比较规则。void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 总结起来，函数指针的用处有以下几点： 定义一种函数模板，结合void指针，处理不同数据类型实现相同功能的情况。例如比较两个对象的大小，对象是int、double、char*等类型。 定义一种函数模板，处理相同数据类型和个数，功能不同的情况。例如对两个整型数的加减乘除。 函数形参为函数指针，适用于库函数编写者，由用户使用时决定函数的具体使用方法。提高灵活性和通用性。 函数形参为函数指针，传递回调函数的函数名，在适当的时候调用回调函数。 递归函数 递归函数是指函数的函数体中直接或间接的调用了该函数自身的函数。 递归函数调用执行分为两步：递推和回归。函数实现是递推过程，函数调用是回归过程。 实例分析函数传参 实践中函数形参为指针时，通常会在函数内部通过地址解引用改变指针指向对象的内容，比如字符指针，在函数内赋值字符串。实参应该传递字符数组，而不要传递字符指针。 函数形参为指针，实参传递指针时，如果在函数内部通过地址解引用改变指针指向对象的内容，实参会有相应改变。如果在函数内部改变形参的地址，相当于普通变量值传递，实参不会有相应变化。 实践中函数定义使用形参和函数调用使用实参，其形参和实参对应关系有:形参为一级指针，实参为一维数组名。形参为行指针，实参为二维数组名。形参为二级指针，实参为一维指针数组名。形参为结构体指针，实参为结构体地址。形参为字符指针，实参为字符数组名。 使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566传递数组名和传递指针的不同，传递指针出现段错误。int get_cameraIP(uint8_t *str,uint8_t *cameraIP)&#123; uint8_t *p = str; uint8_t *begin = NULL; uint8_t *end = NULL; const char *d =&quot;.&quot;; int dot_flag = 0; int first_num_flag = 0; int last_num_flag = 0; int i = 0; int j = 0; while(*p != &apos;\0&apos;) &#123; if(isdigit(*p)&amp;&amp;first_num_flag == 0)//找到第一个数字 &#123; begin = p; first_num_flag = 1; &#125; if((dot_flag == 3) &amp;&amp; (!(isdigit(*p)) &amp;&amp; (last_num_flag == 0)))//找到最后一个IP数字 &#123; end = p; last_num_flag = 1; &#125; if(*p == &apos;.&apos;) &#123; dot_flag++; &#125; p++; &#125; for(i = 0 ;i &lt; (end-begin);i++) &#123; cameraIP[i] = str[begin-str+i];//提取IP字符串 &#125; return 0;&#125;int ONVIF_ClientDiscovery(void)&#123; …… struct __wsdd__ProbeMatches resp; retval = soap_recv___wsdd__ProbeMatches(soap, &amp;resp); if (resp.wsdd__ProbeMatches-&gt;ProbeMatch != NULL &amp;&amp; resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs != NULL) &#123; for(i = 0; i &lt; resp.wsdd__ProbeMatches-&gt;__sizeProbeMatch; i++) &#123; //printf(&quot;%s\n&quot;, resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs); memset(CameraInfo[FoundDevNo].cameraIP,0,16);//全局变量使用前先清零 //将摄像头IP存入摄像头完整信息全局数组 //get_cameraIP(resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs,&amp;CameraInfo[FoundDevNo].cameraIP[0]); //解决段错误，传递数组名，而不是指针 uint8_t tmpip[256]=&#123;&#125;; sprintf(tmpip,&quot;%s&quot;,resp.wsdd__ProbeMatches-&gt;ProbeMatch-&gt;XAddrs); printf(&quot;%s\n&quot;,tmpip); get_cameraIP(tmpip,&amp;CameraInfo[FoundDevNo].cameraIP[0]); …… &#125; &#125;&#125; 参考文档：一级指针还是二级指针作函数参数（2）C语言中“指针”作为“函数参数”时的注意事项指针形参实参传递时需要注意 指针函数 指针函数返回指针，调用时，用同类型的指针变量接收即可。 在实践中返回堆上的地址用的多，涉及malloc和free的使用。需要考虑malloc多次，以及何时free。 关于函数返回值是指针类型或者用指针传递参数的选择：若需要返回多个值，考虑形参为指针。若返回动态内存，考虑函数返回值为指针。 在函数内的字符数组加了static,返回该数组名才能在主函数内访问。如果在主函数不能访问，考虑函数内的变量已经销毁，在适当的位置加上static。 使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201e.g1 指针函数返回堆上的地址。在函数中确定数组大小再动态分配空间。/* * 假设message是符合json格式的字符串，这里未对字符串的格式做检查 * 将控制json格式的字符串分割为原子字符串,以便后续处理 * eg:&#123;&quot;function&quot;:1,&quot;sensorID&quot;:1,&quot;sensorName&quot;:&quot;totalTime&quot;,&quot;valueType&quot;:2,&quot;value&quot;:0&#125; * */char **split_message(char *message,int *num)&#123; int commaNum = 0; int i = 0; int j = 0; int atomMessageNum = 0; int *commaPos = NULL; char **atomMessageArray = NULL; //统计逗号个数，按照协议，json格式应该是一个数组，数组元素是对象,这里称作控制数据原子包 for(i=1;i&lt;strlen(message); i++) &#123; if(message[i] == &apos;,&apos; &amp;&amp; message[i-1] == &apos;&#125;&apos; &amp;&amp; message[i+1] == &apos;&#123;&apos;) &#123; commaNum++; &#125; &#125; //控制数据原子包个数，并通过num返回 atomMessageNum = commaNum + 1; *num = atomMessageNum; //动态分配内存，这里是一个二级字符指针，指向一个字符指针数组，每个数组元素存放字符的首地址 atomMessageArray = (char **)malloc(sizeof(char *) * atomMessageNum); //动态分配内存，对字符指针数组里每个元素分配内存，便于后续使用strncpy赋值 for(i=0; i&lt;atomMessageNum; i++) &#123; atomMessageArray[i] = (char *)malloc(sizeof(char) * ATOMPAYLOAD_MAX); &#125; //数组元素只有一个 if(commaNum == 0) &#123; strncpy(atomMessageArray[0],message+1,strlen(message)-2-1+1); atomMessageArray[0][strlen(message)-2+1] = &apos;\0&apos;; &#125; //数组元素有多个 else if(commaNum &gt; 0) &#123; //统计每个逗号在整个message的位置，存放在动态分配的数组中 commaPos = (int *)malloc(sizeof(int) * commaNum); for(i=1;i&lt;strlen(message); i++) &#123; if(message[i] == &apos;,&apos; &amp;&amp; message[i-1] == &apos;&#125;&apos; &amp;&amp; message[i+1] == &apos;&#123;&apos;) &#123; commaPos[j] = i; j++; &#125; &#125; //第一个数组元素赋值 //起始位置：1 //结束位置：commaPos[0]-1 //长度：commaPos[0]-1-1+1 snprintf(atomMessageArray[0],commaPos[0]-1-1+2,&quot;%s&quot;,message+1); //第2个数组元素到第atomMessageNum-1个元素 //起始位置：commaPos[i-1]+1 //结束位置：commaPos[i]-1 //长度：commaPos[i]-1-(commaPos[i-1]+1)+1 for(i=1; i&lt;atomMessageNum-1; i++) &#123; snprintf(atomMessageArray[i],commaPos[i]-1-(commaPos[i-1]+1)+2,&quot;%s&quot;,message+commaPos[i-1]+1); &#125; //最后一个数组元素 //起始位置：commaPos[commaNum-1]+1 //结束位置：strlen(message)-2 //长度：strlen(message)-2-(commaPos[commaNum-1]+1)+1 snprintf(atomMessageArray[atomMessageNum-1],strlen(message)-2-(commaPos[commaNum-1]+1)+2,&quot;%s&quot;,message+commaPos[commaNum-1]+1); free(commaPos); &#125; return atomMessageArray;&#125;/* *控制数据解包，返回commandInfo指针，和个数 * */commandInfo_t control_payload_parse(char *message,int *num)&#123; char **p = NULL; commandInfo *commandInfoP = NULL; int i; int numTemp; //分割字符串为原子字符串，并获取个数 p = split_message(message,num); numTemp = *num; //动态分配内存空间，存放commandInfo结构体数组 commandInfoP = (commandInfo *)malloc(sizeof(commandInfo)*numTemp); for(i=0; i&lt;numTemp; i++) &#123; //结构体整体赋值 commandInfoP[i] = json_control_atom_unpack(p[i]); //挨个释放p[i]内存 free(p[i]); //判断所给message是否有格式异常，json_control_atom_unpack中异常时，整个结构体赋值0.这里没有对比所有结构体成员，足以判断 if(commandInfoP[i].commandType == 0 &amp;&amp; commandInfoP[i].sensor.sensorID == 0 &amp;&amp; commandInfoP[i].sensor.type == 0) &#123; return NULL; &#125; &#125; //释放二级指针动态分配的空间 free(p); return commandInfoP; &#125;e.g2 指针函数返回静态变量的地址。/* * json解析字符串,返回json结构体，和键指对个数n * 格式限定为： * &#123; * xxx:xxx * xxx:xxx * &#125; */jSONStruct *json_unpack(char *string,int *n)&#123; //函数调用完毕后该变量释放，在函数外不能访问其值，因此加上static static bool tmp; int num,i; //解析json字符串 jSONStruct *jSONStructP = NULL; cJSON *root = cJSON_Parse(string); //获取键值对个数 num = cJSON_GetArraySize(root); *n = num; if(num == 0) &#123; DEBUG_CUSTOMERR(&quot;json format error&quot;); return NULL; &#125; //动态分配内存，便于后面依次填充jSONStruct结构体的内容 jSONStructP = (jSONStruct *)malloc(sizeof(jSONStruct) * num); //获取每一个键值对内容 for(i=0;i&lt;num;i++) &#123; cJSON *jSON1 = cJSON_GetArrayItem(root,i); //填充key strncpy(jSONStructP[i].pKey,jSON1-&gt;string,strlen(jSON1-&gt;string)); jSONStructP[i].pKey[strlen(jSON1-&gt;string)] = &apos;\0&apos;; //按类型填充value和类型 if(cJSON_IsFalse(jSON1)) &#123; tmp = false; jSONStructP[i].pData = &amp;tmp; jSONStructP[i].type = JSON_BOOL; &#125; else if(cJSON_IsTrue(jSON1)) &#123; tmp = true; jSONStructP[i].pData = &amp;tmp; jSONStructP[i].type = JSON_BOOL; &#125; else if(cJSON_IsNumber(jSON1)) &#123; jSONStructP[i].pData = &amp;jSON1-&gt;valuedouble; //这里无法判断int还是double,统一为double jSONStructP[i].type = JSON_DOUBLE; &#125; else if(cJSON_IsString(jSON1)) &#123; //为&apos;\0&apos;也分配空间，否则字符串结束后跟着乱码 jSONStructP[i].pData = (char *)malloc(strlen(jSON1-&gt;valuestring)+1); strcpy((char *)jSONStructP[i].pData,jSON1-&gt;valuestring); jSONStructP[i].type = JSON_STRING; &#125; else &#123; DEBUG_CUSTOMERR(&quot;json object type error&quot;); return NULL; &#125; &#125; return jSONStructP;&#125; 函数指针实践中常在有中断的情况下使用回调函数。通常在初始化时，将结构体的函数指针成员赋值为函数名(即回调函数名)，则在中断触发时，会调用回调函数。 1234567891011121314151617181920212223242526272829303132333435363738394041e.g串口中断方式处理/* * 信号处理函数,如果收到串口中断，置wait_flag=false * 由于向串口发送数据也会触发信号，因此这里区分串口发送触发的信号和串口接收触发的信号 */void signal_handler_IO(int status)//回调函数&#123; //printf(&quot;recv signal\n&quot;); if(uartSend == false) &#123; waitFlag = false; &#125; else &#123; uartSend = false; &#125;&#125;/* * 注册信号，使用sigaction函数 */void set_signal(int fd)&#123; /*definition of signal axtion */ struct sigaction saio; /*install the signal handle before making the device asynchronous*/ saio.sa_handler = signal_handler_IO;//结构体中的函数指针成员赋值为某函数名 sigemptyset(&amp;saio.sa_mask); //saio.sa_mask = 0; 必须用sigemptyset函数初始话act结构的sa_mask成员 saio.sa_flags = 0; saio.sa_restorer = NULL; sigaction(SIGIO,&amp;saio,NULL); /* allow the process to recevie SIGIO*/ fcntl(fd,F_SETOWN,getpid()); /* Make the file descriptor asynchronous*/ fcntl(fd,F_SETFL,FASYNC);&#125; 此外，在许多开源代码中也有函数指针的使用。例如mosquitto中客户端的一些回调函数，在设置回调函数的函数中为结构体的函数指针成员初始化赋值为函数名。在恰当的时候调用回调函数。1234567891011121314151617181920212223242526272829303132e.g mqtt 客户端连接过程回调函数的使用void my_connect_callback(struct mosquitto *mosq, void *obj, int result)//回调函数&#123; int i; struct mosq_config *cfg; assert(obj); cfg = (struct mosq_config *)obj; if(!result)&#123; for(i=0; i&lt;cfg-&gt;topic_count; i++)&#123; mosquitto_subscribe(mosq, NULL, cfg-&gt;topics[i], cfg-&gt;qos); &#125; &#125;else&#123; if(result &amp;&amp; !cfg-&gt;quiet)&#123; fprintf(stderr, &quot;%s\n&quot;, mosquitto_connack_string(result)); &#125; &#125;&#125;int main(int argc, char *argv[])&#123; …… mosquitto_connect_callback_set(mosq, my_connect_callback);//设置回调函数的函数 …… rc = mosquitto_loop_forever(mosq,-1,1); //处理数据收发&#125;void mosquitto_connect_callback_set(struct mosquitto *mosq, void (*on_connect)(struct mosquitto *, void *, int))&#123; pthread_mutex_lock(&amp;mosq-&gt;callback_mutex); mosq-&gt;on_connect = on_connect;//结构体中的函数指针成员赋值为某函数名 pthread_mutex_unlock(&amp;mosq-&gt;callback_mutex);&#125; 说明： 这里只是追溯回调函数的使用，对于mosquitto源码的实现原理另作讨论。 通过ctags工具逐层追溯，可以看到mosquitto_loop_forever()=&gt;mosquitto_loop()=&gt;mosquitto_loop_read()=&gt;_mosquitto_packet_read()=&gt;_mosquitto_packet_handle()=&gt;_mosquitto_handle_connack()=&gt;mosq-&gt;on_connect() ,最终可以找到回调函数的调用，从而能够顺利找到对应的回调函数执行。 在mosquitto_loop()函数中会调用select函数，从而引发后续操作。 参考文档：MQTT C Client实现消息推送（入门指南） MQTT 嵌入式 C语言 客户端libemqtt源码解析 mqtt-client回调方法简介 MQTT libmosquitto源码分析 个人观点 函数指针和指针函数是在实践中使用较多的，应该重点掌握。 与此相关的函数的参数传递和返回值也需要考虑使用场合。 函数相关的参数传递，返回值等应该结合作用域、链接属性、存储模型等内容一起分析。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>指针</tag>
        <tag>函数</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap使用小坑]]></title>
    <url>%2F2017%2F11%2F26%2FHashMap%E4%BD%BF%E7%94%A8%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[HashMap是java中最常用的集合工具类之一，同时HashMap在使用过程中也有很多小坑，稍不注意可能会引起重大问题，下面稍作总结 隐患的泛型case回放1234567891011121314151617181920212223242526public class MapGeneric &#123; static class Apple &#123; &#125; static class IPhone &#123; &#125; public static void main(String[] args) &#123; Map&lt;String, List&gt; map = new HashMap&lt;String, List&gt;(); List&lt;Apple&gt; appleList = new ArrayList&lt;Apple&gt;(); appleList.add(new Apple()); map.put("appleList", appleList); map.get("appleList").add(new IPhone()); for (Apple apple : appleList) &#123; &#125; &#125;&#125; 执行这段代码，会抛出java.lang.ClassCastException异常。 case分析代码逻辑比较简单，重点在第n行map.get()方法返回的List未指定具体类型，因此后面add()方法可以添加一个IPhone，程序可以正常执行。但是此时的appleList里面包含了Apple和IPhone两种对象，再次使用appleList便出现了问题。 case总结使用泛型时，请务必明确指定各类型；复杂数据结构请使用Object，别再List和Map嵌套了好吗。 飙升的CPUcase回放某次上线后，开始收到CPU过高的报警，通过top和stack分析查看，发现有两个线程一直在执行HashMap.put()方法。用以下代码复现12345678910111213141516171819202122232425262728293031public class MapResize &#123; public static void main(String[] args) throws Exception &#123; final Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(16); final String value = ""; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt; 100000; i++) &#123; map.put(i, value); &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 100000; i &lt; 200000; i++) &#123; map.put(i, value); &#125; &#125; &#125;); thread1.start(); thread2.start(); Thread.sleep(1000 * 5); &#125;&#125; stack信息如下1234567891011"Thread-1" prio=5 tid=0x00007fb66308c000 nid=0x4c03 runnable [0x0000000119989000] java.lang.Thread.State: RUNNABLE at java.util.HashMap.put(HashMap.java:494) at MapResize$2.run(MapResize.java:24) at java.lang.Thread.run(Thread.java:745)"Thread-0" prio=5 tid=0x00007fb66308b000 nid=0x4a03 runnable [0x0000000119886000] java.lang.Thread.State: RUNNABLE at java.util.HashMap.put(HashMap.java:494) at MapResize$1.run(MapResize.java:15) at java.lang.Thread.run(Thread.java:745) case分析罪魁祸首是resize()方法导致，HashMap(1.7)中resize源码如下12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; 其中引用的transfer()方法源码如下123456789101112131415void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 在for循环中，转移节点时出现了并发问题，从而导致了死循环的出现。具体细节网上已有多篇文章详述。 case总结使用HashMap时，尽量设置合理的初始size，减少resize次数；并发多的话使用ConcurrentHashMap吧。 灾难的OutOfMemoryErrorcase回放如果没有合理的监控，resize导致的CPU飙升问题很难发现。但是如果不及时解决，很可能会导致OutOfMemoryError的发生。复现代码如下123456789101112131415161718192021222324252627282930313233public class MapResize &#123; public static void main(String[] args) throws Exception &#123; final Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(16); final String value = ""; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt; 100000; i++) &#123; map.put(i, value); &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 100000; i &lt; 200000; i++) &#123; map.put(i, value); &#125; &#125; &#125;); thread1.start(); thread2.start(); Thread.sleep(1000 * 5); System.out.println(map); &#125;&#125; 代码只比上面的多了一行print。 case分析上面说到resize会导致死循环，那map的容量应该是有限的呀，怎么会OutOfMemoryError呢？看一下HashMap的源码，并没有toString()方法，默认继承了AbstractMap的toString()方法，AbstractMap的toString()源码如下12345678910111213141516171819public String toString() &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (! i.hasNext()) return "&#123;&#125;"; StringBuilder sb = new StringBuilder(); sb.append('&#123;'); for (;;) &#123; Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? "(this Map)" : key); sb.append('='); sb.append(value == this ? "(this Map)" : value); if (! i.hasNext()) return sb.append('&#125;').toString(); sb.append(',').append(' '); &#125;&#125; 看到for循环和i.next应该能确定了，根本原因还是上述死循环导致，在这里不停地拼接字符串，最后导致了OutOfMemoryError。 case总结使用HashMap时，设置合理的初始size！！2的n次方！！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--4数组与指针]]></title>
    <url>%2F2017%2F11%2F26%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍了数组和指针相关的知识点，并分析了二者之间的联系和区别。此外还介绍了一些特殊情况：空指针、void 指针、const修饰指针。最后针对实践中常用的字符串，总结了其使用的注意事项。 数组数组基础数组的特点 数组元素类型一样。 存储空间连续。区别于链表。 数组名是数组的起始位置，是地址常量。 注意事项 对数组名求sizeof，结果是整个数组的占用总空间，数组个数=sizeof(数组名)/sizeof(数据类型)。 数组名是地址常量，则说明不能对其做自增自减，改变其值。 数组元素的数据类型可以是基本类型也可以是构造类型。因此有字符数组、指针数组、结构体数组等，后续相关部分有详细介绍。 方括号中的常量表达式在定义就必须确定，而不能随着程序运行而改变。 数组定义、初始化、引用定义1&lt;存储类型&gt; &lt;数据类型&gt; &lt;数组名&gt;[数组元素个数] 初始化 全部元素初始化时，方括号中个数可省略不写。 数组全部初始化为0的几种方法：123int a[10]=&#123;0&#125;;int a[10];memset(a,0,sizeof(a));int a[10];bzero(a,sizeof(a)); 引用1&lt;数组名&gt;[下标] 说明： 数组必须逐个元素引用，不能整体引用。所以在定义完毕后如果需要赋值，必须一个一个赋值，可以使用for循环。而不能写int a[3];a[3] = {1,2,3}; 注意数组下标越界，相当于内存访问越界，造成的结果无法估量。不确定会产生什么后果，这取决于越界访问的内存空间是否是空闲以及访问是读还是写。 二维数组 二维数组的定义、引用、初始化类似于一维数组。 二维数组的存储是按行优先顺序存储的，也是存储在连续的空间。 初始化时可以省略第一个方括号中的数字。 对于二维数组元素或者元素地址的各种变形，要从本质上理解其含义，以a[2][3]为例： a是二维数组名，是地址常量。a+1表示移动一行。a+1表示第二行的地址。 a[0]、a[1]等是一维数组名，也是地址常量。a[0]+1表示移动一列，a[0]+1表示第一行第二列的地址，即&amp;a[0][1]。 指针指针基础基本概念 在计算机中，所有的数据都存放在存储器中，将存储器中的一个字节称为一个内存单元，不同的数据类型占有不同的内存单元数量。比如整型占4个内存单元(即4个字节)。 为了正确的访问内存单元,必须为每个内存单元编号,根据每个内存单元的编号就可以找到该内存单元。内存单元的编号也叫地址,而又称这个地址为指针。 内存单元的指针(地址)和内存单元的内容（具体存放的变量）是两个不同的概念。指针指向的内存区域的数据称为指针的目标，如果指向的区域是一个变量的内存空间，则这个变量称为指针的目标变量。 使用指针的好处 使程序简洁、紧凑、高效。 有效地表示复杂的数据结构。 实现动态分配内存。 得到多于一个函数返回值。 注意事项 理清各个概念的本质。是变量还是常量，是指针还是数据，指针是变量还是常量，所指向的目标是变量还是常量。 实践中建议画图标明指向关系。在程序出错时，也要从本质上分析原因。 使用示例：123px 表示指针变量，内容是地址变量。*px 表示指针指向的目标，内容是数据。&amp;px 表示指针变量占用存储区域的地址，内容是地址常量。 指针定义、初始化、引用定义1&lt;存储类型&gt; &lt;数据类型&gt; *&lt;指针变量名&gt; 说明： 定义时，将星号写在靠近变量名的一侧，而不是靠近数据类型。 这里的数据类型是指指针指向的目标的数据类型。 初始化12345&lt;数据类型&gt; *&lt;指针变量名&gt;=&lt;地址量&gt;int *p = &amp;m;或者int m,*p;p=&amp;m; 说明：未经赋值的指针变量不能随便使用。例如：int *p;*p=50;这是错误的，没有对指针进行初始化，指针随机指向一个内存单元，这样的指针成为野指针，代码在执行时会出现segmentation fault，访问了一个非法地址。在对指针变量进行间接引用前必须确保它们已经指向了一个合法的对象。 引用 对指针的引用使用*。*叫做指针运算符或者叫间接存取运算符。通过指针访问它所指向的对象叫做变量的间接访问。 &amp;是取地址运算符，和*互为逆运算。 注意：将一个变量的地址赋值给指针，那就意味着指针所指向的内存单元就是存储该变量的内存单元。无论是改变指针所指向的内存单元的内容还是直接改变变量的值，都会有相同的效果。 使用示例：1234int a,*p;a = 1;p = &amp;a;*p=2; 该例中a的值也会有变化，这是通过指针改变了变量的值。因此才会有如果不希望通过指针改变变量的值，那么使用const修饰。 指针运算指针的运算是指以指针变量所存放的值作为运算量而进行的运算。指针的运算就是地址的运算。 算术运算 +、-、++、--，表示移动一个或多个单位长度，单位长度是指数据类型所占字节数。因此其值的改变为数据类型所占字节大小乘以1或n。 两指针相减：结果为一个整数，而不是地址量，表示两指针相隔的数据个数。 关系运算：比较少用。多用if(px != NULL)和空指针进行比较。或者两个指针一起向中间移动时，会比较两个指针。 赋值运算 对指针赋值使用&amp;，和*互为逆运算。多个运算符在一起要注意优先级。 *p++ 表示*(p++)，表达式的值是取原p指向的对象值，然后p移动一个位置。 *++p 表示*(++p)，表达式的值是p移动一个位置后，再取其指向的对象值。 sizeof运算符：sizeof(px)，任何类型的指针变量求sizeof，大小始终是4或者8字节，是由计算机系统位数决定，和类型无关。 二级指针 二级指针是指向一级指针变量的指针变量，即指针指向的目标是指针。 定义：&lt;存储类型&gt; &lt;数据类型&gt; **&lt;指针名&gt; 二级指针的运算，和一级指针类似，理解本质即可。++，--也是移动单位长度，这里的单位长度是指针类型的长度，则是4字节或者8字节。另外，用sizeof对二级指针运算，同样是4字节或者8字节。 使用示例：12345678910e.g1:字符指针数组名赋值给字符二级指针char *p[5]=&#123;&quot;beijing&quot;,&quot;tianjin&quot;,&quot;shanghai&quot;,&quot;sichuan&quot;,&quot;liaoning&quot;&#125;;char **pp=p;e.g2:指针数组名赋值给二级指针int a[2][3];int *p[2];p[0]=a;p[1]=a+1;int **q = p; 特殊指针空指针 空指针是指指针变量为0的指针，表示为NULL。表示目前尚未指向任何对象。 用处：(1)在需要返回指针时，如果失败常常返回NULL。(2)在指针定义时，常常初始化为NULL。 修改0地址的值或者进行间接引用操作都是不允许的，会出现段错误。 如果指针初始化为NULL，后又访问或者修改该地址的内容，则一定会出现段错误，所以可以分析出原因：是由于指针指向的对象不明确造成的。 一般在对指针进行引用前，应该先判断指针是否为空。 void指针 void指针是指向不明确数据类型的指针变量。这是空类型指针，区别空指针概念。 不确定数据类型表示只知道目标的起始位置，但是不知道目标的大小，即占用字节数。 void指针可以指向任何类型的数据，那么任何类型的指针可以赋值给void指针，不需要强制类型转换。但是反过来，void指针赋值给某一具体类型的指针变量，则需要强制类型转换。 在引用void指针的目标值时，需要进行强制类型转换。 void指针的运算，ANSI C和GNU C规定不一样。ANSI C规定不允许对void指针进行运算，而GNU C可以。 使用场合：使用任意类型的指针的场合，比如函数参数传递，函数返回值。例如作为一种函数模板，适用于多种情况。 扩展知识：void也是一种数据类型，空类型。void不能定义变量。void的作用是(1)对函数返回做限定。(2)对函数参数做限定。 使用示例：12345678910e.g1:给某个指针动态分配内存，malloc需要强制类型转换void *malloc(size_t size);int *p;p = (int *)malloc(sizeof(int)*n);e.g2:内存拷贝函数，任何类型的指针都可以使用。也符合内存拷贝的本质，与类型无关。void *memcpy(void *dest, const void *src, size_t n);char a1[5]=&#123;0&#125;;char b1[]=&#123;&quot;hi&quot;&#125;;memcpy(a1,b1,sizeof(b1)); 参考文档：void指针详解void及void指针含义的深刻解析void指针用法 const修饰指针 const int *a：常量化指针指向的对象，不予许通过指针修改指向的对象，但可以直接修改变量。 int * const a：常量化指针变量，只能指向同一个对象，指针变量的值不能改变，但是可以通过指针改变对象的值。 const int * const a：常量化指针变量和目标表达式，既不能通过指针修改指针所指向的变量的值，也不能修改指针变量的地址。 注意： 强行修改会报错：assignment of read-only location …… const声明的变量必须在初始化时赋值，后面再赋值，则会报错。 使用示例：1234567e.g1:char *strcpy(char *dest, const char *src);这里加const是为了不予许在函数内，通过*src修改原字符串的内容。e.g2:int main(int argc,const char *argv[])这里的形参char *argv[]可以理解为char **argv。const限制*argv[]不能变，即不能通过指针改变字符串。而argv[1]和argv都是可变的。 参考文档：读懂C语言const限定以及复杂定义C语言中strcpy字符串复制库函数的理解与分析 指针与数组由上面内容可知，指针和数组有很多相似之处。要从本质上理解区分指针和数组。在C语言中指针的效率往往高于数组下标。编译器对程序中数组下标操作会全部转换为对指针的偏移量操作。 数组指针数组指针是指向数组起始位置的指针，本质是指针。实践中多指指向二维数组的指针。 指针与一维数组 数组在内存中的位置在运行过程中不能动态改变。数组名不允许被赋值。 数组的指针是地址常量，而指针变量是地址变量。 *运算符称之为指针解引用，即根据地址获取地址里的内容。[]运算符称之为下标运算，表示指针移动n个单位长度后取内容。 使用示例：12345int a[5];int *p = a;则有数组元素表示：*(p+i)&lt;=&gt;p[i]&lt;=&gt;a[i]&lt;=&gt;*(a+i)数组元素地址表示：p+i&lt;=&gt;&amp;p[i]&lt;=&gt;&amp;a[i]&lt;=&gt;a+i 指针与二维数组访问二维数组元素的方法有： 列指针（一级指针），利用顺序存储的特点访问。 行指针。定义：存储行地址的指针称为行地址。加1表示移动一行。格式：&lt;存储类型&gt; &lt;数据类型&gt; (*&lt;指针变量名&gt;)[表达式]注意：方括号的表达式表示指针加1，移动几个数据，用行指针操作二维数组时，代表一行的个数，即列数。 一级指针数组。定义指针数组操作二维数组时，指针数组的个数应该为二维数组的行数。 二级指针。注意：二级指针的初始化在这里必须赋值为指针数组名，而不是二维数组名，否则不知道如何偏移。 使用示例：123456789101112131415161718192021222324252627282930313233int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//访问二维数组元素//数组方式//a[1][2];printf(&quot;%d %d %d\n&quot;,a[1][2],*(a[1]+2),*(*(a+1)+2));//列指针访问int num = sizeof(a)/sizeof(int);int row = sizeof(a)/sizeof(a[0]);int col = num / row;int *pcol = &amp;a[0][0];printf(&quot;%d\n&quot;,*(pcol+1*col+2));//行指针访问int (*prow)[3];prow = a;printf(&quot;%d\n&quot;,*(*(prow+1)+2));//指针数组访问int *parray[2];parray[0] = a[0];parray[1] = a[1];printf(&quot;%d\n&quot;,*(parray[1]+2));//二级指针访问int **psec;//psec =a;//对二级指针赋值，是指针数组名，而不是二维数组名，否则psec+1不知道如何偏移psec = parray;printf(&quot;%d\n&quot;,*(*(psec+1)+2));//访问二维数组元素的地址printf(&quot;%p %p %p\n&quot;,&amp;a[1][2],a[1]+2,*(a+1)+2);printf(&quot;%p %p %p %p\n&quot;,pcol+1*col+2,*(prow+1)+2,parray[1]+2,*(psec+1)+2); 注意：a[i]和*(a+i)是完全等价的，不管a是数组名还是指针，因此示例中可以按照此规则等价转换书写更多的形式。 指针数组指针数组：本质数组，数组名相当于多级指针。指针数组的数组名是数组的起始地址。 使用示例：12345678910111213e.g1:访问二维数组int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;int *parray[2];parray[0] = a[0];parray[1] = a[1];e.g2:字符指针数组int main(int argc,const char *argv[])这里是指针数组做形参，相当于同级别的指针。char *fruit[3]=&#123;&quot;apple&quot;,&quot;pear&quot;,&quot;grape&quot;&#125;; 字符串、字符数组、字符指针关于字符串的使用，涉及字符数组和字符指针。数组和指针前面已经介绍，数组和指针使用的注意事项，字符数组和字符指针同样应注意。除此之外，重点理解字符串的特殊之处即可。 字符串定义字符串是由’\0’作为结束符的一组字符，用字符数组表示。 字符串常量在程序中使用字符串常量会生成一个“指向字符串的常指针”。当一个字符串常量出现在一个表达式中，表达式所引用的值是存储该字符串常量的内存首地址，而不是字符串本身。 字符串处理函数字符处理函数常用的有strlen、strcpy、strcmp、strcat、strtok。以及带有长度限制的对应函数，例如strncpy等。这些函数需要熟练使用，这在Linux应用程序开发中有使用。说明： 每一个函数的具体用法参见man手册。一定要理解各个函数的含义，尤其是特殊处理。 strlen统计字符长度，不带’\0’。 strcpy不会做越界检查，需自己保证长度合适。而strncpy不保证最后一个字符是’\0’。 strtok功能是分割字符串，会破坏原有字符串完整性，如果要想保持不变，使用strchr和sscanf组合代替。 参考文档:C语言字符串使用注意事项常见字符串处理函数梳理及分析 C语言字符串操作总结大全(超详细)C语言中strcpy字符串复制库函数的理解与分析 字符数组 字符数组是有一定顺序关系的若干字符变量的集合。可以是一维的也可以是二维的。字符数组具有普通数组的性质，又有其特殊性。 初始化：可以使用逐个赋值，也可以使用字符串常量。 1234char str[6]=&#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos;\0&apos;&#125;;char str[6]=&quot;hello&quot;;char str[]=&quot;hello&quot;;char fruit[][7]=&#123;&quot;apple&quot;,&quot;orange&quot;,&quot;grape&quot;&#125;; 注意： 用字符串赋值比用字符逐个赋值多一个字符，所以通常用字符串赋初值时，不写数组长度。 如果希望字符数组表示字符串，那么字符逐个赋值时，应该额外在最后手动添加’\0’。即a[strlen(s)]=’\0’。 字符数组一定不能越界访问。如果定义了数组长度N，输入时只能输入N-1个字符。 字符数组名同样也是地址常量，不能自增自减改变其值。 字符指针 字符指针就是指向字符类型对象的指针。如果字符指针指向字符串，则存储字符串的起始地址，即指针指向字符串的第一个字符。 初始化：可以赋值为字符数组名，也可以使用字符串常量。 12char str[]=&quot;hello&quot;;char *p = str;char *p=&quot;welcome&quot;; 注意： 初始化字符指针是把内存中字符串的首地址赋予指针，并不是把字符串复制到指针中。而字符串本身存储在内存的其他地方。 char *p=”welcome”;相当于const char *p=”welcome”;因此按照const修饰指针的规则，则不能通过指针修改字符串的内容，会引起段错误。但是指针本身可以改变，p++是允许的。 字符指针作为形参，函数内判断字符串是否达到结尾，通常使用while(*s == ‘\0’)，而不用其长度判断。 获得字符串长度，通常使用strlen，而不能对字符指针求sizeof，因为其代表的是指针占内存空间大小。如果对字符指针求sizeof控制长度，打印时会导致字符串打印不全。 如果给指向字符串的字符指针动态分配空间时，也应该是strlen(s)+1，因为要给’\0’提供一个位置。否则在打印时会导致字符串打印完全后还跟着乱码字符。 参考文档C语言字符串指针（指向字符串的指针）c中给字符数组，字符串指针赋值的方法总结 字符指针数组 字符指针数组即是在数组中存储若干个字符串首地址。 字符指针数组的数组名是代表数组的起始位置，而数组元素是字符指针，因此数组名是指针的地址，即为二级指针，因此使用二级指针操作。 使用示例： 12char *p[5]=&#123;&quot;beijing&quot;,&quot;tianjin&quot;,&quot;shanghai&quot;,&quot;sichuan&quot;,&quot;liaoning&quot;&#125;;char **pp=p;//(用二级指针承接指针数组名) 个人观点 理解每一个概念的本质含义。从本质上去理解每一个知识点的使用方法和注意事项。 当出现多个名词组合在一起时，学会分解，从简单组合到复杂。 对数组和指针的掌握程度是熟练使用。此外建议通过读经典源码，了解通用写法。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--3Make]]></title>
    <url>%2F2017%2F11%2F23%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--3Make%2F</url>
    <content type="text"><![CDATA[本篇文章围绕GNU make介绍了make工程管理器相关知识，包括Makefile基本结构、变量、规则的使用，以及一些相关问题：伪目标、文件搜索、嵌套执行make、Makefile函数的使用。最后结合实践情况，对一些Makefile文件做了简要分析，并介绍了autotools和cmake两种自动生成Makefile的工具。 make简介 make工程管理器，它是一个自动编译管理器，“自动”是指它能够根据文件时间戳自动发现更新过的文件，只编译改动的代码文件，而不是全部编译，从而减少工作量。make可以提高项目开发和维护的工作效率。 Makefile是make读入的唯一配置文件。 可以理解为makefile里面是大量的gcc命令。使用Makefile可以减少多个文件编译时一遍一遍输入gcc命令。只不过Makefile有其自己的语法格式。 这里是总结GNU make的知识。而其他厂商的make与之类似。 Makefile基本结构使用make工程管理器，也就是编写Makefile文件。Makefile文件由三部分组成：（1）目标体：通常是可执行文件、目标文件、标签。（2）创建目标体所依赖的文件。（3）创建每个目标体需要运行的命令。 Makefile格式：123target:dependency_files&lt;tab&gt; command&lt;tab&gt; …… 说明： Makefile的工作原理：如果dependency_files比target新或者target不存在，那么就会执行command指令。 目标和依赖是Makefile中的主要构成。而目标和依赖的关系是通过规则表达，即命令。 一个Makefile可以定义多个目标，调用make命令时需指明目标，如果未指明时，默认生成第一个目标。 如果依赖也是目标，那么make会按从左到右的顺序先构建规则中依赖的目标，再构建目标。Makefile只检查依赖关系，如果依赖的文件找不到则会退出。 注意命令前tab键的使用。Makefile以tab键区分是否是命令，不能以多个空格代替。 command不一定是编译链接等命令，可以是任意可以运行的命令以及make定义的函数。 一个规则可能包含多条命令。一个规则也可以包含多个目标。 在Makefile文件中除了有规则、变量定义还有文件指示和注释。文件指示包括：在一个Makefile中包含另一个Makefile；指定Makefile的有效部分，即条件判断；定义一个多行的命令。而注释是以#开头。 包含其他Makefile，可以使用include filename，其中filename可以包含路径和通配符。 使用cc -MM xxx.c命令可以输出文件的依赖关系，并生成一条依赖语句。 变量使用 在Makefile中使用变量的目的就是代替一个文本字符串，作用类似于宏。比如系列文件的名字、传递给编译器的参数、运行的程序、查找源代码的目录。使用变量可以增加Makefile的可维护性。 在Makefile文件中定义的变量相当于全局变量，如果要定义局部变量，可以定义在目标之后或者模式（%）之后，则变量会只作用于由这个目标引发的所有规则。 定义变量的两种方式 递归展开方式 1VAR=var 一次性将内嵌的变量全部展开，但不能在变量后追加内容，可能导致无穷循环。 简单扩展方式 1VAR：=var 在定义处展开，且只展开一次。前面的变量不能使用后面的变量，只能使用前面定义好的变量。 使用变量1$(VAR) 使用说明: 变量大小写敏感。 推荐使用小写字母作为变量名，预留大写字母作为控制隐式规则参数或用户重载命令选项参数的变量名。 实践中常会用到+=，为定义的变量添加新的值。 变量的替换(1) $(var:a=b) 将var变量中以a结尾的字符串替换为b。(2) 使用静态模式 $(var:%a=%b)。 override指示符的作用：如果变量是通过命令行参数设置，要在Makefile中设置其值，需要使用override。 定义空格可以写为：12empty:=space:=$(empty) $(empty) 变量的种类 自定义变量 预定义变量 自动变量 $@目标文件完整名称，在模式规则中， 可以匹配目标中模式定义的集合。 $^所有不重复的目标依赖文件。 $&lt;第一个依赖文件名称，在模式规则中，是将符合模式的文件挨个取出。 环境变量make在启动时会自动读取系统当前已经定义的环境变量，并创建与之相同的变量，若在Makefile中定义了相同名称的变量，则会覆盖同名的环境变量。 类似于全局变量和局部变量的关系。最好不要使用环境变量MAKEFILES,否则会影响使用make。 规则说明 Makefile的规则包括目标体、依赖文件和其间的命令语句。这称为显式规则，即显示的说明了如何生成一个或多个目标文件。除此之外，还有隐式规则和模式规则。 规则包含两个部分：一个是依赖关系，一个是生成目标的方法。Makefile中只应该有一个最终目标，第一条规则中的目标被确立为最终的目标，所以顺序很重要。 隐式规则 隐式规则告诉make如何按照约定俗成的方法完成任务，只需把目标文件列出即可，不需要指定编译的具体细节。 使用隐含规则生成目标，make会自动推导这个目标的规则和命令。 在隐含规则库中，每一条规则都在其库中有顺序，位置靠前的规则容易被使用，为了避免依赖无效，则必要时需要显示写出执行的命令，不能省略。 常见的隐式规则有：123.c变成.o 使用$(CC) -c $(CPPFLAGS) $(CFLAGS).cc变成.o 使用$(CXX) -c $(CPPFLAGS) $(CXXFLAGS).o生成目标 使用$(CC) $(LDFLAGS) xxx.o $(LOADLIBES) $(LDLIBS) 说明： 其余隐式规则详见《跟我一起写Makefile:隐含规则》。 隐式规则中使用的是系统设定的变量，用户可以在Makefile中修改这些变量的值，只要设置了其值，那么就会对隐式规则起作用。 关于隐含规则链，一个目标可能被多条隐含规则作用。make会尽一切可能生成目标，其中可能生成中间文件，这种方式生成的中间文件在生成目标后会使用“rm -f”删除。 模式规则 模式规则用来定义对多个文件使用相同处理规则。隐式规则仅能使用make默认的变量进行操作，但模式规则可以引入用户自定义变量，简化Makefile的书写。 模式规则在目标定义中需加上”%”符号，”%”表示一个或多个任意字符。目标必须是这种形式，否则成为一般的规则。 依赖中也可以使用“%”符号，但是其值取决于目标。 使用示例：12%.o:%.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@ 补充：静态模式，可以容易的定义多目标的规则。其定义和模式规则类似，格式如下：12target:target-pattern:prereq-pattern&lt;tab&gt;commands 其中target为一系列目标，target-pattern是目标集模式，prereq-pattern是目标的依赖模式。使用示例：1234objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 相关问题伪目标使用.PHONY关键词定义伪目标，作用是防止文件夹中有和目标相同名字的文件，执行make指令不产生预期的动作。例如clean目标，可以认为是一个标签，不依赖任何文件。因此可以在Makefile中定义一些和编译无关的命令，比如程序的打包、备份、删除等。 使用示例：123.PHONY:cleanclean: rm xxx *.o 说明： 通常clean规则写在文件最后。需要显示使用make clean执行相应功能。 这里使用了通配符“*”，make支持“*“、”?”、”~”三种通配符。 如果要一次生成多个可执行文件，可以使用all伪目标，用伪目标作为默认目标。 伪目标也可以作为依赖，用于完成不同的功能，详见《跟我一起写Makefile:书写规则》。 文件搜寻使用VPATH完成文件搜索。如果Makefile文档中定义了VPATH变量，那么make会在当前目录找不到的情况下，到指定的目录中寻找文件。 使用示例：1VPATH=src:../header 说明： make会按照这个顺序进行搜索，多个路径由冒号分割。 还可以使用vpath(小写字母)关键词定义，详细使用方法详见《跟我一起写Makefile:书写规则》。 命令的书写这里总结几条书写命令时的注意事项： make的命令默认使用/bin/sh解释执行。 如果在使用make时不希望打印命令，则在Makefile中命令前加上@。 如果要执行两条命令，第一句的命令结果要应用于下一条命令，必须用分号分割，而不能写在两行。 在Makefile中可以为相同的命令序列定义一个变量，注意不可以和变量重名。使用方法和变量类似，执行命令时，其包裹的每条命令都会执行。使用示例：1234define two-lines echo foo echo $(bar)endef 嵌套执行make 在大的工程中，不同模块或功能的源文件放在不同的目录中，每个目录都可以书写一个该目录下的Makefile。最外层的Makefile称为总控Makefile。 如果要传递变量到下级Makefile中，使用export xxx，如果要传递所有，使用一个export即可。其具体使用详见《跟我一起写Makefile:书写命令》。 在实践中，通常有很多源码，每个文件夹都有Makefile,上级目录中的Makefile会逐级调用下层的Makefile。具体情况需结合实例分析。 使用make -C指定进入下层Makefile时，-w参数自动打开，则可以在make执行时看到进入哪个目录，离开哪个目录。 使用示例:1set -e; for d in $(DIRS); do $(MAKE) -C $$&#123;d&#125;; done 使用条件判断使用条件判断，可以让make根据不同的情况选择不同的分支执行。格式如下：12345ifeq (arg1,arg2) 或者ifneq (arg1,arg2) 或者 ifdef xxx 或者ifndef xxx……else……endif 说明： arg可以是make函数。 ifdef只是判断变量是否为空，非空为真，空为假。 Makefile函数在Makefile中使用函数处理变量，可以增加其灵活性。函数的返回值可以作为变量使用。包括字符串处理函数，文件名操作函数，foreach，if，call，shell函数等，具体使用详见《跟我一起写Makefile:使用函数》。 格式如下：1$(function arguments) 函数名和参数用空格隔开，变量之间用逗号隔开。 常用的函数总结如下：1234567891011121314151617addprefix 给字符串中每一个子串加上一个前缀。$(addprefix prefix,names)filter 从字符串中根据模式得到满足模式的字符串，返回匹配的。$(filter pattern,text)filter-out 从字符串中根据模式滤出某些字符串，返回不匹配的。$(filter-out pattern,text)wildcard 通配符，相当于*，pattern举例：*.c$(wildcard pattern)patsubst 模式字符串替换,相当于变量替换的功能。$(patsubst pattern,replacement,text)shell函数执行shell命令，和`xxx`是同样的功能。 make 使用make命令 make命令执行后会有三个退出码。0表示成功执行，1表示运行时出现任何错误。2表示某些目标不需要更新，make需要使用-q选项。 make最终目标是Makefile中的第一个目标。可以指定make的目标，只需在make命令后跟上目标的名字即可。目标可以是真实的目标，也可以是伪目标。 通常开源软件发布的Makefile中都包括编译、安装、打包等功能。例如有all、clean、install、tar、dist、test等目标。具体要结合具体的Makefile分析。 因此，可以使用make xxx，make clean，make install等完成不同的功能，如果只写make,则默认建立Makefile中第一个目标。 make 常用参数12345-C dir 读入指定目录下的Makefile。-f file 读入当前目录下file文件作为Makefile。-n 模拟执行，打印要执行的命令，但不执行。可以用于调试Makefile，查看其执行顺序。-j 同时运行命令的个数，-j2表示以两个线程编译。-i 忽略所有命令执行错误，也可以在Makefile中command前加上短横线。 更多的参数详见《跟我一起写Makefile：make运行》。 应用实例 在实践中，通常会用到第三方的开源库或者SDK包，因此涉及第三方库的移植，若是源代码，那么需要修改其自带的Makefile，使其适合目标平台，再进行配置编译工作。该部分内容另作讨论研究。这里只对使用第三方库过程中的Makefile做简单分析。 此外，在开发者自己编写模块或者软件包时，可以采用系统内核规定的方式，将软件包作为内核的一部分进行编译。也可以放在内核之外，使用内核的Makefile文件编译为模块，使用时再进行动态加载。这里也做简要分析。 最后，实践中也经常使用工具来自动生成Makefile,例如autotools和cmake工具，开发者只需按照规定填充源文件的相关信息。 第三方开源库或SDK使用中的Makefile分析openwrt使用opencv库Makefile分析在js9331开发板上做图像处理，需要openwrt移植opencv库。具体移植的方法在后续第三方库移植专题中再做深入研究。这里只对其测试代码的Makefile做一分析。 Makefile说明： Makefile代码详见gist。 使用命令时，可以添加命令行参数，例如export prefix=xxx; make install。 opencv的应用程序一般使用c++编写，如果移植到openwrt平台，涉及到c和c++程序的混合编译，使用注意事项详见《c语言高级编程-2搭建交叉编译环境》。 参考文档：用OpenWrt package方式编译OpenCV openwrt-packages/wrtnode/opencv-test/src/Makefile ubuntu使用海康威视SDK包Makefile分析海康威视摄像头提供linux版本的SDK包，供开发者进行二次开发。其中涉及到Makefile文档，对其进行简要分析。 Makefile说明： Makefile代码详见gist。 gcc选项-W……，用于不同错误的警告提示。 Makefile函数的使用，比如subst，foreach，wildcard，dir，notdir，patsubst，addprefix等。 VPATH的使用，用于文件搜索。 对于动态链接库，使用-Wl,-rpath=……选项，表示运行时记住库的路径。 gcc选项，-pipe，用于优化处理。 参考文档：提领类型双关的指针将破坏重叠规则——strict-aliasinggcc中的-Wl,rpath=选项《gcc五分钟系列》第十节：编译期优化选项（一）——pipe 海康威视设备网络SDK_V5.2.7.4(for Linux64) openwrt上onvif开发Makefile分析openwrt平台上进行onvif协议开发和在其他linux平台上类似，只是编译器选为mips-openwrt-linux-gcc。onvif协议客户端开发，使用gSoap开源软件中的WSDL2h和SOAPcpp2工具生成onvif.h和相关的.c源文件进行应用程序开发。具体原理另作研究讨论。 Makefile说明： Makefile代码详见gist。 使用-DDEBUG选项，可以打印onvif通信日志。 使用strip命令，可以对可执行文件瘦身，减小大小，对于嵌入式开发十分必要。 参考文档：onvif开发之设备发现功能的实现Onvif开发之Linux下gsoap的使用及移植 编译自己的模块或软件openwrt编写ipk包Makefile分析openwrt软件安装包一般为ipk后缀的文件，它提供了一种让用户自己生成ipk包的方法。即： 在openwrt源码中，package目录下，新建文件夹A，其中创建Makefile和src文件夹。src文件夹中编写.c、.h源文件和编译的Makefile。或者没有源码文件，在A文件夹下的Makefile中写明获取软件源码的网址。 在文件夹A下的Makefile是一种编写模板，其提供了该软件包的下载、编译、安装的方法。 在步骤2编写完成的Makefile包含了该软件在make menuconfig配置下的位置和信息，因此在openwrt主目录下make menuconfig选中要编译的软件。 在openwrt主目录下运行make V=s。完成后在/openwrt/bin/ar71xx/packages/base目录下可以找到对应的ipk软件包，复制到开发板进行安装即可。 Makefile说明： Makefile代码详见gist，这里选取两个范例，一个是openwrt移植opencv使用该方法，另一个是普通的ipk软件包生成测试。具体含义参见参考文档。 makefile函数的使用，eval和call函数。 参考文档:用OpenWrt package方式编译OpenCVOpenwrt学习之路-(5-Openwrt package Makefile) openwrt简单ipk生成及Makefile解释 iTOP4412/FS4412编写LED灯驱动Makefilelinux驱动编译时，多采用动态编译，即驱动的源代码不放在内核中，因此其Makefile编写有一定讲究。在此简略分析。关于驱动的内容详见后续总结。 Makefile说明： Makefile代码详见gist。 ifeq的使用，执行不同的命令。 make -C指明使用内核Makefile的路径。 参考文档：Linux 驱动开发之内核模块开发 （二）—— 内核模块编译 Makefile 入门 自动生成Makefile的工具对于大型的项目，如果有工具可以自动生成Makefile，那么将提高开发效率。 GNU autotools使用autotools制作Makefile步骤如下： 运行命令autoscan。 修改configure.scan文件，并重命名为configure.ac。 运行命令aclocal。 运行命令autoconf。 运行命令autoheader。 创建文件Makefile.am，并配置内容。 运行命令automake –add-missing。期间缺少的文件自己创建。 运行./configure命令。 运行make命令，得到可执行文件。 说明： make install、make clean、make disk等命令可以使用。 在confiure.ac、Makefile.am文件中填写源文件相关的内容，不需要填写依赖关系等，可以自动生成。 参考文档：Linux c 开发 - Autotools使用详细解读 cmake GNU autotools 是linux系统下常用的自动生成Makefile的工具，而cmake是一款跨平台的安装编译工具。不仅可以生成Makefile，还可以生成Windows visual C++的projects等。 在实践项目中，涉及一些开源软件的使用，比如opencv、mosquitto、paho.mqtt.embedded-c、Azure iot-hub-c-raspberrypi-client-app等。在这些源码中，包含了许多CMakeLists.txt文件。关于如何在自己的程序中使用这些第三方的开源库，在第三方库移植专题中总结。这里只对cmake做一简单介绍，涉及两个方面。 如何编写CMakeLists.txt文件，即理解其语法。常用的语法如下：projet(projectname) 项目名称 add_executable(exename source) 生成可执行文件 set(var value) 设置变量 add_subdirectory(source_dir) 增加源代码目录 add_library(libname source ) 生成链接库 target_link_libraries() 添加依赖的链接库 aux_source_directory(. var) 查找当前目录下源文件并将其保存到var变量中 如何使用cmake命令。cmake PATH PATH是CMakeLists.txt所在的目录 cmake . 在当前目录下运行cmake 注意： CMakeLists.txt中命令不区分大小写。 使用变量时，使用花括号。 参考文档：为什么用CMake大型程序管理神器之CMakeCMake 入门实战cmake 命令行CMake TutorialCMake交叉编译配置 个人观点 本篇文章的Makefile主要参考文档为跟我一起写makefile。 写Makefile时，首先是思考需要表达什么样的依赖关系。而不是先思考如何写规则命令。 对于Makefile的掌握程度，要会写简单的Makefile，用于自己项目管理。要会读懂别人的Makefile，要会根据需要做相应修改。对于一些细节知识仅作了解，理解即可，真正使用时再做分析。 在实践中，由于项目并不大，因此一般自己编写Makefile文件，可使用一份Makefile模板，进行细微修改即可，而不是用cmake或autotools工具。autotools目前只做了解。 目前cmake工具的使用主要用在开源库的使用中，因此需要理解其含义和使用方法。待对cmake有足够了解后，可以对开源库的CMakeLists.txt根据自己需要进行修改。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>make</tag>
        <tag>Makefile</tag>
        <tag>autotools</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--2搭建嵌入式linux编程环境]]></title>
    <url>%2F2017%2F11%2F17%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--2%E6%90%AD%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[搭建嵌入式Linux编程环境，就是搭建C语言编程环境，这是嵌入式系统开发的首要工作。另外在嵌入式Linux系统移植中，也需要首先搭建交叉开发环境。嵌入式开发工具包括编辑器、编译器、调试器、工程管理器等。前面已介绍过VIM编辑器，本篇主要总结gcc编译器和gdb调试器，此外简要介绍GNU Binutils工具集，并给出实践的使用实例。工程管理器make将在下一篇总结。 GNU工具集GNU工具集是包含了GNU项目所产生的各种编程工具的集合。这些工具形成一条工具链，用于开发应用程序和操作系统。ＧNU工具有很多，包括如下： 编译工具：gcc。 调试工具：gdb。 二进制工具集：GNU Binutils,包括链接器、汇编器、格式转换工具等。 软件管理工具：make、CVS、subvision等。 参考文档：gnu工具集GNU工具链（GNU toolchain）gnu工具链简介 GNU Binutilsbinutils工具集主要包括as汇编器和ld链接器，除此之外，还有一些工具(即命令)是开发调试中常用的，此处做一简要介绍。123456789101112131415161718192021readelf -h xxx 查看可执行文件的头部信息，包括系统架构、大小端等信息。elf文件是linux/unix系统下的二进制文件格式。readelf -a xxx 查看可执行文件的所有信息。file xxx 查看文件类型，如果是可执行文件，会显示文件类型、系统架构、大小端、是否strip等信息。size xxx 列出可执行文件每一段的大小和总大小。可显示可执行文件包括text、data、bss等部分。strip xxx 对可执行文件“瘦身”，丢弃目标文件中的全部或特定符号，减小文件体积。对于嵌入式系统，需要使用该命令。不可对中间文件“瘦身”，否则链接出错。nm xxx 查看可执行文件的所有符号。在调试段错误时可以使用，方便定义哪里发生了段错误。objdump -d xxx 对可执行文件进行反汇编，生成汇编代码，在调试段错误也会用到。 objcopy 进行目标文件格式转换 例如：objcopy --gap-fill=0xff -O binary u-boot u-boot.bin,用在uboot移植部分。addr2line 把程序地址转换为文件名和行号，常用于内核调试。注意编译时需加上-g选项，生成调试符号。否则运行addr2line出错。e.ggcc -o test -Wl,-Map=test.map -g test.cgrep main test.mapaddr2line 0x08048368 -e test -f 参考文档：Binutils工具集 解析Linux环境下段错误的产生原因及调试方法小结Linux debug : addr2line追踪出错地址 GCCGCC简介GCC可以编译如C、C++、Java等多种语言，GCC是可以在多种硬件平台上编译出可执行程序的超级编译器，其执行效率比一般的编译器要高20%-30%。在嵌入式领域开发需要交叉平台编译器。 GCC的基本用法该部分介绍GCC命令常用的选项，需熟练掌握。因为在makefile中也就是使用这些语句组成。 1234567891011121314151617181920212223-c 只编译,不链接为可执行文件。用于编译不包含主程序的子程序文件。由.c文件生成.o文件。-g 在使用gdb之前需要加上该选项。-o output_name 指定输出文件名。-O/O2 优化编译链接过程。-On n表示优化级别的整数。优化可以加快代码运行速度，但是会对调试造成影响，因此在开发阶段不要进行优化，在发布时可以优化。-I dirname 将dirname所指向目录加入到程序头文件目录列表中,在预编译过程使用。-L dirname 将dirname所指向的目录加到程序函数档案库文件的目录列表中,在链接时用到。-llibrary 链接名为library的库文件。-Dname 预定义一个名为name的宏，值为1。也可以是-Dname=xxx，值为xxx。 可以用于调试，如-DDEBUG。-Wall 打开所有类型的语法警告。运行含有警告信息的代码通常会有意想不到的结果，所以应尽量使用-Wall处理警告信息。-std=c99 指明使用标准ISO C99作为标准编译程序。-static 禁止使用动态库。-share 尽量使用动态库。 GCC编译过程GCC编译包括4个步骤： 预处理命令：gcc -E test.c -o test.i作用：进行编译的第一遍扫描。由预处理程序负责完成。当编译一个程序时，系统自动调用预处理程序对程序中的以＃开头的预处理部分进行展开，然后才进入源程序的编译阶段。包括替换宏、条件编译、头文件展开等。该阶段不检查语法错误。 编译命令：gcc -S test.i -o test.s作用：检查代码的规范性，是否有语法错误，检查无误后把代码翻译为汇编代码。 汇编命令：gcc -c test.c -o test.o 或者gcc -c test.s -o test.o或者 as test.s -o test.o作用：生成目标代码。 链接命令：gcc test.o -o test作用：将目标程序链接库资源，生成可执行程序。对于头文件包含的函数声明，其函数实现大多数都包含在libc.so.6这个函数库中，gcc默认在路径/usr/lib下去搜索，即链接到libc.so.6库函数中，从而找到函数的实现。这就是链接的作用。 GDBGDB使用GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。使用时，必须在编译时加上-g选项，才可以使用GDB调试。编译完成后，使用命令gdb xxx,即进入调试过程。以下列出常用的选项。1234567891011121314151617l 查看文件。b n 在第n行设置断点，表示程序运行到第n行之前停止。r 运行代码。c 恢复代码运行。p xxx 打印变量值xxx，在显示变量值时前面有一个$N,表示当前变量值的引用标记，后续再次查看该变量，可以使用$N简化书写。n 非进入式单步运行。s 进入式单步运行。watch xxx 对xxx变量设置观察点，单步运行会看到变量值的变化。q 退出。 参考文档：Linux gdb调试器用法全面解析 嵌入式交叉开发环境搭建搭建嵌入式交叉开发环境是进行嵌入式应用开发前必需的准备工作，也是嵌入式系统移植的第一步。开发环境包括主机、目标机、以及连接介质。搭建嵌入式交叉开发环境就是要在主机上编译、调试目标机的代码，即涉及主机和目标机的通信。关于嵌入式交叉开发环境搭建有以下几点说明： 理解为什么要交叉编译。交叉编译是指在开发主机上运行编译器编译内核、应用程序，在目标机上运行内核和应用程序。原因是嵌入式系统硬件资源限制，且嵌入式系统MCU体系结构和指令集不同。 理解如何搭建嵌入式开发环境。 准备好主机、目标机和连接介质。 准备好目标机代码。 安装交叉工具链。 准备主机和目标机之间通信的辅助工具，即安装通信服务和软件。 关于安装交叉工具链。主要步骤是获取交叉工具链压缩包、解压、添加全局环境变量到配置文件、source 配置文件。一般情况是从网上下载已经编译好的交叉工具链。也可以下载源码，自行编译交叉工具链，需要使用工具crosstool-ng，后续有需求再做深入了解。GNU 交叉工具链和前面叙述一致，包括GNU Binutils、GNU GCC、GNU Glibc等部分。 连接主机和目标机的介质通常是串口、USB、网络。对于每一种方式，掌握使用什么工具，如何使用，有何作用即可。具体情况需结合实践情况进行分析。通常情况下，有以下两个任务需要完成。 进入目标机终端的方法：（1）使用串口。（2）使用网络协议ssh、Telnet等。不管是使用串口还是网络，都可以使用putty、scureCRT软件，因为其支持serial、ssh、ftp等众多协议。此外，也可以使用命令行远程控制，例如ssh root@192.168.1.105。 传输目标机代码的方法：（1）使用串口。使用dnw或超级终端软件。（2）使用网络协议scp、tftp等传输。同样，可以使用secureCRT，winSCP(windows平台下使用)等软件，也可以使用命令行，例如在主机上运行命令scp test root@192.168.1.105:/上传文件，或者在开发板上运行scp youbo@192.168.1.109:/home/youbo/test .下载文件。 在使用的嵌入式硬件平台中，（1）JS9331开发板，使用串口进入终端，使用scp传输文件。（2）树莓派和Intel NUC3815，使用ssh进入终端，使用scp传输文件。（3）FS4412/ITOP4412开发板，使用串口进入终端，使用tftp传输文件，使用nfs共享根文件系统，此外还使用dnw或者超级终端烧写程序。 说明：使用网络协议nfs共享根文件系统，是开发调试时比较方便的一种方法。应该理解为根文件系统在主机上，主机上对根文件系统的操作会同步到目标机上。因此可以方便的拖动应用软件，而不需要传输。等待功能开发完毕后，可以将根文件系统压缩传输到目标机的flash中，启动时从flash读取根文件系统即可。具体内容还可参见系统移植部分。 参考文档：linux：嵌入式linux开发环境搭建（整理）嵌入式Linux开发环境的搭建之：嵌入式开发环境的搭建 NFS文件系统简介及原理目标板通过nfs挂载根文件系统嵌入式CRT和DnW工具有什么区别扩展文档：OpenWrt NFS启动 实例分析GCC编译C++程序在实际编程中可能涉及调用第三方库函数。而基于第三方库，项目中他人可能编写c++程序，因此涉及如何同时编译c程序和c++程序。以openwrt移植opencv库，并使用c程序调用c++程序函数为例进行分析。详情参见源代码和Makefile。 说明： 使用gcc编译C程序，使用g++编译C++程序，使用g++或者gcc -lstdc++链接。 如果要使用C程序调用C++函数，对于C++函数形参中的对象变量如何在C程序转换使用，需要扩展学习。因此此段代码暂时使用IplImage *指针传参，在函数内部转换为Mat类型。 参考文档：linux下C与C++混合编程 GCC编译C C++ 和C混合C++ GDB远程调试在实际开发过程中，调试程序是必不可少的环节，对于应用程序的调试，可以采用print方法。也可以使用gdb方法。因为gdb通常很大，不适合直接在目标机中运行，因此通常使用目标机运行gdbserver,主机运行gdb进行远程调试。此外，还有一些其他方法，例如分析core文件调试段错误，后续根据需要可做扩展研究。这里分析gdb远程调试的方法。 js9331开发板使用gdb远程调试包括以下步骤： 在openwrt源码目录下make menuconfig选中toolchain option中的gdb,以及development中的gdbserver。 编译openwrt。将/openwrt/staging_dir/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2拷贝到/opt目录下，配置好环境变量。 将/openwrt/bin/ar71xx/packages/base/目录下的gdbserver包及其依赖包传输到开发板进行安装。 开发板运行命令./gdbserver 192.168.1.111:1234 hello。 主机运行mips-openwrt-linux-gdb hello，进入gdb环境。 在gdb环境下运行target remote 192.168.1.105:1234。 在gdb环境下查看搜索文件路径前缀show solib-absolute-prefix，并设置为交叉编译环境库路径前缀set solib-absolute-prefix /opt/OpenWrt-Toolchain-ar71xx-for-mips_34kc-gcc-4.8-linaro_uClibc-0.9.33.2/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2/。之后则进入正式调试环节。 ITOP4412开发板使用gdb远程调试包括以下步骤： 在arm-2009q3交叉工具链中找到gdbserver可执行文件，使用arm-none-linux-gnueabi-strip对其进行瘦身。 使用tftp将瘦身后的gdbserver传输到开发板。 使用arm-none-linux-gnueabi-gcc编译待调试代码，加入选项-g。并用tftp传输到开发板。 开发板运行命令./gdbserver 192.168.1.111:1234 hello。 主机运行arm-none-linux-gnueabi-gdb hello，进入gdb环境。 在gdb环境下运行target remote 192.168.1.230:1234。 在gdb环境下查看搜索文件路径前缀show solib-absolute-prefix，并设置为交叉编译环境库路径前缀set solib-absolute-prefix /opt/arm-2009q3/arm-none-linux-gnueabi/libc。之后则进入正式调试环节。 参考文档：嵌入式开发调试方法 嵌入式Linux的调试技术使用gdbserver远程调试openwrt下使用gdbserver远程调试 搭建交叉开发环境搭建交叉开发环境，主要是安装交叉编译工具链。此外，为了调试方法，会使用tftp和nfs服务，下面做简要分析。这里的操作均是在主机上运行。 js9331开发板openwrt系统搭建交叉编译环境步骤如下： openwrt官网下载工具链压缩包。 解压到/opt文件夹下。 配置环境变量，修改/etc/bash.bashrc文件。 执行命令source /etc/bash.bashrc。 执行mips-openwrt-linux-gcc -v检查安装是否成功。 ITOP4412开发板linux最小系统搭建交叉编译环境步骤如下： 获得工具链压缩包。 解压到/opt文件夹下。 配置环境变量，修改/etc/bash.bashrc文件。 执行命令source /etc/bash.bashrc。 执行arm-none-linux-gnueabi-gcc -v检查安装是否成功。 使用tftp服务 主机安装tftpd-hpa和tftp-hpa。 配置tftp server配置文件，/etc/default/tftpd-hpa。内容如下： 1234TFTP_USERNAME=&quot;tftp&quot;TFTP_DIRECTORY=&quot;/tftpboot&quot;TFTP_ADDRESS=&quot;0.0.0.0:69&quot;TFTP_OPTIONS=&quot;-c -s -l&quot; 创建/tftpboot文件夹，并改变权限。 重启tftp服务，sudo /etc/init.d/tftpd-hpa restart。 复制目标机代码到/tftpboot文件夹下。 目标机输入命令”tftp -g -l 目标文件名 -r 源文件名 tftp服务器IP”即可下载代码。 使用nfs服务 主机安装nfs-kernel-server。 配置文件，/etc/exports。内容如下： 1/source/rootfs *(rw,sync,no_root_squash,no_subtree_check) 创建/source/rootfs文件夹，解压根文件系统到该目录。 复制目标机代码到/source/rootfs文件夹下。 配置目标机启动参数。 注：在集成开发环境也可以编译、调试程序，例如eclipse CDT,其中也需要设置编译器、调试器等参数，其原理本质上和gcc、gdb等一样。 参考文档《嵌入式linux c语言程序设计基础教程》1.6 个人观点这一部分不涉及知识难点，只需要会使用gcc、gdb，以及主机和目标机之间通信的工具，达到完成开发的目的即可。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>gcc</tag>
        <tag>gdb</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言高级编程--1基础零碎知识]]></title>
    <url>%2F2017%2F11%2F14%2FC%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--1%E5%9F%BA%E7%A1%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本篇文章作为C语言高级编程的铺垫，介绍一些C语言相关的基础概念，以及容易出错的零碎知识点。重点包括typedef定义数据类型，宏定义，条件编译，sizeof运算符。 数据这里介绍嵌入式linux c语言数据相关的知识点,包括GNU C简介、基本数据类型、变量与常量定义、预处理等。 ANSI C与GNU C ANSI C是美国国家标准协会ANSI(American National Standard Institute) 1989年颁布的C语言标准，也称为C89，Standard C。1990年ISO和IEC采用了ANSI C(带有一些小改动)为国际标准，所以C89标准又被称为C90标准。后来又有C99和C11。 GNU C(支持GNU扩展的Ｃ语言称之为GNU C)是在标准Ｃ基础上进行了扩展而来，GCC支持C90，不完全支持C99和C11,使用时需加上-std=gnu99之类。GCC由开始的GNU C Compiler变成了GNU Compiler Connection，支持多种语言的编译。 参考文档：1.《ANSI C, Standard C与GCC》2.《GNU C 、ANSI C、标准C、标准c++的区别和联系》 数据类型C语言数据类型如图所示。 说明:不同计算机体系结构中数据类型所占字节数不同，比如32位机或者64位机不一样，编译器相关目录下的limits.h中有相关的规定。123ubuntu系统： /usr/include/limits.hopenwrt交叉工具链： /opt/OpenWrt-Toolchain-ar71xx-for-mips_34kc-gcc-4.8-linaro_uClibc-0.9.33.2/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2/include/limits.h 变量与常量变量：变量采用先定义后使用的规则。变量定义后存储器会为其分配一定的存储空间，一个变量在其作用域内只能有一个定义，可以有多次声明，且存储器不会为其分配存储空间。用typedef定义一种新的数据类型，是编程中常见的处理。常量：常量定义可以使用const，也可以使用define。const的主要知识点在于修饰指针。详见《C语言高级编程-4数组与指针》。 typedeftypedef是c语言的关键字，用于为一种数据类型定义一个新名字。 格式如下：1typedef 已有数据类型 新数据类型 使用typedef的好处有： 给变量起一个易记且意义明确的新名字。例如对函数指针使用typedef。 简化一些比较复杂的类型声明。例如对结构体使用typedef。 用在嵌入式开发移植中，通过typedef为标识符取名为一个统一的名称，在需要修改标识符时，只需要修改typedef的内容。例如/usr/include/asm-generic/types.h，以及linux内核源码中include/asm-arm/types.h。 使用示例：1234567891011121314151617181920212223242526e.g1:链表节点定义，注意这里int也重新定义一个名字，方便后续可以替换其他类型。typedef int datatype;typedef struct node&#123; datatype data; struct node *next;&#125;linknode,*linknode_t;void list_show(linknode_t H)e.g2:枚举类型重新定义新名称。typedef enum&#123; SENSOR_BOOL = 1, SENSOR_INT = 2, SENSOR_DOUBLE = 3,&#125;SENSORTYPE;typedef struct sensorInfo&#123; int sensorID; char sensorName[20]; SENSORTYPE type; void *pValue;&#125;sensorInfo;e.g3:函数指针重新定义新名称。#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum,sighandler_t handler); 预处理预处理是gcc编译的第一步，包括预定义、文件包含、条件编译等功能。预处理的主要作用是用预处理程序将以#开头的语句进行展开。具体关于预处理的相关内容详见《C语言高级编程–2搭建嵌入式linux编程环境》。 预定义预定义符号在C语言中有一些预处理定义的符号串，其值为字符串常量或者十进制常量，常用在调试程序时输出源程序各项信息。常用的有__FILE__、__LINE__、__FUNCTION__等。 宏定义除了系统定义的预处理符号，还有用户自定义编写的宏。这里的宏定义即为用户编写的宏。分为两种，无参宏定义和带参宏定义，定义如下。12无参宏定义 #define 宏名 字符串 带参宏定义 #define 宏名() 字符串 使用说明： 预处理阶段不会对宏做错误检查。 宏定义不必加分号，否则连分号一起替换。 为了避免优先级引起的替换错误，一定要加括号，否则有宏的副作用。不仅被替换的要加括号，可能整个字符串也要加括号。 带参宏定义中宏名和形参表中间不能有空格。多行时用“\”进行分割。可以使用do……while(0)结构，增强可读性。 带参宏定义就是函数宏。在函数宏中，参数每次应用于宏定义时，都会重新求值，多次求值可能导致结果不可预料。 文件包含文件包含是把指定文件插入该语句行位置，从而把指定文件和当前文件源程序连成一个源文件。通常我们称为包含头文件。格式为#include “文件名”或者#include &lt;文件名&gt;。注意：&lt;&gt;是在系统头文件目录去找，而“”是在当前目录下找头文件。此外，书写头文件的格式通常如下，这样可以防止头文件重复包含。123#ifndef _MYFUNC_H_#define _MYFUNC_H_#endif 条件编译条件编译是指根据条件的真假决定是否编译相关代码。按不同条件编译不同的代码。区别if……else,它是都会生成机器语言，根据不同条件执行语句。而条件编译是选择性编译，代码量会少一些，可以通过.i文件区分。条件编译的用途有： 用于移植。在同一份文件中生成不同的可执行文件。 用于调试。区分调试版本和发布版本。 条件编译的格式如下： 方式一： #ifdef 标识符 程序段1 #else 程度段2 #endif 方式二： #if 常量表达式 程序段1 #else 程序段2 #endif 应用实例在实际编程中，常常会打印信息用于调试，判断程序执行情况和出错情况。由于经常使用，有必要自定义一个调试打印代码，可以方便的移植到任何项目中，用于调试。其中涉及到预定义符号、函数宏、条件编译等内容。代码详情参见debug.h。 数据的输入输出常用的输入函数有：getchar,gets,printf。常用的输出函数有：putchar,puts,scanf。其使用方法在此不再赘述。其相关信息相见文件IO和标准IO部分。注意事项 int getchar(void)注意理解返回值是int类型而不是char类型的原因：字符对应的ascii码值范围为0-255，用char类型不能表示完整，此外，如果接收错误，返回-1。因此返回值类型为int类型。 垃圾字符可以用getchar()吃掉或者用格式串中的“%*c”来吃掉。通常产生的原因可能是scanf一个字符，而%c是可以接收转义字符的，所以会把缓存区的字符(例如\n)直接赋值过去。 运算符和表达式C语言包括40多种运算符，常见的运算有：算术运算、赋值运算、逗号运算、位运算、关系运算、逻辑运算、条件运算以及sizeof运算符等。这里只简要介绍需要注意的几点。 重点说明 逗号表达式：分别求两个表达式的值，并以第二个表达式的值作为结果。 位运算表达式：C语言标准说明对无符号数进行移位都是逻辑移位，而有符号数采用算术移位还是逻辑移位取决于编译器。因此一个程序采用了有符号数的右移操作是不可移植的。移位操作相当于乘2或者除2,该运算效率要高于乘除。逻辑移位和算术移位详见ARM汇编一节，另外位运算多用于操作寄存器，参见ARM接口编程。 sizeof操作符：单目运算。用来计算变量或者数据类型占用内存空间字节数。 sizeof(p)p为指针，结果是4或者8,和计算机位数有关。不管是什么类型的指针，结果一样，因此不能对字符指针求sizeof得到字符串长度，而应该使用strlen。 sizeof(a)a为数组名，结果为整个数组所占长度，数组个数=sizeof(数组名)/sizeof(类型)。同样需要注意字符数组求sizeof，可作为期望长度。 条件运算符：三目运算符。示例：#define MAX(a,b) (a)&gt;(b)?a:b 取两个值中的大数。 类型转换运算符：即强制转换。示例：void *需要强制转化，详情见void *知识点,《C语言高级编程-4数组与指针》。如果某数据打印结果显示为一长串数字，不是预期的，需要考虑可能数据类型出现问题。 运算符优先级C语言中，一个表达式中如有不同优先级的运算符，优先级高的先运算。如果相同优先级，则按照结合性规则进行运算。运算符的优先级总结如下表。 程序结构与控制语句C语言中的语句分为：顺序结构、分支结构和循环结构。控制语句有：条件判断语句、循环语句和跳转语句。其具体使用方法在此不再赘述。 这里只简单说明switch语句的格式和注意事项。格式如下所示。其中表达式必须是字符类型或者整数类型，不能是字符串。 1234switch (表达式)case 常量表达式1：语句1;case 常量表达式2：语句2；default:语句n;]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>typedef</tag>
        <tag>宏定义</tag>
        <tag>条件编译</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--6文件系统]]></title>
    <url>%2F2017%2F10%2F29%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[本篇文章主要围绕linux文件系统总结相关知识点，包括文件系统类型、分区与挂载等基本概念以及文件系统重要目录分析。最后简要叙述文件系统体系结构中起重要作用的虚拟文件系统概念，以作后期扩展学习。 文件系统简介文件系统概念 文件系统是一种管理和访问磁盘的软件机制。用于组织和管理计算机存储设备上的大量文件，并提供用户交互接口。 文件系统是linux操作系统的重要组成部分。在linux操作系统中，“一切皆文件”。因此硬件设备也是一种特殊的文件，它挂载在某一目录下被使用。我们需掌握体会linux文件系统与windows文件系统的不同之处。 文件系统类型常见的linux文件系统有以下几种： 磁盘文件类型本地主机可以访问的文件系统，包括硬盘、CD-ROM、DVD、USB、磁盘阵列等。文件系统格式有：Ext3、Ext4、vfat、FAT32、FAT16、NTFS等。 网络文件系统远程可访问的文件系统，在服务器端仍然是本地的磁盘文件系统。文件格式有：NFS、Samba、AFP、WebDAV等。 专有/虚拟文件系统不驻留磁盘的文件系统，即为操作系统加载才产生。文件格式有：TMPFS（临时文件系统）、PROCFS（进程文件系统）、LOOPBACKFS（回送文件系统）。 注：1. 使用du -aTh命令可以看到各文件系统的使用情况和类型。2. 对比Windows系统，文件系统格式主要为NTFS、FAT16、FAT32。 分区与挂载分区 硬盘分区是针对硬件进行操作，分为主分区、扩展分区、逻辑分区。 交换分区：将内存中的内容写入磁盘或者从磁盘中读出，称为内存交换。交换分区的大小最小为计算机内存。需要把交换分区放在硬盘驱动器的起始位置。 挂载 挂载是指将分区和目录对应的过程。将一个文件系统和一个存储设备关联起来。挂载点是指文件树中的挂载目录。 linux下分区与目录的关系 Linux每一个分区都和某一个目录对应，对目录的操作就是对分区的操作，从而实现了硬件管理手段和软件目录管理手段的统一。 在Linux下，查找某个文件，不需要知道其物理存储位置，只需要知道属于哪一个目录即可。 在Windows下，目录属于分区，而在Linux下，分区属于目录。 Linux文件系统和Windows文件系统区别如下图所示。 注:1. 分区的概念可以结合安装linux操作系统的操作进一步加深理解。2. 参考文档：《嵌入式操作系统(Linux篇)》1.5.1 根文件系统目录结构根文件系统定义：存放运行、维护系统所必须的各种工具软件、库文件、脚本、配置文件和其他特殊文件的地方，也可以安装各种软件包，其实就是目录和文件。 文件类型linux系统下文件不是以后缀名不同来区分不同的文件。linux操作系统下有7种文件类型。 b 块设备文件 c 字符设备文件 d 目录文件 - 普通文件 l 链接文件 s 套结字文件 p 管道文件 说明 用ls -l命令可以看到前10个字符表示文件类型和访问权限。访问权限包括读r、写w、执行x。访问权限又分为3个不同用户级别：文件所有者、文件从属组、其他用户。 使用chmod可使用符号标记或者八进制数两种方式改变文件访问权限。如chmod u+r xxx或者chmod 777 xxx。使用符号标记方式改变，可指定多个用户级别，用逗号隔开。 目录分析Linux文件系统就是一个树形的分层组织结构，类似于一棵倒置的树。将根（/）作为文件系统的唯一起点，其他文件和外部设备都以文件的形式挂载在这个文件树上。每一个linux操作系统的文件系统不完全一样，这里以Ubuntu为例，只介绍重要的几个目录。 /bin 普通用户可以使用的命令存放地，类似的有/usr/bin、/usr/local/bin。 /sbin 超级用户可以使用的命令存放地，类似的有/usr/sbin、/usr/local/sbin。 /dev 存放所有设备文件，包括硬盘、键盘、鼠标、网卡、终端等。 /etc 存放系统配置文件。 /home 普通用户家目录。 /root 超级用户家目录。 /lib 存放共享库文件，包括被/bin、/sbin程序使用的库文件，类似的有/usr/lib、/usr/local/lib。 /media Ubuntu系统自动挂载CD-ROM、USB等，存放临时读入的文件。 /mnt 作为临时被挂载文件系统的挂载点。 /opt 作为可选文件和程序的存放目录，通常第三方软件和通过源码安装的软件，可安装于该目录。 /proc 存放所有标志为文件的进程，每一个进程在proc下有一个名为其进程号的目录。 /tmp 存放临时文件。 /lost+found 恢复文件存放位置，系统崩溃时，可在该目录下找到恢复文件，通常为空。 /usr/include c/c++等开发环境的标准include文件。 /usr/local 安装本地程序的一般默认路径。 /var/cache 应用程序缓存目录。 说明 使用tree命令可以查看系统的文件树形目录结构。 用于intel NUC3815的开发IDE Intel® System Studio IoT Edition和openwrt的交叉编译环境都安装在opt下。 /tmp文件夹是tmpfs类型的文件系统挂载于此，而tmpfs文件系统由内核支持，存在于内存中，由于内存的数据掉电丢失，因此系统重启后，该目录下的文件被清空。openwrt系统下安装软件，通常将软件包放于此目录。 制作根文件系统的方法详见系统移植部分。 参考文档：Linux文件系统以及目录结构简介 文件系统体系结构linux文件系统组件的体系结构如下图所示，该图显示了用户空间和内核空间中与文件系统相关的主要组件之间的关系。 文件系统包括三个部分：虚拟文件系统、cache、真正的文件系统(vfat、Ext3等)。其中有重要作用的是虚拟文件系统(VFS)。它是一种转换机制，仅存在于内存中，不存在外存空间。它的作用如下： 给用户空间的程序提供文件系统接口，通过一套统一的文件IO系统调用，对任意文件操作。 提供抽象功能，通过一些数据结构及其方法向实际的文件系统提供接口，实现不同文件系统在Linux中共存。 注：1. 从调用open、read等函数到设备文件正确返回数据的过程加深理解文件系统体系结构。2. 后期可深入内核中文件系统源代码加深理解文件系统的工作机制。3. 参考文档：Linux 文件系统剖析]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>文件系统</tag>
        <tag>根文件系统</tag>
        <tag>虚拟文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--5shell脚本]]></title>
    <url>%2F2017%2F10%2F23%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--5shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[本篇文章围绕shell脚本编程，介绍了shell变量、常用的功能性语句和结构性语句，并通过实例分析进一步理解shell脚本的使用。 shell简介 计算机不能直接理解高级语言，而需要将高级语言翻译成可以理解的机器语言。翻译的方式有两种：编译和解释。而shell脚本就是一种解释性语言。 shell脚本对于管理系统任务和其他重复性工作，有很好的表现。例如在/etc/rcx.d/文件夹下有许多脚本文件，用来存储系统配置和建立服务，必要时可以修改。再例如网络配置重启时，使用命令/etc/init.d/networking restart，其中networking就是一个脚本文件。 shell脚本和windows系统下的批处理类似，脚本文件类似于.bat文件。 shell脚本的本质shell命令的有序集合。 shell脚本的目的批量执行shell命令。 shell编程的基本过程 建立shell文件 赋予shell文件执行权限 执行shell文件 注：执行时要加上./才可以。因为标准搜索路径没有当前路径。 shell变量基本概念 shell允许变量，但是不支持变量类型，所有赋值给变量的值都解释为一串字符。不需要声明。 变量赋值不能有空格，否则解析为命令。 通常使用全大写表示shell变量。 变量的调用：在变量前加$，可以使用{}区分其他内容，即${}。 使用unset命令删除变量的赋值，如unset VAR。 用#开头表示注释，通常在脚本的第一行写#! /bin/bash表示用哪种类型shell解释该程序。 变量类型 用户自定义变量 位置变量（命令行参数）$0表示脚本文件名。$1、$2……${10}等分别表示命令行第一个参数，第二个参数……第十个参数。 预定义变量 $# 表示命令行参数个数。 $@或$* 表示所有命令行参数，不包括命令名称。 $? 表示前一个命令的退出状态。 $$ 表示正在执行的进程ID号。注意预定义变量和makefile的自动变量区分。 环境变量在《Linux操作系统使用–4常用shell命令汇总》中有相关描述，此处不再赘述。补充：使用set命令查看所有本地定义的shell变量，包括环境变量。 使用说明 shell允许变量，但是不支持变量类型，所有赋值给变量的值都解释为一串字符。不需要声明。 变量赋值：VAR=var,不能有空格，否则解析为命令。通常变量使用全大写表示。 变量调用：在变量前加$即可，可以使用{}区分别的内容，即${}，避免歧义。 使用unset命令删除变量的赋值，如unset VAR。也可清除环境变量。 用#开头表示注释，通常在脚本的第一行写“#! /bin/bash”表示用哪种类型shell解释该程序。 常用功能性语句readread var1 var2 var3……表示从标准输入读入一行，把读入的第一个单词赋给var1，把第二个单词赋给var2，其余所有的词赋给var3。注：read是阻塞等待输入的。 exprexpr用于简单的整数运算，包括加(+)、减(-)、乘(\*)、整除(/)、求模(%)等。注：1. expr和运算符之间有空格，运算符之间有空格。2. expr结果赋值给变量，需要使用命令置换。3. 变量运算时，必须使用expr。不能使用$I=$I+1，而是let i++或者expr 1 + 1。切记shell脚本的目的不是做运算。 testtest用来测试字符串、整数、文件属性，每一种有不同的测试操作符。 字符串s1=s2,判断s1字符串和s2字符串是否相等。还有s1!=s2、-z s1、-n s1等,详情参阅手册man test。 整数a -eq b,判断a和b是否相等。在a和b之间还有-ne、-gt、-ge、-lt、-le等，详情参阅手册。 文件属性-d name,判断name是否为一个目录。name前还可以有-e、 -f、 -L、-r、-w、-x、-s等。以及f1 -nt f2、f1 -ot f2等。详情参阅手册。注：1. 可以使用[]代替test，在使用条件语句时常用。注意[]内的内容离左右两个括号都有一个空格。2. 字符串比较，等号和不等号两边的字符串有空格，且字符串要加双引号。3. 使用echo $?查看test结果，真为0,假为1。4. 在系统调用中可以使用stat取得文件属性。 echoecho用于向标准输出打印字符串。注:1. 单引号不解析特殊字符，原样输出。双引号解析特殊字符，进行替换输出。因此如需打印变量的值，需使用双引号。2. echo在打印空格时，若加上双引号，每个空格都打印。若不加，两个单词间多个空格只当做分割两个单词的符号，打印一个空格。参考文档：shell脚本中单引号(‘)和双引号(“)的使用区别 setset用于跟踪调试shell脚本。set -e表示脚本执行出现了返回值为非零时，整个脚本立即退出。set -x表示set命令之后执行的每一条命令以及加载命令行中的任何参数都会显示出来。 各种括号在shell脚本中，常常会使用各种括号。例如： []单中括号可以替代test。 [[]]双中括号用于字符串模式匹配，例如if [[“$i” =~ “.sh”]] 判断是否包含.sh后缀。 {}花括号和$一起使用，${}表示区分其他字符。{}内还可以加入逗号或者“..”表示扩展，例如{1..5}。 ()圆括号和$一起使用，$()和反引号``作用一样，表示取值。 (())双圆括号用在算术运算中，例如for ((I=0;I&lt;10;I++))循环。 参考文档：shell中各种括号的作用()、(())、[]、[[]]、{} 结构性语句shell脚本中的结构性语句主要是掌握每种语句的书写格式,使用方法类似c语言，但不能照搬，注意shell脚本的主要任务是执行命令集合。 条件语句123456789101112131415if 条件then 命令1 命令2fiif 条件1then 命令1elif 条件2then 命令2else 命令Nfi 说明： if i&lt;5用shell表示为if (($i&lt;5)), 或者if [ $i -lt 5 ]。 在脚本中常看到if和then写在一行，用分号隔开。例如if [$i -lt 5];then 多路分支12345678case 字符串变量 in模式1） 命令1 ;;模式2) 命令2 ;;esac 说明： case只能识别字符串变量，且字符串要加双引号。 模式可以使用通配符，也可以同时匹配两个模式，使用|单竖线即可，通常最后一个模式使用*通配剩下所有情况。 匹配模式为字符串匹配。 使用;;结束，类似于c语言中的break。 循环语句for循环1234for 变量名 in 单词表do 命令表done 说明： 这里不是用变量名匹配单词表，而是使用单词表里单词的个数作为循环的次数。 for循环适用于循环次数确定。 如果单词表为所有命令行参数，可以省略“in 单词表”。 一定要区分和c语言中的for循环，shell脚本主要是执行命令。 示例：for ((I=0;I&lt;10;I++))，for i in `seq 1 2 10`（表示从1开始到10,间隔为2），for i in {1..5} (表示从1到5,间隔为1)。 while循环1234while 命令或表达式do 命令表done 说明: while用于循环次数不确定。 死循环为while true。 while语句的退出状态为命令表中最后一条命令的退出状态。 循环控制语句123break n continue 说明：break n表示跳出n层循环，而continue表示转到最近一层循环语句的下一轮循环上。 shell函数 定义：把完成固定功能且多次使用的一组命令封装在一个函数里，使用时调用函数名即可。 原则：遵循先定义后调用。 函数只在当前shell起作用，不能输出到子shell中。 定义格式：函数名()或者function 函数名()，没有形参，使用命令行传参。 调用格式：置换的方式赋值给变量或者单独调用。调用时，就相当于使用一个命令。 函数返回：由return返回或者使用echo $?查看结果。 可以在函数中定义局部变量，使用local修饰。 实例分析通过分析三个实践中使用过的shell脚本。进一步理解shell脚本编程。源代码详见gist。 automatic mount disk in openwrt 该例子是openwrt系统下自动挂载的脚本。编辑文件为/etc/hotplug.d/block/30-disk-mount。 该段代码主要是case……esac语句的使用。模式有add和remove。 参考文档：1. openwrt hotplug2. OpenWrt中的热拔插Hotplug.d中的脚本 mkconfig in uboot source code 该例子是uboot源代码顶层目录下的配置文件，在Makefile中调用，作用是完成编译前针对特定单板的配置工作，编辑文件为u-boot-2013.01/mkconfig。 -a表示&amp;&amp;，-o表示||，在单中括号中使用-a和-o，在双中括号中使用&amp;&amp;和||。 set ${line}表示把line变量设置为当前shell的变量。 shift用来向左移动位置参数。 if [“字符串”]表示判断字符串是否为空。 awk是一个文本分析工具，可以用于字符串匹配分割等。 sed是一个流编辑器，可以用于字符串的替换过滤等。 关于uboot源码的配置编译在系统移植部分再具体分析。 参考文档：1.(三)u-boot2013.01.01 for s5pv210：《mkconfig分析》 2. linux awk命令详解3. Shell脚本学习之sed详解 networking service in ubuntu 该例子是Ubuntu系统下重启网络的脚本，编辑文件为/etc/init.d/networking。 该例子中使用一些函数，例如log_warning_msg。定义在/lib/lsb/init-functions文件中。在第19行使用“. /lib/lsb/init-functions”（点号加文件名）表示调用另一个脚本。 该例子中使用&amp;&amp;和||逻辑运算符，利用其短路性质。当&amp;&amp;连接两个表达式时，只有左边表达式为真时计算右边表达式。当||连接两个表达式时，只有左边表达式为假时计算右边表达式。 关于Linux启动脚本和如何编写启动脚本另做研究总结。 参考文档：1. Linux Standard Base2. 分析 shell 中 的 复杂的 &amp;&amp; 和 || 表达式3. 理解Linux系统/etc/init.d目录和/etc/rc.local脚本4. Linux exec与重定向 个人观点 shell脚本的掌握程度是：能够编写基本的脚本，同时能够理解他人的脚本。 shell脚本编程时出现错误的原因多数是因为未理解shell脚本的实质，与C语言混淆。shell脚本的实质是为了执行一系列命令。 C语言中提供了调用shell脚本的方法，具体内容另起研究总结。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--4常用shell命令汇总]]></title>
    <url>%2F2017%2F10%2F18%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--4%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本篇文章从基本命令、磁盘管理、用户管理、进程管理、文件管理等几个方面总结实践中shell常用命令及其使用场合。并在最后简要介绍环境变量的相关知识：定义、查看、修改。 shell简介基本概念 shell是一个命令行解释器，其功能是将用户命令解析为操作系统所能理解的指令，实现内核和用户的交互。 shell命令包括三个要素，命令名称、选项、参数。命令名称区分大小写。 当多个shell命令写在一行，用分号隔开，顺序执行每一个命令。 当一条shell命令一行写不完，用反斜杠表明。 shell中的特殊字符通配符当用shell命令处理一组文件时，通常使用通配符，提高效率。注意和正则表达式区分。常用于文件名匹配。 - * 匹配任意长度字符 - ? 匹配一个长度字符 - […] 匹配其中指定的一个字符 - […-…] 匹配指定的一个字符范围 - [^…] 除了指定的字符，其他均可匹配 管道功能：将第一个命令的输出作为第二个命令的输入（单竖线 |）示例：ps -ef | grep xxx 用于杀死某个进程时，先用该命令定位进程号ls | wc -l 统计文件个数 置换功能：将一个命令的输出作为另一个命令的参数（Esc下方的引号）示例：wc -l `ls` 统计每个文件的行数ls `pwd` 显示当前路径文件 重定向功能：分为输入、输出、错误重定向，输出重定向用的多。主要是改变shell命令或者程序默认的标准输入、输出、错误目标。示例：> 新建模式，覆盖原文件>> 追加模式，写在已有内容后注：使用> filename可以新建文件参考文档：shell中的通配符，特殊字符和正则表达式 常用shell命令基本命令这里只简要总结常用shell命令。 whereis xxx 查找二进制文件、可执行文件、帮助文档，源文件、配置文件等。 which xxx 查找可执行文件所在位置。 hostname 查看主机名。 whoami 查看当前用户。 history numberline 显示历史命令，在重启电脑后可以查看，以便执行过去的命令。 wc -c/-w/-l xxx 统计文件字符数/单词数/行数。 参考文档：四个查找命令find,locate,whereis,which的区别注：掌握某些命令的选项含义，能够举一反三套用在多个命令中，例如-r表示 recursion递归，-h表示human人类可读。 磁盘管理 df -aTh 查看文件系统空间占用磁盘情况，显示文件格式类型，在清理磁盘时常用。 du -h 查看某个目录/文件所占磁盘空间大小。 dd if=xxx of=xxx bs=xxx count=xxx 块拷贝文件，烧写系统时将镜像拷贝到优盘用到；制作ramdisk文件系统用到。 fdisk 查看硬盘分区及对硬盘进行分区管理。ITOP4412烧写系统用到fdisk -c 0。 mount -t types device mountpoint 将设备文件挂载在某个目录下，openwrt下有手动挂载和自动挂载使用；制作ramdisk文件系统用到。 umount mountpoint 将设备文件卸载。 用户管理 adduser username 添加用户。 passwd username 修改用户的密码。 注：1. 添加一个用户时，系统会将/etc/skel目录下的文件、目录都复制到新用户的主目录下，主要是一些配置文件，如.vimrc、.bashrc等。且会保存在/etc/passwd文件里，一行包含一个账号信息。此外，/etc/group文件记录了组的名称和组员列表。2. 如果忘记密码，可以使用启动界面进入Recovery Mode，以root身份修改其他用户密码。也可以使用passwd直接修改其他用户密码，不必输入旧密码。 进程管理 ps aux 查看进程，侧重查看进程的CPU占用率和内存占用率。 ps -ef 查看进程，侧重查看进程的父进程ID和完整的COMMAND命令。 pstree 以树状形式显示进程。 注：1. 其余关于进程的状态等知识点另起专题研究。2. ps命令经常搭配grep命令，关注感兴趣的进程。 文件管理文件及文件夹 pwd 查看当前路径，在需要粘贴绝对路径时使用该命令。 file xxx 查看文件类型。 rm -rf 强制删除，包括文件夹。小心使用该命令，尤其是root用户。一般不使用rmdir，该命令要求必须为空文件夹。 mkdir -p dir1/dir2 创建多级目录。 head -num xxx 显示文件前num行内容，通常搭配其他命令结合管道使用。 tail -num xxx 显示文件后num行内容。 grep pattern file 查找字符串，格式支持正则表达式。 find path -name “xxx” 查找文件,支持通配符*和?。 diff a b 比较a和b两个文件。 创建链接 ln target link_name 创建硬链接，通过每个文件的iNode建立，不能跨越文件系统。会在选定位置生成一个和源文件大小相同的文件。 ln -s target link_name 创建软链接（符号链接），利用文件路径名建立，使用绝对路径，可以跨越文件系统。实践中使用较多。不会重复占用磁盘空间。 压缩与解压 tar -cvjf xxx.tar.bz directoryname 压缩为bz格式。 tar -cvzf xxx.tar.gz directoryname 压缩为gz格式。 zip xxx.zip directoryname 压缩为zip格式。 tar -xvjf xxx.tar.bz 解压bz格式。 tar -xvzf xxx.tar.gz 解压gz格式。 unzip xxx.zip 解压zip格式。 注：1. iNode是检索i节点表的下标，i节点中存放有文件的状态信息。2. 修改硬链接文件名，链接仍然有效，而软链接断开连接。对于已存在的链接执行移动或删除命令，可能会导致链接断开。如果删除后，建立同名文件，软链接将恢复，但硬链接不再有效。 网络管理网络管理主要是配置上网。临时生效使用命令配置，永久生效编辑配置文件。关于网络的其他基础知识和常用的命令另起专题研究。 ifconfig 查看网络。 ifconfig eth1 192.168.1.126 netmask 255.255.255.0 配置IP和子网掩码。 Ubuntu/Raspbian网卡配置文件：/etc/network/interfacesdns配置文件：/etc/resolv.conf重启生效 ：sudo /etc/init.d/networking restart openwrt网卡配置文件：/etc/config/network重启生效：/etc/init.d/network reload 注：1. 如果ping不通域名网址，可能需要修改dns配置文件。2. resolv.conf文件在重启后被清空，需要再次配置。 环境变量环境变量是指用户运行环境的参数集合。每一个用户都有其专门的运行环境。用户可以对运行环境进行定制，即修改系统环境变量。环境变量的书写为 环境变量名=内容1：内容2。使用环境变量的场合有： 安装软件，配置路径环境变量，以便全局使用。 切换用户时，通常带上环境变量和工作目录，确保软件的正常使用，如su - root。 常见的环境变量 PATH 系统路径 HOME 系统家目录 HISTSIZE 保存历史命令记录的条数 LOGNAME 当前用户的登录名 HOSTNAME 主机名称 SHELL 当前用户用的哪种shell 查看/设置环境变量 env 查看所有环境变量。 echo $environmentVariable 查看某一环境变量的内容。 export PATH=/home/youbo:$PATH 临时添加环境变量，只对当前终端有效。 如果想要永久性修改环境变量，则需要修改配置文件。 /etc/profile 系统级环境变量 e.g:安装java和tomcat /etc/bash.bashrc 系统级bashrc e.g:安装openwrt交叉编译环境 /home/xxx/.bashrc 用户级环境变量 e.g:修改HISTSIZE 注：修改完配置文件后，需要使用source命令使其生效，不必重启参考文档：Linux环境变量种类、文件、设置]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>shell命令</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--3软件包管理]]></title>
    <url>%2F2017%2F10%2F15%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--3%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇文章围绕Linux平台下软件包管理问题，首先介绍deb软件包和rpm软件包两种常用的软件包管理机制，重点介绍deb软件包的dpkg命令和apt原理，简述rpm软件包的rpm命令和yum工具。然后归纳在实践中使用的除上述两种软件包管理之外的方法，并结合所使用的硬件平台给出一些具体的软件包安装实例说明。 软件包管理机制定义把应用程序的二进制文件、配置文档、man/info帮助页面等文件合并打包在一个文件中，使用软件包管理器操作软件包，完成获取、安装、卸载、查询等操作。 主要功能安装、卸载、查询、升级、校验等。 软件包管理是在工作中必做的一项任务，但Linux系统下的软件管理和Windows下软件管理截然不同，因此需要了解Linux系统软件管理的原理、方法并熟练使用。通常有两类软件包管理机制：Debian系统的deb软件包(.deb)管理和Redhat系统的rpm软件包(.rpm)管理。 关于两种软件包管理机制的重要说明： 原理十分类似，命令有所区别，掌握其中一种，其余的有需要时再查询资料。 由Debian或者Redhat衍生出来的Linux系统必然使用与之相关的软件包管理机制。 deb软件包deb软件包管理有两种方式：dpkg本地安装和apt在线安装。dpkg安装方式适用于deb软件包已经下载到本地时进行。而APT工具适合联网时安装使用。 dpkg本地安装常用的命令有以下几个： - dpkg -i xxx.deb 安装软件 - dpkg -r xxx 移除软件 - dpkg -P xxx 移除软件和配置文件 - dpkg -l 列出已安装软件清单 - dpkg -s xxx 显示某个软件安装情况 apt在线安装定义APT是Ubuntu Linux中功能最强大的命令行软件包管理工具，用于获取、安装、编译、卸载、查询deb软件包和检查软件包依赖关系。它是一组命令，包括apt-get、apt-cache、apt-proxy、apt-show-versions、apt-config、apt-cdrom等。其中最常用的apt-get。 原理1.配置软件源各种软件包存放在软件仓库中，软件仓库置于镜像服务器中，在/etc/apt/sources.list软件源配置文件中列出最合适访问的镜像站点。该文件可以直接编辑修改。 在更新源或者添加源时，修改sources.list文件，需要了解其配置项的书写格式，可参考以下文档。另外，直接访问镜像站点查看各个文件夹也有助于进一步了解APT安装软件的原理。参考文档：《嵌入式操作系统Linux篇》3.2.1节debian软件源source.list文件格式说明apt系统中sources.list文件的解析 2.刷新软件源使用apt-get update命令，从/etc/apt/sources.list文件中的每一个配置项下载软件包列表，即建立索引文件，存放在/var/lib/apt/lists目录下。 3.安装软件包使用apt-get install xxx命令，会执行以下几个步骤： 本地扫描软件包列表(/var/lib/apt/lists目录)找到软件包。 检查依赖关系，找到支持软件运行的所有软件包。 从软件源指向的镜像站点下载软件包，存放于var/cache/apt/archives目录。 解压软件包，自动完成应用程序的安装配置。 注：1. apt-get install执行时的打印信息就是其步骤过程2. apt的cron脚本会限制var/cache/apt/archives目录的存储空间和其中文件的存放时间 特点相比于dpkg，APT软件包管理的两个特点是： 检查和修复软件包的依赖关系 需要使用Internet网络获取软件包 apt-get常用命令如下： - apt-get update 下载更新软件包列表信息 - apt-get upgrade 软件包升级为最新版本 - apt-get install xxx 安装软件 - apt-get --reinstall install xxx 重新安装软件 - apt-get check 检查是否有损坏的依赖 - apt-get -f install 修复软件包依赖问题 - apt-get remove xxx 卸载软件 - apt-get --purge remove xxx 完全卸载软件 - apt-get autoremove 将不满足依赖关系的软件包自动卸载 - apt-get clean 删除缓存区所有已下载的包文件 - apt-get autoclean 删除缓存区老版本已下载的包文件 注：apt-get autoclean在释放磁盘时会用到 apt-cache常用命令如下： - apt-cache show xxx 获取二进制软件包详细描述信息 - apt-cache search xxx 根据正则表达式检索软件包 - apt-cache depends xxx 查询该软件包的依赖信息 - apt-cache rdepends xxx 查询所有依赖该软件包的软件包 - apt-cache policy xxx 查询软件包安装状态 rpm软件包rpm软件包管理是另外一种软件包管理机制，和deb功能十分相似。在此不再赘述，有需要时请查阅参考资料。 rpm本地安装rpm的功能类似于dpkg yum在线安装yum功能类似于apt，也有相应的配置文件/etc/yum.conf，/etc/yum.repos.d/目录，数据库目录/var/lib/rpm/等。 rpm和yum使用详情，参考linux软件包管理之一（rpm包管理）deb和rpm软件包管理命令对比，参考Linux软件包管理 应用实例值得注意的是，上述两种软件包管理机制适用的Linux平台为Debian和Redhat系统及它们衍生的Linux系统，而对于嵌入式Linux安装软件又有其各自的特殊之处。另外，基于Linux开源的思想，还有一种特别的软件安装方法，即源码安装。 因此，在实践中，有两个方面需要考虑。第一，Linux平台有哪几种软件安装方法可供选择。第二，具体在哪种Linux平台上安装软件，需要注意什么问题。 Linux平台下安装软件的几种方式 使用dpkg、rpm等底层工具安装需要将软件包下载到本地后，再使用命令安装。 使用apt、yum等上层工具安装联网安装，自动检查依赖关系。 源代码编译安装第三方开源软件通用的安装方法，通常经历：下载--解压--./configure--make--make install等步骤。不同的软件以及不同的安装平台具体细节有差别，该方法可做专题研究，尤其是在嵌入式Linux平台移植，可做总结。 其他除了以上安装方法，有的软件提供安装脚本，直接运行即可。还有其他方法参考以下文档。 参考文档：汇总linux下安装软件的几种方式 实践中各平台的操作系统在实践中我使用了四个硬件平台，关于其详细介绍参考嵌入式学习笔记--前言，在此不再赘述。使用cat /proc/version命令或者cat /etc/issue命令查看各平台的操作系统详细信息。总结如下： - 树莓派3 B：Raspbian GNU/Linux 8 - JS991开发板：openwrt - Intel NUC DE3815TYKHE：Wind River Linux 7.0.0.13 - IOT4412/FS4412开发板：Linux version 3.0.15 实例注意事项总结树莓派/Ubuntu说明 树莓派和Ubuntu都基于Debian系统，因此安装软件首选apt工具。 首先尝试apt-cache search xxx 和 apt-get install xxx。 若提供该软件的软件源，则需要使用apt-key命令导入GPG密钥；配置软件源文件，下载至/etc/apt/sources.list.d/或手动创建编辑；再apt-get update和 apt-get install xxx。 对于ppa个人软件包，使用add-apt-repository命令添加软件源，再apt-get update和 apt-get install xxx。 使用git clone、wget等方法下载安装包，使用提供的脚本安装或者编译源码安装。 实践example Ubuntu下安装mosquitto服务器进行mqtt通信实验 Ubuntu下安装Tomcat web应用服务器进行Java后台开发实验 Ubuntu下安装docker，Intel® System Studio IoT Edition进行Intel网关开发 Ubuntu下安装gsoap进行onvif协议开发 树莓派下安装FFmpeg进行视频推流实验 树莓派下安装node、npm，利用AWS IOT JavaScript SDK进行树莓派连接AWS云实验 树莓派下安装Azure IOT开发包进行树莓派连接Azure云实验 注：有的软件安装涉及环境变量配置，和Windows下类似 JS991开发板说明 openwrt系统下软件包管理工具为opkg,通常使用opkg install xxx.ipk。 如果安装失败，提示缺少依赖的库，可以先使用opkg install安装该库或者找到openwrt系统中该动态链接库，将其复制到开发板的/usr/lib下，再安装相关软件。 ipk软件包可以来源于openwrt下载官网，也可以自己制作并在内核中编译生成，具体制作方法另起专题研究。 支持LuCi进行页面可视化安装软件。 参考文档：openwrt安装软件的两个方法 实践example openwrt下移植opencv，进行视频图像处理实验。 Intel NUC DE3815TYKHE说明 wind river Linux系统作为Intel IoT Gateway Software Suite的一部分提供，此处使用的是免费版本Wind River Linux 7.0.0.13。 Wind River Linux 7.0.0.13系统下的软件包后缀为rpm，软件包管理工具为smart update、smart install、smart channel --add等。可能类似rpm软件包管理，具体需深入学习该系统。 若提供软件源，需要使用rpm --import命令导入GPG密钥，然后使用smart channel --add添加软件源，再使用smart update和smart install。 添加软件源镜像所能访问的文件夹需要和操作系统版本保持一致。 支持页面添加源和软件安装。 实践example wind river Linux下安装AWS IOT SDK,进行Intel nuc3815连接AWS云实验 wind river Linux下安装paho.mqtt.c,进行mqtt客户端通信实验。 wind river Linux下安装OpenSSL，用于mqtt安全通信。 声明：文章中涉及的参考文献并不是随意引用，均是经过笔者阅读大量资料筛选后所得，和本文有密切关系，可放心阅读。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>软件包管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--2文本编辑器VIM]]></title>
    <url>%2F2017%2F09%2F27%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--2%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8VIM%2F</url>
    <content type="text"><![CDATA[本篇文章简要叙述文本编辑器VIM的使用，包括VIM的3种模式，常用的功能键，常用的插件配置。同时给出可供参考的IDE，以作扩展学习。 vim编辑器3种模式 命令模式：主要是光标跳转、复制、粘贴、删除。 编辑模式：主要是文字编辑。 底行模式：主要是保存、退出、查找、替换、设置编辑环境。 注：三种模式叫法可能存在差异，理解每个模式下的功能即可 常用功能键与快捷键这里只列举常用的一些功能键和快捷键。 多窗口与多标签 新窗口 Ctrl+shift+n 新标签 Ctrl+shift+t 跳转 跳转到第n行 ngg 查找字符串 正向查找 /str 跳到下一处 n 跳到上一处 N 反向查找 ?str 替换字符串 m行到n行的str1替换为str2 ：m,ns/str1/str2/g 全文str1替换为str2 ：%s/str1/str2/g 注：最后的g表示一行中所有匹配的字符串，不加则只替换第一处 撤销与反撤销 撤销 u 反撤销 Ctrl+r 重复上一修改正文的操作 .(点号) 显示行号 :set number 分屏 竖分屏 :vsp filename 横分屏 :sp filename 比较两个文件 未打开文件时 vimdiff a.c b.c 打开a.c时，和b.c比较 :vert diffsplit b.c 参考文档：Vim入门基础 配置文件与插件网上有许多关于VIM配置的说明，我认为最重要的是知道自己要做什么，而不是盲目的使用教程做复杂的配置。 作为新手，我主要用vim进行C语言开发，我常用以下功能。 - 查看定义(宏、变量、函数名等) - 符号一览(宏、变量、函数名等) - 查看文件目录 - 代码补全 因此需要下载相关插件，并编辑配置文件，以期实现以上功能。其中插件下载后存放于~/.vim文件夹，配置文件为~/.vimrc，当前用户有效。 ctags插件实现查看定义使用步骤 1. 在源码目录下执行ctags -R，生成tags文件 2. 在.vimrc文件中添加:set tags +=源码路径/tags 3. 跳转定义使用Ctrl+] 4. 返回使用Ctrl+t 注：程序修改后，需重新运行ctags -R taglist插件实现符号一览使用步骤 1. 前提：ctags已经打好标签 2. 打开taglist窗口使用:Tlist 3. 光标选择符号，按enter键跳转到定义 4. 光标选择符号，按空格键，在底行显示tag的完整表达 netrw、WinManager插件实现查看文件目录使用步骤 1. 注：netrw已随vim安装，无需下载 2. WinManager的作用是组合netrw窗口和taglist窗口 3. 打开窗口使用wm,关闭窗口再次使用wm 4. 光标选择文件或文件夹，按enter键进入 5. 返回上级目录使用-键 new-omni-completion、SuperTab插件实现自动补全使用步骤 1. 输入几个单词后，按下Tab键进行选择 注：程序修改后，需重新运行ctags -R 参考文档：手把手教你把Vim改装成一个IDE编程环境(图文) IDE编程环境除了VIM编辑器，还有许多集成开发环境可供选择。比如以下两种。 eclipse CDT QT creator 在实践中，我在Ubuntu16.04上安装过Intel® System Studio IoT Edition(linux版)开发Intel NUC DE3815网关的C语言程序，该IDE是基于eclipse的。同时，也使用过eclipse for ARM(windows 32版)开发FS4412裸板的汇编语言程序，并未做深入研究。 个人观点我认为，IDE的使用原理和vim + Makefile + gcc的方式一致，只是在交叉编译环境配置和可视化编程等方面有所不同。 关于vim的高级配置以及IDE的使用，待基础技能熟悉后，视情况再做深入讨论。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统使用--1基本概念]]></title>
    <url>%2F2017%2F09%2F26%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8--1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[本篇文章简要叙述嵌入式Linux中的基本概念：嵌入式系统的定义、Linux的发展、Linux操作系统的组成以及Linux作为嵌入式操作系统的优缺点，以期对嵌入式Linux有一个大致的了解。 嵌入式系统定义嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，对可靠性、成本、功耗、功能、体积有严格要求的专用计算机系统。 Unix家庭树Linux是类Unix系统，通常所谓的Linux系统全称是GNU/Linux。Unix家庭树如下图所示，了解GNU/Linux所在位置。 此外，与GNU/Linux和BSD家族系统有密切关系的是GPL、BSD软件许可协议。关于常见的开源软件许可协议可做专题分析。 Linux操作系统组件Linux操作系统主要由四部分组成：Linux内核、shell、文件系统和应用程序。 Linux内核内核是操作系统的核心，包括设备驱动、内存管理、进程管理、文件系统 、网络管理和系统调用接口。 shellshell是一个命令解释器，它是Linux内核外层的保护工具，完成用户和内核之间的交互。常用的版本为BASH。 文件系统文件系统是文件存放在磁盘等存储介质上的一种组织方式。Linux操作系统中将文件系统组织为一个层次化的树形结构。 个人观点：Linux下一切皆文件，而通信的本质我认为就是文件的读写。 应用程序 参考文档：Linux系统结构 详解 Linux作为嵌入式操作系统的优缺点优点- 低成本开发：开源且免费使用。 - 适用于多种硬件平台：x86、ARM、MIPS、PowerPC等。 - 内核可定制：模块的插入或移除机制。 - 性能优异：占用资源少、运行稳定、速度快。 - 良好的网络支持：实现了TCP/IP协议栈。 缺点- Linux对硬件有一定要求，而嵌入式硬件资源通常有限。 - Linux结构体系复杂，代码量大。 - 产品化时，遇到问题需要自行解决。 - 产品化时，移植优化工作量大。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>unix家庭树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式Linux学习路线]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[概述本篇文章简要说明嵌入式Linux的学习路线，后续系列文章将按照本篇所述内容进行展开。 嵌入式Linux开发基础- Linux操作系统使用 - C语言高级编程 - 数据结构 嵌入式Linux应用层开发- 文件I/O与标准I/O - 进程和线程 - 网络编程 嵌入式Linux底层开发- ARM处理器编程 - ARM硬件接口编程 - 系统移植 - 设备驱动 - Android底层驱动 嵌入式系统项目实战- 电子词典 - 仓储物联系统]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式学习笔记--前言]]></title>
    <url>%2F2017%2F09%2F08%2F%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[写在前面的话动手写博客前，我一直在思考：博客……写点啥，为了啥，有意义么。第一次写博客，难免有些紧张和忐忑。 我从2017年2月到9月系统的学习了嵌入式Linux的相关知识，包括嵌入式Linux应用层和底层开发等。另外，从去年9月工作以来，我在工作项目中也接触了几款嵌入式设备。因此，我希望借写博客开启嵌入式小白的学习成长之旅。 对于开篇的问题，有以下几点说明： 1. 总结的首要目的是梳理知识点，巩固加深理解，熟练掌握开发技能。 2. 总结的内容为嵌入式Linux重点知识整理，掺杂日常实践中的问题分析。 3. 最后，博客不仅分享的是学习资料，也是笔者的学习心得，而后者是不可复制的。我想，这就是最大的意义所在。此外，若这些短文能够带给您一点帮助或启发，那将是我莫大的荣幸。 嵌入式平台树莓派3 B SoC： BCM2837 CPU： ARM Cortex-A53 1.2GHz 四核 GPU： Broadcom VideoCore IV, OpenGL ES 2.0, 1080p 30 h.264/MPEG-4 AVC 高清解码器 内存： 1GB 外设： WiFi、蓝牙4.1、10/100网口、USB2.0*4、microSD、HDMI、3.5mm音频插孔、CSI摄像头接口、DSI显示接口、40pin扩展GPIO OS： Debian GNU/Linux、Fedora、Arch Linux、RISC OS、Windows10、Snappy Ubuntu Core JS9331开发板 SoC： Atheros AR9331 CPU： AR9331 MIPS 24K 400MHz 内存： 64MB DDR2 SDRAM 外存： 8MB/16MB SPI flash 外设： WiFi、10/100网口*2、USB2.0*2、TTL/RS232串口、USB mini串口、LED*4、key*4、板载温度传感器、红外发送接收、5pin扩展GPIO OS： openwrt Intel NUC DE3815TYKHE套件 CPU：Intel x86 Atom E3815 1.4GHz 单核 内存：单条SO-DIMM内存插槽(最大容量8GB) DDR3 缓存：512KB 外存：4GB eMMC闪存、2.5寸SATA硬盘位 外设：半长式mini PCI-E扩展插槽（无线网卡）、10/100/1000网口，USB 3.0、USB 2.0*2、VGA、HDMI、音频插孔 OS：Intel IoT Gateway Software Suite、Ubuntu 16.04 LTS、Wind River Pulsar Linux IOT4412/FS4412开发板 SOC： 三星Exynos4412 CPU： ARM Cortex-A9 1.4GHz 四核 内存： 1GB DDR3 外存： 4GB eMMC 外设： 20针WiFi接口、microSD、USB2.0*2、USB OTG、10/100网口、音频插孔、串口*2、key*5、20PIN扩展GPIO、20针camera接口、HDMI、LVDS_LCD*2、RGB_LCD OS： Android4.2、Linux-QT、Ubuntu 注：此处以IOT4412说明，FS4412与之类似，外设稍有差别 附：uname -a命令结果- 树莓派3 B： Linux raspberrypi 4.9.35-v7+ #1014 SMP Fri Jun 30 14:47:43 BST 2017 armv7l GNU/Linux - JS991开发板： Linux JoySince 3.10.49 #10 Fri Jul 21 18:31:20 CST 2017 mips GNU/Linux - Intel NUC DE3815TYKHE Linux WR-IDP-42C1 3.14.58_IDP-XT_3.1-WR7.0.0.13_idp #1 SMP PREEMPT Tue Jun 7 16:52:19 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux - IOT4412/FS4412开发板 Linux iTOP-4412 3.0.15 #3 SMP PREEMPT Thu Apr 2 18:49:01 PDT 2015 armv7l GNU/Linux]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>学习笔记</tag>
        <tag>嵌入式硬件平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js升级]]></title>
    <url>%2F2017%2F07%2F15%2FNode.js%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Node.js版本更新很频繁，由0.1x版本跃升至4.x乃至目前最新的8.x版本，升级Node.js很有必要 查看Node版本 1$ node -v 安装n模块 1$ npm install -g n 查看所有node版本 1$ n ls 升级Node 12$ n 4.4.0（版本号） # 升级到指定版本$ n stable # 升级最新的稳定版本]]></content>
      <categories>
        <category>日常case</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Git 搭建一个个人博客]]></title>
    <url>%2F2017%2F07%2F04%2FHexo-Git-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Github Pages搭建个人网站 Github Pages是GitHub免费提供给开发者的一款托管个人网站的产品，首先需要创建一个GitHub账号 在GitHub创建一个仓库：username/username.github.io，username是你的账户名，这是特殊的命名约定 在此仓库提交一个index.html文件，网站内容是在master分支下的 访问http://username.github.io，就能看到自己的网站了 绑定独立域名 如果你有自己的域名的话，在之前的仓库点开设置(Settings)，找到GitHub Pages，在Custom domain添加自己的域名，保存(Save)即可 在你的域名注册提供商那里配置DNS解析，获取GitHub的IP地址，添加A记录即可 使用Hexo搭建博客 前提已安装Node.js和Git 安装Hexo 1$ npm install -g hexo-cli 建站 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 安装 hexo-server 1$ npm install hexo-server --save 生成静态文件 1$ hexo generate # 或者 hexo g 启动本地服务 1$ hexo server # 或者 hexo s 查看结果访问http://localhost:4000/，已经可以看到一篇内置的blog了，Hexo使用Markdown解析文章 部署Hexo到Github Pages 安装hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改配置文件_config.xml注：配置文件中，冒号后面一定要加空格 1234deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 执行部署 1$ hexo deploy # 或者 hexo d 使用git部署将我们之前创建的repo克隆到本地，将hexo generate生成public文件夹下的内容copy到本地repo，然后使用git commit提交代码，最后push到远程repo的master branch上即可 查看结果访问http://username.github.io，能看到Hexo内置的blog已经发布到自己的网站了 使用独立域名 123$ cd source/$ touch CNAME$ vim CNAME # 输入你的域名 Hexo主题Next及常用第三方服务 Next主题Hexo支持更换多种主题，本站所用主题是：Next，将喜欢的主题放在themes文件夹内，并修改_config.yml内的theme设定，即可切换主题 1theme: next # Hexo默认主题是landscape 标签与分类确认站点配置文件以及主题配置文件里开启响应设置，新建标签和分类页面内容，在新发布的blog首部设置自定义标签和分类即可 1234567891011121314151617181920212223# 站点配置文件tag_dir: tagscategory_dir: categories # 主题配置文件tags: /tagscategories: /categories # 新建source/tags/index.mdtitle: tagsdate: 2015-10-20 06:49:50type: &quot;tags&quot;comments: false # 新建source/categories/index.mdtitle: categoriesdate: 2015-10-20 06:49:50type: &quot;categories&quot;comments: false # 新发布的blog首部设置categories: 类别tags: [标签1,标签2,标签3] 网站统计百度统计登录百度统计，定位到站点的代码获取页面，复制 hm.js? 后面那串统计脚本 id，修改主题配置文件内的字段 baidu_analytics，值设置成你的百度统计脚本id 12# Baidu Analytics IDbaidu_analytics: **** 阅读次数统计LeanCloud注册LeanCloud帐号，创建一个应用，在应用的配置界面创建Class（名字必须为Counter），由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。在应用Key界面拿到AppID以及AppKey这两个参数，修改主题配置文件内对应的的字段即可。另外，建议开启Web安全选项，在安全中心的Web安全域名中填入我们自己的博客域名，来确保数据调用的安全 1234# leancloud_visitors:enable: trueapp_id: ****app_key: **** 评论系统HyperComments首先需要在文章首部开启评论，Next官网提供的DISQUS、多说、网易云跟帖等都已经停止服务了，只好使用HyperComments，创建一个免费应用即可，拿到WIDGET-CODE，修改主题配置文件内对应的的字段即可 123456# 文章首部设置comments: true # 主题配置文件# Hypercommentshypercomments_id: **** 分享系统jiathis注册jiathis账号，获取uid后更改配置文件内对应的的字段即可 123jiathis: enable: false id: 2139015 搜索服务LocalSearch安装 hexo-generator-searchdb，编辑站点配置文件和主题配置文件 12345678910111213# 安装 hexo-generator-searchdb$ npm install hexo-generator-searchdb --save # 站点配置search: path: search.xml field: post format: html limit: 10000 # 主题配置local_search: enable: true 打赏服务编辑主题配置文件，添加comment和支付二维码即可 1234# 打赏配置 可自己添加reward_comment: 您的支持将鼓励我继续创作！wechatpay: # 微信收款二维码alipay: # 支付宝收款二维码 腾讯公益404页面寻找丢失儿童，让大家一起关注此项公益事业！新建404.html页面，放到主题的source目录下，内容如下 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; &lt;meta name="robots" content="all"/&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>开源工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>